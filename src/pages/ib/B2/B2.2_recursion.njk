---
layout: layouts/base.njk
title: B2.2 Recursion | Study Guide
description: "IB Computer Science Topic B2.2 Recursion: Call Stack, Base Case, Recursive Algorithms (Python)."
is_revision_guide: true
activeSection: ib
breadcrumbs:
  - { label: "Home", href: "index.html" }
  - { label: "IB", href: "ib/index.html" }
  - { label: "B2", href: "ib/B2/index.html" }
  - { label: "Student Resources", href: "ib/B2/student_resources.html" }
  - { label: "B2.2 Recursion", href: "ib/B2/B2.2_recursion.html" }
extraStyles:
  - https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark-reasonable.min.css
scripts:
  - https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js
---
<script>hljs.highlightAll();</script>

<style>
    :root {
        /* Palette specific to Recursion - Magic/Violet Theme */
        --header-violet: #7c3aed;
        --header-fuchsia: #c026d3;
        --header-rose: #e11d48;
        --header-amber: #d97706;

        --bg-body: #f4f6f9;
        --bg-card: #ffffff;
        --text-main: #1f2937;
        --text-muted: #6b7280;

        --tip-bg: #fffae6;
        --tip-border: #ffb300;
        --table-header: #ede9fe;

        /* Spacing */
        --container-width: 1000px;
        --radius: 12px;
        --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .hero {
        background: linear-gradient(135deg, var(--header-violet), #4c1d95);
        color: white;
        padding: 3rem 1.5rem;
        text-align: center;
        margin-bottom: 2rem;
    }
    
    .hero h1 { font-size: 2.5rem; font-weight: 800; margin-bottom: 0.5rem; }
    .hero p { font-size: 1.1rem; opacity: 0.9; }

    /* Main Container */
    .container {
        max-width: var(--container-width);
        margin: 0 auto;
        padding: 0 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 2rem;
    }

    /* Cards */
    .card {
        background: var(--bg-card);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
        border: 1px solid #e5e7eb;
    }

    .card-header {
        padding: 1rem 1.5rem;
        font-weight: 700;
        font-size: 1.25rem;
        color: white;
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    .card-body { padding: 1.5rem; }

    /* Themes */
    .theme-violet .card-header { background-color: var(--header-violet); }
    .theme-fuchsia .card-header { background-color: var(--header-fuchsia); }
    .theme-rose .card-header { background-color: var(--header-rose); }
    .theme-amber .card-header { background-color: var(--header-amber); }
    .theme-dark .card-header { background-color: #374151; }

    h2 { font-size: 1.5rem; margin-bottom: 1rem; color: var(--text-main); }
    h3 { font-size: 1.1rem; margin-bottom: 0.5rem; color: #374151; font-weight: 600; margin-top: 1rem; }

    ul { list-style-position: inside; margin-bottom: 1rem; }
    li { margin-bottom: 0.5rem; }

    /* Tips */
    .tip-box {
        background-color: var(--tip-bg);
        border-left: 5px solid var(--tip-border);
        padding: 1rem;
        border-radius: 4px;
        margin-top: 1.5rem;
    }
    .tip-title { font-weight: 700; color: #b45309; }

    code {
        font-family: 'JetBrains Mono', monospace;
        background-color: #f3f4f6;
        padding: 0.1rem 0.3rem;
        border-radius: 4px;
        font-size: 0.9em;
        color: #d10056;
    }
    pre { border-radius: 8px; overflow: hidden; margin: 1rem 0; }
    pre code { background-color: transparent; padding: 1rem; color: inherit; }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
    @media (max-width: 768px) { .grid-2 { grid-template-columns: 1fr; } }
    .mb-4 { margin-bottom: 1rem; }
</style>

<!-- Header -->
<header class="hero">
    <div class="nav-container">
        <h1>Recursion</h1>
        <p>Theory, Stack Operations & Python Implementations</p>
    </div>
</header>

<main class="container">

    <!-- 1. THEORY (Violet) -->
    <section id="theory" class="card theme-violet">
        <div class="card-header">
            <i class="fa-solid fa-brain"></i> Understanding Recursion & The Stack
        </div>
        <div class="card-body">
            <p class="mb-4"><strong>Recursion</strong> is a process where a function calls itself to solve a smaller instance of the same problem. It continues until a stopping condition is met. Think of it like a set of Matryoshka dolls.</p>

            <div class="grid-2">
                <div>
                    <h3>Key Components</h3>
                    <ul>
                        <li><strong>Base Case</strong>: The terminating scenario (e.g., <code>if n == 0</code>). Stops the recursion.</li>
                        <li><strong>General (Recursive) Case</strong>: The logic that calls the function again with modified data (e.g., <code>n - 1</code>).</li>
                        <li><strong>Winding</strong>: Building up the stack of calls.</li>
                        <li><strong>Unwinding</strong>: Returning results back down the stack.</li>
                    </ul>
                </div>
                <div>
                    <h3>The Role of the Stack</h3>
                    <p>When a function calls itself, the computer pauses the current function and saves its state (variables, return address) onto the <strong>Call Stack</strong>.</p>
                    <ul>
                        <li><strong>Push</strong>: Each new call is pushed onto the stack.</li>
                        <li><strong>Pop</strong>: When a Base Case is reached, functions return and are popped off one by one.</li>
                        <li><strong>Stack Overflow</strong>: Occurs if there is no Base Case (infinite recursion fills the memory).</li>
                    </ul>
                </div>
            </div>

            <div class="tip-box">
                <span class="tip-title"><i class="fa-solid fa-lightbulb"></i> Why Use Recursion?</span>
                <p>It simplifies code for problems that have repetitive sub-structures (like trees, sorting, graph traversal). While sometimes less memory-efficient than loops (iteration), it is often more readable and elegant for complex algorithms.</p>
            </div>
        </div>
    </section>

    <!-- 2. BASIC CALCULATIONS (Fuchsia) -->
    <section id="basic" class="card theme-fuchsia">
        <div class="card-header">
            <i class="fa-solid fa-calculator"></i> Basic Calculations
        </div>
        <div class="card-body">
            <div class="grid-2">
                <div>
                    <h3>Sum of Natural Numbers</h3>
                    <p>Calculates <code>1 + 2 + ... + n</code>.</p>
                    <pre><code class="python">def sum_natural(n):
    if n <= 0:  # Base Case
        return 0
    else:       # Recursive Case
        return n + sum_natural(n - 1)

print(sum_natural(5)) # Output: 15</code></pre>
                </div>
                <div>
                    <h3>Factorial (n!)</h3>
                    <p>Calculates <code>n * (n-1) * ... * 1</code>.</p>
                    <pre><code class="python">def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5)) # Output: 120</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- 3. BINARY SEARCH (Rose) -->
    <section id="search" class="card theme-rose">
        <div class="card-header">
            <i class="fa-solid fa-magnifying-glass"></i> Recursive Binary Search
        </div>
        <div class="card-body">
            <p class="mb-4">Binary Search finds an element in a <strong>sorted</strong> list by repeatedly halving the search interval.</p>

            <pre><code class="python">def binary_search_recursive(arr, target, low, high):
    # Base Case: Target not found
    if low > high:
        return -1
    
    mid = (low + high) // 2
    
    # Base Case: Target found
    if arr[mid] == target:
        return mid
    
    # Recursive Cases
    elif arr[mid] > target:
        return binary_search_recursive(arr, target, low, mid - 1)
    else:
        return binary_search_recursive(arr, target, mid + 1, high)

# Usage
nums = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
result = binary_search_recursive(nums, 23, 0, len(nums)-1)
print(f"Index: {result}") # Output: Index: 5</code></pre>

            <div class="tip-box">
                <span class="tip-title"><i class="fa-solid fa-stopwatch"></i> Efficiency</span>
                <p>Time Complexity: <strong>O(log n)</strong>. This is extremely fast compared to Linear Search O(n).</p>
            </div>
        </div>
    </section>

    <!-- 4. SORTING (Amber) -->
    <section id="sort" class="card theme-amber">
        <div class="card-header">
            <i class="fa-solid fa-arrow-down-zm"></i> Recursive Sorting
        </div>
        <div class="card-body">
            <div class="grid-2">
                <div>
                    <h3>Recursive Bubble Sort</h3>
                    <p>Not commonly used, but demonstrates the concept. It pushes the largest element to the end recursively.</p>
                    <pre><code class="python">def bubble_sort_rec(arr, n):
    # Base Case: 1 element is already sorted
    if n == 1:
        return
    
    # One pass to move largest to end
    for i in range(n - 1):
        if arr[i] > arr[i + 1]:
            arr[i], arr[i + 1] = arr[i + 1], arr[i]
            
    # Recur for remaining n-1 elements
    bubble_sort_rec(arr, n - 1)

data = [64, 34, 25, 12, 22, 11, 90]
bubble_sort_rec(data, len(data))</code></pre>
                </div>
                <div>
                    <h3>Quick Sort</h3>
                    <p>A "Divide and Conquer" algorithm. It picks a pivot and partitions the array around it.</p>
                    <pre><code class="python">def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0]
        # Elements less than pivot
        less = [x for x in arr[1:] if x <= pivot]
        # Elements greater than pivot
        greater = [x for x in arr[1:] if x > pivot]
        
        return quick_sort(less) + [pivot] + quick_sort(greater)

data = [10, 7, 8, 9, 1, 5]
sorted_data = quick_sort(data)
print(sorted_data)</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- 5. TOWER OF HANOI (Violet) -->
    <section id="hanoi" class="card theme-violet">
        <div class="card-header">
            <i class="fa-solid fa-cubes-stacked"></i> Tower of Hanoi
        </div>
        <div class="card-body">
            <p class="mb-4">The classic problem: Move <code>n</code> disks from Source to Destination node, using an Auxliary node, without ever placing a larger disk on a smaller one.</p>

            <pre><code class="python">def tower_of_hanoi(n, source, auxiliary, destination):
    if n == 1:
        print(f"Move disk 1 from {source} to {destination}")
        return
        
    # Move n-1 disks from Source to Auxiliary
    tower_of_hanoi(n - 1, source, destination, auxiliary)
    
    # Move nth disk from Source to Destination
    print(f"Move disk {n} from {source} to {destination}")
    
    # Move n-1 disks from Auxiliary to Destination
    tower_of_hanoi(n - 1, auxiliary, source, destination)

# Solve for 3 disks
tower_of_hanoi(3, 'A', 'B', 'C')</code></pre>

            <div class="tip-box">
                <span class="tip-title"><i class="fa-solid fa-wand-magic-sparkles"></i> The Magic</span>
                <p>This solution is elegantly simple (3 lines of logic) yet solves a complex problem that requires <code>2^n - 1</code> moves. It assumes we can trust the recursive calls to handle the smaller towers.</p>
            </div>
        </div>
    </section>

</main>
