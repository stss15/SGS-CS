# Slide Plan: 7.4 Standard Methods of Solution

**Goal:** Master the five standard algorithms required for IGCSE: Totalling, Counting, Max/Min/Average, Linear Search, Bubble Sort. Know when to use each, and how to write them with 1-based indices.

**Pedagogy:** Toolbox approach. Each algorithm is introduced with the “why”, a visual, a 1-based pseudocode template, and a mini test to spot off-by-one errors.

---

## 1. Title Slide
- **Type:** Title
- **Content:**
  - Main Title: 7.4 Standard Methods of Solution
  - Sub-title: Topic 7: Algorithm Design and Problem Solving
- **Notes:** Standard title layout.

## 2. Hook / Big Question
- **Type:** Concept (Horizontal)
- **Content:**
  - **Question:** Why reinvent the wheel?
  - **Visual:** Well-shaped wheel vs a square block.
  - **Key Idea:** These standard algorithms are reliable building blocks. Learn the patterns, not just the lines.

## 3. Foundations: Totalling & Counting
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Add Up and Count Up
  - **Reminder:** Always initialise (`Total <- 0`, `Count <- 0`) **before** the loop.

### 3.1 Vertical Deep Dive: Worked Patterns
- **Type:** Vertical Stack
- **Slide 1 (Counting):**
  - Scenario: Count students who scored above 50.
  - Pseudocode (1-based):
    ```
    PassCount <- 0
    FOR i <- 1 TO ClassSize
      IF Mark[i] > 50 THEN PassCount <- PassCount + 1
    NEXT i
    ```
- **Slide 2 (Totalling):**
  - Scenario: Sum all marks.
  - Pseudocode:
    ```
    Total <- 0
    FOR i <- 1 TO ClassSize
      Total <- Total + Mark[i]
    NEXT i
    ```
  - **Check:** What happens if you forget `Total <- 0`? (Garbage carries over.)

## 4. Extremes and Average
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Max, Min, Average
  - **Idea:** Assume the first value wins, then challenge it.

### 4.1 Vertical Deep Dive: Pseudocode Templates
- **Type:** Vertical Stack
- **Slide 1 (Max/Min):**
  - Use first element to avoid impossible starters:
    ```
    Max <- Mark[1]
    Min <- Mark[1]
    FOR i <- 2 TO ClassSize
      IF Mark[i] > Max THEN Max <- Mark[i]
      IF Mark[i] < Min THEN Min <- Mark[i]
    NEXT i
    ```
  - **1-based emphasis:** Start at 2 because first item is already used.
- **Slide 2 (Average):**
  - Build on totalling:
    ```
    Total <- 0
    FOR i <- 1 TO ClassSize
      Total <- Total + Mark[i]
    NEXT i
    Average <- Total / ClassSize
    ```

## 5. Searching
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Linear Search (Stop Early)
  - **Visual:** Finger scanning a list until match found.

### 5.1 Vertical Deep Dive: Find or Fail
- **Type:** Vertical Stack
- **Slide 1 (Flow):**
  - Start at position 1, move forward until found or past the end.
- **Slide 2 (Pseudocode with Flag):**
    ```
    OUTPUT "Enter name to find"
    INPUT Target
    Found <- FALSE
    Position <- 1
    REPEAT
      IF Target = StudentName[Position] THEN
        Found <- TRUE
      ELSE
        Position <- Position + 1
      ENDIF
    UNTIL Found OR Position > ClassSize
    IF Found THEN
      OUTPUT Target, " found at position ", Position
    ELSE
      OUTPUT Target, " not found"
    ENDIF
    ```
  - **Check:** What is the last valid index? (ClassSize, because lists start at 1.)

## 6. Sorting
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Bubble Sort (Swap Neighbours)
  - **Visual:** Largest bubble drifting to the end each pass.

### 6.1 Vertical Deep Dive: Passes & Swaps
- **Type:** Vertical Stack
- **Slide 1 (Logic):**
  - Compare `List[i]` with `List[i+1]`. Swap if out of order. After one full pass, the last element is correct.
- **Slide 2 (Pseudocode):**
    ```
    Last <- Length
    REPEAT
      Swap <- FALSE
      FOR i <- 1 TO Last - 1
        IF List[i] > List[i + 1] THEN
          Temp <- List[i]
          List[i] <- List[i + 1]
          List[i + 1] <- Temp
          Swap <- TRUE
        ENDIF
      NEXT i
      Last <- Last - 1
    UNTIL (NOT Swap) OR Last = 1
    ```
  - **Key Detail:** Loop stops early when no swaps; inner loop uses `Last - 1` because we always compare `i` with `i+1`.

## 7. Choosing the Right Tool
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Toolbox Selector
  - Present 3 short scenarios; learners pick algorithm:
    - “How many students passed?” → Counting.
    - “What is the highest score?” → Max.
    - “Is ‘Sami’ in the list?” → Linear search.

## 8. Plenary: Name that Algorithm
- **Type:** Quiz (Vertical Stack)
- **Slide 1:** `Total <- Total + Number` inside a loop → **Totalling**.
- **Slide 2:** `IF Value > Max THEN Max <- Value` → **Finding Maximum**.
- **Slide 3:** `REPEAT ... Swap ... UNTIL NOT Swap` → **Bubble Sort**.
- **Slide 4:** `REPEAT ... UNTIL Found OR Position > Length` → **Linear Search**.
