# Slide Plan: 1.1 Number Representation

**Goal:** Explain binary, denary, and hexadecimal systems, how to convert between them, and how to perform binary operations (addition, shifts, two's complement).

**Pedagogy:** Question First. Start with the "Why" (Why binary? Why hex?). Use vertical stacks for worked examples and deep dives.

---

## 1. Title Slide
- **Type:** Title
- **Content:**
  - Main Title: 1.1 Number Representation
  - Sub-title: Topic 1: Data Representation | The Language of Computers
- **Notes:** Standard title layout.

## 2. Hook / Big Question
- **Type:** Concept (Horizontal)
- **Content:**
  - **Question:** Why do powerful computers only use 0s and 1s?
  - **Visual/Layout:** Split screen.
    - Left (The Mystery): A complex video game or AI.
    - Right (The Reality): Billions of tiny switches (Transistors).
  - **Key Idea:** It's not about math; it's about physics. Switches are either ON (1) or OFF (0).

## 3. The Number Systems (Concept Loop)
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** The Three Systems
  - **Content:**
    - Denary (Base 10): Humans (10 fingers). 0-9.
    - Binary (Base 2): Computers (2 states). 0-1.
    - Hexadecimal (Base 16): Humans + Computers (Shortcuts). 0-9, A-F.
  - **Interaction:** Fragment reveal for each system.

### 3.1 Vertical Deep Dive: Binary Basics
- **Type:** Vertical Stack
- **Slide 1 (Concept):** Place Values.
  - Show the powers of 2 table: 128, 64, 32, 16, 8, 4, 2, 1.
  - Example: 00001001 = 8 + 1 = 9.
- **Slide 2 (Interactive):** Quick Conversion.
  - Question: What is 10101010 in Denary?
  - Answer (Fragment): 128 + 32 + 8 + 2 = 170.

### 3.2 Vertical Deep Dive: Hexadecimal Basics
- **Type:** Vertical Stack
- **Slide 1 (Concept):** Why Hex?
  - Binary is too long for humans to read/debug. Hex is a shorthand.
  - 4 bits (Nibble) = 1 Hex digit.
- **Slide 2 (The Code):** The A-F Problem.
  - 0-9 are easy.
  - 10=A, 11=B, 12=C, 13=D, 14=E, 15=F.
  - **Misconception Check:** "10" in Hex is not ten, it's sixteen. Ten is "A".

## 4. Conversions (Skill Loop)
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Converting Numbers
  - **Question:** How do we translate between these worlds?
  - **Visual:** A cycle diagram showing Binary <-> Denary <-> Hex.

### 4.1 Vertical Deep Dive: Binary <-> Denary
- **Type:** Vertical Stack
- **Slide 1 (Binary to Denary):** The Table Method.
  - Write headings (128...1). Write bits. Add values where 1.
- **Slide 2 (Denary to Binary):** The Subtraction Method.
  - Does 128 fit? Yes -> 1, subtract. No -> 0. Repeat.
  - Example: 45. (32 fits, rem 13. 8 fits, rem 5. 4 fits, rem 1. 1 fits). -> 00101101.

### 4.2 Vertical Deep Dive: Binary <-> Hex
- **Type:** Vertical Stack
- **Slide 1 (The Split):**
  - Split binary byte into two nibbles (4 bits).
  - Convert each nibble to Hex.
  - Example: 1100 0101 -> (12=C) (5) -> C5.
- **Slide 2 (Hex to Binary):**
  - Reverse it. Write 4 bits for each Hex digit.
  - Example: 2B -> (0010) (1011) -> 00101011.

### 4.3 Vertical Deep Dive: Denary <-> Hex
- **Type:** Vertical Stack
- **Slide 1 (The Bridge):**
  - Don't do it directly. Use Binary as the bridge.
  - Denary -> Binary -> Hex.
  - Hex -> Binary -> Denary.
  - It's safer and less math-heavy.

## 5. Uses of Hexadecimal
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Where do we see Hex?
  - **List:**
    - HTML/CSS Colour Codes (#FF0000).
    - MAC Addresses (Network ID).
    - Memory Dumps (Debugging).
    - Assembly/Machine Code display.
  - **Key Idea:** It's for **humans** to read binary easier. Computers don't "use" hex; they convert it to binary instantly.

## 6. Binary Addition
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Adding Binary
  - **Rules:**
    - 0+0 = 0
    - 0+1 = 1
    - 1+1 = 0 (carry 1)
    - 1+1+1 = 1 (carry 1)

### 6.1 Vertical Deep Dive: Overflow
- **Type:** Vertical Stack
- **Slide 1 (The Problem):**
  - What happens if the result is 9 bits? (e.g., 255 + 1).
  - **Overflow Error:** The computer drops the extra bit or crashes.
  - Visual: A bucket overflowing.

## 7. Logical Shifts
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Logical Binary Shifts
  - **Action:** Moving bits left or right.
  - **Effect:**
    - Left Shift = Multiply by 2.
    - Right Shift = Divide by 2.
  - **Visual:** Bits sliding over, empty spots filled with 0.

## 8. Two's Complement (Negative Numbers)
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Representing Negative Numbers
  - **Problem:** How do we store -5 with only 0s and 1s? (No minus sign allowed).
  - **Solution:** Two's Complement. The Most Significant Bit (MSB) becomes negative (-128).

### 8.1 Vertical Deep Dive: The Method
- **Type:** Vertical Stack
- **Slide 1 (Step-by-Step):**
  - To find -Number:
  1. Write positive binary.
  2. Flip all bits (0->1, 1->0).
  3. Add 1.
- **Slide 2 (Example):**
  - Find -5.
  - +5 = 00000101.
  - Flip = 11111010.
  - Add 1 = 11111011.
  - Check: -128 + 64 + 32 + 16 + 8 + 2 + 1 = -5.

## 9. Plenary: True or False?
- **Type:** Quiz (Vertical Stack)
- **Slide 1 (Intro):** Misconception Check.
- **Slide 2 (Q1):** "Hexadecimal is used because it takes up less storage space than binary."
  - **Answer:** False. It takes up less *screen* space for humans. In storage, it's all binary.
- **Slide 3 (Q2):** "A logical left shift divides a number by 2."
  - **Answer:** False. Left is multiply. Right is divide.
- **Slide 4 (Q3):** "In Two's Complement, the first bit (MSB) represents -128."
  - **Answer:** True. This allows us to have negative values.
- **Slide 5 (Q4):** "An overflow error occurs when a number is too big to fit in the available bits."
  - **Answer:** True.

---
