# Slide Plan: 1.2 Text, Sound and Images

**Goal:** Explain how non-numeric data (text, sound, images) is converted into binary for computer processing, covering character sets, sampling, and bitmaps.

**Pedagogy:** Question First. Focus on the "Transformation" process (Real World -> Binary).

---

## 1. Title Slide
- **Type:** Title
- **Content:**
  - Main Title: 1.2 Text, Sound & Images
  - Sub-title: Topic 1: Data Representation | Digitising the World
- **Notes:** Standard title layout.

## 2. Hook / Big Question
- **Type:** Concept (Horizontal)
- **Content:**
  - **Question:** How do we turn a song or a photo into numbers?
  - **Visual:** A waveform turning into 010101, or a zoomed-in pixel grid.
  - **Key Idea:** Everything is binary. We just need a "code" or a "model" to map reality to numbers.

## 3. Text Representation
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Character Sets
  - **Definition:** A map that links every character to a unique number (Code Point).
  - **The Evolution:** ASCII -> Extended ASCII -> Unicode.

### 3.1 Vertical Deep Dive: ASCII vs Unicode
- **Type:** Vertical Stack
- **Slide 1 (ASCII):**
  - 7-bit (128 characters).
  - English only (A-Z, 0-9, punctuation).
  - Example: 'A' = 65.
- **Slide 2 (The Problem):**
  - What about French accents? Chinese characters? Emojis? ðŸ˜±
  - ASCII isn't enough.
- **Slide 3 (Unicode):**
  - The Universal Standard.
  - Uses more bits (up to 32, usually variable via UTF-8).
  - Covers every language + emojis.

## 4. Sound Representation
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Digital Audio
  - **Question:** Sound is a wave (analogue). Computers are digital. How do we bridge the gap?
  - **Answer:** Sampling. Taking snapshots of the wave amplitude at regular intervals.

### 4.1 Vertical Deep Dive: Sampling Parameters
- **Type:** Vertical Stack
- **Slide 1 (Sample Rate):**
  - How *often* we take a snapshot.
  - Measured in Hz (samples per second).
  - Higher Rate = Better Quality (captures high notes) but Larger File.
  - Nyquist Theorem: Must be 2x the highest frequency.
- **Slide 2 (Sample Resolution / Bit Depth):**
  - How *detailed* each snapshot is.
  - Measured in bits per sample.
  - Higher Resolution = Less "noise", smoother wave, but Larger File.
- **Slide 3 (Calculating Size):**
  - Formula: Rate x Resolution x Duration x Channels.
  - Example: 44,100 Hz x 16 bits x 10s x 2 (Stereo).

## 5. Image Representation (Bitmaps)
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Bitmap Images
  - **Concept:** A grid of pixels (Picture Elements).
  - **Colour Depth:** How many bits per pixel?
    - 1-bit = Black/White.
    - 8-bit = 256 colours.
    - 24-bit = True Colour (16.7M colours).

### 5.1 Vertical Deep Dive: Image Size & Quality
- **Type:** Vertical Stack
- **Slide 1 (The Trade-off):**
  - Higher Resolution (more pixels) = Sharper image.
  - Higher Colour Depth (more bits/pixel) = Better colours.
  - **Cost:** File size explodes.
- **Slide 2 (Calculation):**
  - Formula: Width x Height x Colour Depth.
  - Example: 100 x 100 pixels @ 8-bit depth = 10,000 x 8 = 80,000 bits.

## 6. Vector Graphics (The Alternative)
- **Type:** Concept (Horizontal)
- **Content:**
  - **Title:** Vectors vs Bitmaps
  - **Concept:** Vectors store *maths* (shapes, lines, coordinates), not pixels.
  - **Pros:** Scale infinitely without pixelation (great for logos). Small file size for simple shapes.
  - **Cons:** Can't do photorealism (bad for photos).

## 7. Plenary: True or False?
- **Type:** Quiz (Vertical Stack)
- **Slide 1 (Intro):** Misconception Check.
- **Slide 2 (Q1):** "ASCII can store emojis."
  - **Answer:** False. ASCII is only 7-bit (128 chars). You need Unicode for emojis.
- **Slide 3 (Q2):** "Increasing the sample rate improves the sound quality."
  - **Answer:** True. It captures higher frequencies more accurately.
- **Slide 4 (Q3):** "A vector image gets blurry when you zoom in."
  - **Answer:** False. Vectors are math-based and scale perfectly. Bitmaps get blurry (pixelated).
- **Slide 5 (Q4):** "Image file size = Width x Height x Colour Depth."
  - **Answer:** True. (In bits).

---
