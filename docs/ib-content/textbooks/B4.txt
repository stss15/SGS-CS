B4 Abstract data types (ADTs) (HL)

(®Tok

F
o
=
ks

Areas of Knowledge (AOKs) and ADTs: Guiding questions
B How does abstraction in ADTs mirror abstraction in other disciplines?
B To what extent is modularity essential for organizing and simplifying complex systems?

-

Abstraction and modularity are key concepts in ADTs. In groups, investigate how
abstraction and modularity are applied in their assigned AOK, such as natural sciences,
arts and mathematics. Consider:
B How is abstraction used to simplify complex ideas?
B Are there risks or benefits to simplifying reality through abstraction?
B How does modularity help organize knowledge or creativity in these fields?
Present your findings and discuss as a class.

B4.1.2 Linked lists
head—(1] (0

7

12

5

—

»NuLL

M Linked list structure

A linked list consists of two main elements: nodes and pointers.
Nodes are the data element of the list. This could be a single piece of data, or it may be an

4 Node: a basic unit
of a data structure,

object containing multiple data. There are two particularly important nodes: the head and the

e.g. a linked list ortree,

tail. The head is the first node in the linked list and the tail is the last. These help us navigate

which contains data
and typically links to or

through the linked list.

references other nodes.

# Pointer: a variable
that stores the memory
address of another
variable, typically used
in programming to
reference, or access, the

Pointers are contained within the node. These point to the next node in the list (and

sometimes the previous). A pointer may also be referred to as a reference, as it refers to the
memory address of where the next node resides.

(;Top tip!

location of data stored

in memaory.

M A trail of elephants (nodes), linked by their tails and trunks (pointers)

To visualize a linked list, you might imagine it as a chain of elephants, where each elephant
represents a node. The trunk of one elephant extends to the tail of the next, similar to how pointers
connect one node to another in a linked list.

Bl Advantages and disadvantages of linked lists
Advantages
B Dynamic data structures: Due to their implementation, linked lists are dynamic data
structures. This means that they can grow and shrink in size as we add and remove nodes.
This is unlike an array, which is a static data structure.

B4.1 Fundamentals of abstract data types

ATNO TH

B Memory utilization: Linked lists can be more efficient with memory usage, as they do not
create a reserved space in memory like an array does when it is declared.
B Efficient insertion and deletion: Linked lists generally outperform arrays when inserting

or deleting data due to their dynamic nature.
# Heap space: a region
of dynamically allocated
memory managed by
the operating system
where programs store
variables and data
structures that require
memory allocation
during runtime, allowing
for flexible memory
usage that can grow
and shrink as needed by
the application.

Disadvantages
B Sequential access: As linked lists cannot be accessed via an index like arrays, searching

a linked list requires a linear search algorithm, where you start at the head node and
continue traversing until you find what you are looking tor. This means that using a binary
search algorithm, for example, is not possible on a linked list. For large data structures,
this restriction when searching can be very time consuming when compared to accessing
an array.
B Memory utilization: Each node requires a reference to the next (and possibly the previous)

node, as well as storing the data within it. This takes up system resources in the primary
memory. As linked lists can grow, they potentially can go beyond the system resources that
are available, causing a heap exhaustion as the system will run out of heap space.

B Types of linked lists
Singly linked lists
node
—r—

|

head—» A

:

|

data

B

C

D

»NULL

pointer

W Singly linked list

This is the simplest of the three types. Each node contains a single pointer pointing to the next
node in the list. The tail nodes contain a pointer that points to null (or none). This can be used

to recognize the end of the list when traversing it.

Doubly linked lists
next pointer
head

NULL

null «——

|

A

C

B

e

—

D

previous pointer
M Doubly linked list

These differ from singly linked lists because the nodes have two pointers — one reference to the

next node in the list and one to the previous. This allows for easier traversing of the list, as you
can move forward and backward with ease.
Circular linked lists
head —»

— A

B

C

M Circular linked list

B4 Abstract data types (ADTs) (HL)

These are similar to singly linked lists, but with one major difference: the tail node, instead of
pointing to null, points back to the head node. This allows for circular, continuous traversal of

I
=

the list. Doubly linked lists can also be implemented in this manner.

g

=
=<

1

Sketch out a singly linked list containing the numbers 1 to 5.

2

Sketch out a doubly linked list containing the names of five of your classmates.

3

Sketch out a circular linked list containing the names of five of your idols.

(;Common mistake
Do not forget to label the head and to paint the tail node to null (or to the head node in a circular
linked list).

(;Top tip!
Remember to clearly show the node, as illustrated above. It should be represented as a box, divided
into either two or three sections. The pointers should be arrows clearly indicating the node they are
referring to.

B4.1.3 Linked lists
B Linked list operations
These steps all refer to the operations based on a singly linked list.

Traversal / search
This is essentially a linear traversal / search, where you start at the beginning of the linked list
and move along the list, following the pointers to the nodes.
1

Start with the head pointer to find the first node in the linked list.

2 From this node, follow the pointer within the node to the next node.
3

Repeat step 2 until you find the node you are searching for or until the pointer points to

null / none, which means you have reached the end of the list.

Insertion
There are three methods for inserting into a linked list. Which one you use depends on where
you need to insert the node.
Inserting at the beginning:

Z

head —»
1

———NULL

A

>

B

— 1 »nNULL

Create a new node.

B4.1 Fundamentals of abstract data types

@

2

——> NULL

Point the new node to the current head node.

Z

i

N

A

—>NULL

3 Update the head pointer of the linked list to the new node.

Inserting at the end:
— NULL

head —>|

1

A

—1—> NULL

Create a new node.
—n

head —|

2
3

I

7

nuLL

Find the last node by traversing the list until you find the tail node that points to null.
Point the current tail node to the new node (the new node pointer has not been set, so it
will point to null).

Inserting in the middle:

1=

head —»|

A

—>NULL

N —|

ATNO TH

A

head

C

1

Create a new node.

2

Traverse the list to find the node after which you want to insert the new node.

NULL

B4 Abstract data types (ADTs) (HL)

=
o
Z
25

\
head ——> f\
3

B

C

NULL

Set the new node’s pointer to point to the newly found node’s pointer (at this point, both
nodes will be pointing to the next node in the list).

vl
head ——> A\
4

B

Z [ 5]

7

C

——>NULL

Set the newly found node’s pointer to the new node.

(;Common mistake
Be careful not to complete action 4 before action 3 when inserting into the middle of the linked
list. If you do this, you will lose any pointers to the second part of the list, and every node beyond

the point of the insertion will be lost.

Deletion
There are also three methods for deleting trom a linked list. Which one you use depends on
where you need to delete the node.
Deleting the first node:

head—
1

5 A

B

Check whether the list is empty. (If the head pointer is already null, the list is emprty.)

head

A

>

Tee,2ZMemeR
0 .o

2

———————>NULL

B

—————NuULL

Set the head pointer to the new first node’s pointer. (Now nothing is pointing to the
original first node, which eliminates it from the list. Most high-level languages have
garbage collection to realize this and clear it up without you having to delete it.)

P—

Deleting a middle node:

head —| A

1

a

B

C

NULL

Traverse the list, starting from the head, to find the node you want to delete.

B4.1 Fundamentals of abstract data types

@

=<

visited node.

head ——> A

B

C

NULL

2 If you find the node you want to delete, use the previously visited node’s pointer and adjust
it to point to the found node’s pointer. (Now nothing is pointing to the found node, which
climinates it from the list.)

Deleting the end node:
le—a

ATNO TH

b While doing this, you will need to manually keep a pointer / reference to the previously

head——»| A

B

NULL

!
1

a

This process is similar to the deletion from a middle node. Traverse the list, starting
from the head, until you find the tail node pointing to null.

b While doing this, you will need to manually keep a pointer / reference to the previously
visited node.

head——» A

=

B

NULL

\Nuu
2 Adjust the previously visited node’s pointer to point to null (or none).

Draw a singly linked list with the following names: Aarav, Yuki, Sofia, Jamal and Elena.
With the aid of diagrams:
1

Show the steps to insert Nia after Sofia.

2

Show the steps to delete Elena.

3

Show the steps to add Liam at the head.

B Construct linked lists
Initial set-up and traversal
Each linked list has a class that is the starting point when creating a linked list. This often just
includes a single instance variable: the pointer to the first node (the head).
We will also create a method that traverses the list to ourpur the contents. Take note of how
the loop works. We initially get access to the first node through the head pointer, and then we
traverse through the nodes until we come to the tail node that points to null or none.

B4 Abstract data types (ADTs) (HL)

Python

T
o
=
ks

class LinkedList:
"mn Constructor """

def

init

-~

(self):

self.head = None

# Initialize the head pointer

"niFunction te print the linked lisg"""
def print list(self):
current = self
. head # Set to first node
while current

!= None:

# Loop until no further nodes

print (current .data,

end="

-> ")

# Output node data

current = current.next # Move pointer to next node

T
T T T TP T P TP PP PP

print ("None")

Java
public class LinkedList {
ListNode head;

// Head of the list

// Method to print the LinkedList

public void printList()

({

ListNode n = head;

//

while

{ // Loop until no further nodes

(n != null)

Set to first node

System.out.print(n.data + " -> ");
// data

// Output node

n = n.next; // Move pointer to next node

}
——

System.out .println ("NULL") ;

}
We then create a node class that contains data and at least one pointer. If we were creating
a doubly linked list, we would have a second variable (self .previous for Python, or
ListNode previous
in Java).

Python
class ListNode:
" Constructor
def

init

(1 parameter data with a default value of 0)

(self,

self.data

"""

data=0):

data

self .next = None

B4.1 Fundamentals of abstract data types

@

Java
class ListNode {
int data;

// This example will create a node with data of type int,

but you

// may use any type here depending on your needs
ListNode next;

// Constructor to create a new node
ListNode (int d)
data

{

d;

next = null;

// Set to null

——

AINO TH

HH
H
HH
H

Insertion
The insertion method should be created inside the LinkedList class. This should have a
parameter to receive the data passed to it. From there, it should create a new node with that

data and insert it into the correct position in the list. Remember that there are three different
insertion methods: at the beginning, in the middle or at the end.
The insert_after wvalue method assumes we want to insert after a found value. This
could be implemented in different ways. It could be inserted in a certain position or after a

node that has already been identified and passed as a parameter.
e

i

1

e

e

e

i

et

e

sl

| Python
:

iy |

1

|

def insert_at beginning(self,

data):

:

1

new node = ListNode(data) # Create the new ncde with the data given

1

:

new_node.next = self.head # Set new node pointer tc current head node

:

:

self.head = new _node # Set head peointer tc new node

:

|

1
:
1

W

1

Inserts a new node with 'data' after the first node found with 'target
value'.

1

:

If

:

1

'target value'

is not found,

does not insert the new node.

:

def insert after value(self,

:

current = self.head

target value,

data):

:
:

:

while current is nct None:

:

:

if current.data == target value: # If we find the node to insert after

:

1
:

new_node = ListNode(data) # Create a new node with provided data
newnode.next = current.next # Set new node pointer to the same

:

:

# pointer as the found node

:

:

current .next = new node # Set the found node pointer to the new

:

1

# node

1

:

return # We can now end the method early

:

:

current = current.next # Otherwise move to the next node

:

print (E"Node with data {target value} not found.")

:

# not find our target

B o

o

o

R

O

RN R

R RN RN MR N RN R

:

# If loop ends we did

:
:

N

N M

M

RN

N RN

N M RN M

RN M

N

N M

N RN M

NN NN M

NN NN NN MM M

NN M

RN W

M M

M

e

mm wm em mm wm mw oww owm o

B4 Abstract data types (ADTs) (HL)

def insert
at end(self,

data):

new_node = ListNode (data)

L

==

# Create new node

o

E

if self.head is None: # Check if list is empty

-

self.head = new node # Insert new node as head of list
else:
current = self._head # CGet a link to the first node in the list

while current.next

!= None:

# Keep moving down the list

current = current.next

# When the above loop ends,

the next pointer must be None,

indicating we

# have reached the last node

current.next = new node # Set peointer on current last node to the new node

B

T T T

T T T T

T

T

Java
public void insertAtBeginning(int data)

{

ListNode newNode = new ListNode (data);
newNode.next = head;

// Create a new node with the data given

// Set new node pointer to current head node

head = newNode; // Set head pointer to new node

}
public void insertAfter(int targetValue,

int data)

{

ListNode current = head;

// Traverse the list to find the target value
while

(current

current

=

!= null && current.data

!= targetValue)

{

current.next;

}
// At this point current will either be null
// 1f the target node is found,

if (current != null)

(not found)

or our target node

insert the new node after it

{

ListNode newNode = new ListNode (data);

// Create new node with data

// provided
newNode .next = current.next;

// Set new node pointer to the same pointer

// as the found node
current .next = newNode;

// Set the found node pointer to the new node

} else {
// If the target value is not found in the list
System.out.println("Node with value " + targetValue + " not found.");

}
public void insertAtEnd(int data)

{

ListNode newNode = new ListNode(data);
if

(head == null)

{

// Create a new node

// Check if list is empty

head = newNode; // Insert new node as head of list

} else {
ListNode last = head; // Cet link to the first node in the list
while

(last.next

!= null)

{ // Keep moving down the list

last = last.next;

B4.1 Fundamentals of abstract data types

@

AINO TH

// When the above loop ends,

the next pointer must be null,

indicating

// we have reached the last node
last.next = newNode;

// Set pointer on current last node to the new node

)
:
T

L T LT T

L LT T

T T T T

T

T

H
T L LT T TP PP PP PP

Deletion
Like the insertion methods, the deletion method will also reside in the LinkedList class. We
assume here that all items in our list are unique. If this were not the case, these methods
would delete the first occurrence. Our method has one parameter: the data we are looking for.

Our delete method must be prepared for three possible outcomes:
1

We are deleting the head node

2 We are deleting a middle node or the tail node
3
|
1
]
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
:
1
1
1
]
1
1
1
1
1
1
]
]
1
1
1
|
1
1
1

The node may not be found.

def delete node(self, data):
current = self _head # Get the head node
prev = None
# Case 1:

If the node to be deleted is the head of the list

if current

!= None and current.data == data:

self _head = current.next
current = None

# Change head to the current head's pointer

# Free the old head

return
# Search for the node to be deleted,

remembering to keep track of the

# previous node
while current

!= None and current.data

!= data:

prev = current
current

# Case 3:

=

current.next

If the node is not found

if current == None:

print (f'"Node with data {data} not found.")
return
# Case 2: Unlink the node from the list
prev.next = current.next
current

= None

B4 Abstract data types (ADTs) (HL)

o
=

Java

==

public void deleteNode
(int data)

{

ListNode current = head

-

prev = null;
// Case 1:

if

If the head node is to be deleted

(current

!= null && current.data == data)

{

head = current.next; // Changed head
return;

}
// Case 2:
while

If the node to be deleted is somewhere other than at the head

(current

!= null && current.data

!= key)

{

prev = current;

current = current.next;

}
// Case 3: If the key is not present in the list

if (current == null)

{

System.out.println("Node with value " + key + " not found.");
return;

}
// Unlink the node from the linked list
prev.next = current.next;

}
T

T

T

T T LT

T T T T TT T T T

T

T TS

Search
The search method also resides in the LinkedList class. This is a relatively straightforward
method that combines some of the techniques we have already used. The method needs a

single parameter to look for and, in these examples, will return true or false, depending on
whether the item was found. This could be modified to return the position in the list of the
node itself, if needed.

Python
def search(self, key):
current = self.head # Cet the head node

while current != None:

# Keep looping until we have run out of nodes

if current.data == key: # If we find the node we are looking for
return True

current = current.next # Move to the next node
return False

# Value not found in the list

1
1
[
1
1
1
1
1
1
1
1
1
1
1
1
1
-

B4.1 Fundamentals of abstract data types

@

AINO TH

Java
public boolean search(int key)
ListNode current = head;

// Get the head node

while

{ // Keep looping until we have run out of nodes

if

HH
HH
H

(current

!= null)

(current.data == key)
return

HH
:
HH
HH
H
HH
HH
H

{

{

//

1f we find the node we are looking for

true;

}
current

current.next; // Move to the next node

}
return false;

// Value not found in the list

HH
HH

Create the LinkedList class and ListNode class. Using a test table, plan out the actions you will
take to ensure that these list methods are working correctly. When you have done that, carry out
the tests.

B4.1.4 Structures and properties
of binary search trees
B How binary search trees are used for data organization
A tree structure in Computer Science is used to hold data in order and is usually drawn upside
down, with the root at the top and the leaves at the bottom.
4 Root: the topmost
node from which all
other nodes descend,
serving as the starting
point for any traversal
or operation within a
binary search tree.
4 Parent: a node that
has one or more nodes
directly beneath it,
connected by edges,
and it directly controls
these subsequent
child nodes.
4 Child: any node that
has a direct link from a
parent node positioned
above it, potentially
having further child
nodes of its own.

left subtree

right subtree

children

leaf nodes
M Tree structure and its parts

In this section, we will be focusing on a tree that follows some strict rules, which allow us to
optimize search, insertion and deletion operations.
However, before we discuss the rules of binary search trees (BST), it is important to

understand the terminology. The node at the top of the tree is known as the root node. If a
node has a node attached below it, it is known as a parent node, with the one below being the
child node. Each parent node can have one or two child nodes. The child node that is less than

the parent goes on the left; the child node that is greater than the parent, on the right.

B4 Abstract data types (ADTs) (HL)

# Subtree: any

The sub-section to the right of a node is known as the right subtree and to the left, the left

node, along with

subtree. All nodes at the bottom of the tree, without children, are known as leaves.

its descendants,
functioning as a
standalone binary search
tree, with its node
acting as the root.

‘We can assume that all items within the BST are unique (there are no duplicates).

# Leaf: a node that
does not have any
children, representing
the endpoints of
a binary search
tree’s branches.

o
Z

==

-

GCommon mistake
Make sure you move in the correct direction when navigating through the tree:
m Move left if the item is smaller than the node.
m Move right if the item is larger than the node.

B Tree structure and node insertion

®®

@

ere, you can see these two rules in place. In this example, 10 was the first node entered into

the BST and set as the root. Each new node works its way through the tree until it finds a space
where it can join. We cannot be completely sure what was entered next, but let us assume that
it was node 5:
B Node 5: This would be compared to node 10; as it is smaller than node 10, it would join to

the left of that node. This is now a child of node 10, which is the parent node of node 5. At
this point, node 5 is also a leaf, but this will change as more nodes are added later.
® Node 12: This would be compared with 10 and, as it is greater, it would join to the right.
This is now a child of node 10, which is the parent node of nodes 5 and 12.
B Node 3: This would be compared to node 10; as it is smaller, it would move to the left. It
would then be compared with node 5 and, as it is smaller, it would be moved to the left
again, where it would join the tree. This is now a child of node 5, and node 5 is the parent
of node 3.
B Node 8: This is smaller than node 10, so it moves to the left; it is greater than node 5, so it
moves to the right. This is now a child of node 5, and node 5 is the parent of nodes 3 and 8.

B4.1 Fundamentals of abstract data types

AINO TH

1

Write the statements for how nodes 6, 9, 16 and 15 join the tree.

2

Sketch the resulting binary tree when the following items are entered:
10,15, 3,12,7,1,22,18,5

Which nodes are:
oW

children?

N

leaves?

Qo

Leaves are not always
at the bottom of
the tree. A leaf is
any node in the tree
that does not have
any children.

parents?

right subtree?

o

3

left subtree?

=

(‘Common
mistake

root?

B Node search
To find a node in a BST, we follow these steps, looking for the key we are searching for:
1

Start at the root node: Begin your search from the root of the BST.

2

Check for null / none: If the current node is null (or none in Python), the search concludes
without finding the key. The key is not present in the BST.

3

Compare the node value with the key:
a

If the current node’s value matches the key, the search is successtul. The key is found in

the BST.
b If the key is smaller than the current node’s value, proceed to the left child of the

current node.
¢

If the key is larger than the current node’s value, move to the right child of the

current node.
4 Repeat the process: Continue the process from step 2 with the new current node.

M Node traversal
Depending on the requirements, there are different ways to traverse the BST and return the
data within. These are:
B in-order traversal
B pre-order traversal
B post-order traversal.
To perform these operations, it is important to remember the order of actions as you move
through the BST. The easiest way to do this is to remember that you always move left before
right. After that, you just need to remember when you output the node data.

(;Top tip!
The traversal name gives you a clue to where the node check is:
B Pre-order: check before left and right (NLR)
B

Post-order: check after left and right (LRN)

B In-order: goes in the middle (LNR).

Let us look again at the BST illustrated above.

468

B4 Abstract data types (ADTs) (HL)

In-order traversal (left, node, right)
We start at the root (10) and need to perform all three operations on this node. We start with

the first, left. This takes us to node 5 with the same situation, left and we move to node 3.
Here, we move left (no further node), node so we output 3, and then move right (no further

node). We have now completed all three actions on this node. So, we move back to node 5.

Here we have already gone left, so now we output node, which would be 5, and then we move
right. We continue with these operations until all three have been completed on every node.

The final output would be:
3,5,6,8,9,10,12,15, 16
You will notice the numbers are output in order. This is the main purpose of an in-order

traversal — to output the nodes, sorted, in ascending order.
Pre-order traversal (node, left, right)
We carry out the same operations here, but in a different order. We start again at the root (10),
but this time we output node value first. We then move left to node 5, where we output the

node value there. We move left again and output node 3. We move left and right on node 3,
completing the operations, and then move back to node 5, where we move right to node 8. We
then continue in this manner until all three operations have been completed on every node.
The final output would be:
10,5,3,8,6,9,12, 16, 15

This method is useful for creating a copy of the tree or for exploring paths, as it visits the
parent prior to the children.

Post-order traversal (left, right, node)
Once you have understood the first two methods, this third should not cause any problems. It
follows the same idea again, but this time we visit the node last. We start at the root (10), and

we go left to node 5. We then go left again to node 3, where we complete all three operations,
left, right and then finally node, where 3 is output. We then go back to node 5 and move right
to node 8, where we go left to node 6 and complete all three actions, with 6 being output. We
then move back to node 8 and move right to node 9. We then continue in this manner until all
three operations have been completed on every node.
The final output would be:

3,6,9,8,5,15,16,12, 10
This method is often used for deleting nodes within the tree as it visits children before their

respective parent nodes.

1

2

On the BST you drew for the previous review questions, carry out the following and show
the output:
a

In-order traversal

b

Pre-order traversal

¢

Post-order traversal

What would happen if non-numerical data were input into a BST? Sketch the following
BST when the data is input in this order:
Ava, Alex, Bella, Catherine, Carlos, Brian, Aaron, Chloe

B4.1 Fundamentals of abstract data types

@

=
o
=
ze

-

ATNO TH

B Node deletion
To delete a node in a BST, we take the following steps, looking for the key to delete and then
carrying out the action based on the situation we find ourselves in:

1

Start at the root node: Begin the deletion process from the root of the BST.

2

Search for the key: Follow the algorithm from the node search.

3 Once the node is found, determine its type:
a

Leaf node (no children): if the node has no left or right child

b One child: if the node has exactly one child (either left or right)
¢

Two children: if the node has both a left and a right child.

4 Delete the node based on its type:
a

Leaf node: Simply remove the node from the tree by setting its parent’s appropriate (left
or right) child pointer to null.

b One child: Bypass the node by linking its parent directly to its child. If the node is a left
child, update the parent’s left pointer; if a right child, update the parent’s right pointer.

set pointer

M Deletion of node with one child

¢

Two children:
i

Find the in-order successor (smallest value in the right subtree) or the in-order
predecessor (largest value in the left subtree).

il

Replace the value of the node to be deleted with the in-order successor’s (or
predecessor’s) value.

iii Delete the in-order successor (or predecessor) by repeating step 4, which now

becomes a case of deleting a node with at most one child.

Thinking skills:
Problem-solving
and analysis
Coding competitions
are an effective
way to improve
your programming
and problemsolving skills. Here
is a question from
CodingQuest where
a BST can be used
to solve it:
https://codingquest.io/
problem/26

M Deletion of node with two children

5

Repeat the process as needed:

If you had to delete the in-order successor or predecessor (step 4¢), repeat the deletion
process for that node.

B4 Abstract data types (ADTs) (HL)

B4.1.5 Sets as an abstract data type
# Unordered set: a
collection of unique
elements where the
elements do not have
a specific order or
sequence and their
arrangement can vary
each time they are
accessed.
# Mutable: a set whose
state or content can
be changed after it has
been created, allowing
for modifications, e.g.
adding, removing or
altering elements within
the object.

z
o
=

I

Like lists and arrays, sets can be used to store multiple values in a single variable. Sets are
unordered, meaning that they cannot be accessed via index or key, but they are mutable,

=<

allowing the addition and removal of items. However, the individual items cannot be updated
or change values. Sets contain only unique elements.
They are a powerful data structure when unique elements and etficient operations are crucial.
They are extremely useful when you want to ensure a collection consists of only unique
elements, such as when working with usernames where duplicates are not allowed. They are
also extremely fast when needing to check whether an item is already part of a collection.
‘When needing to perform mathematical set operations, such as union, intersection and
difference, which are commonly used with database queries, search algorithms and data
analysis, sets perform very well.
Key characteristics of sets are that:
B they are unordered
H they are mutable
B they contain unchangeable values
|

they contain only unique elements.

M Creating sets
There are two ways of creating a set in Python:
1
1
1
1
1
1
1
1
1
1

Python
# Using curly brackets
my set = {1,

2,

3,

4,

5}

# Using the set ()

constructor

my set2 = set([1,

2,

2,

3,

4,

5]}

# Duplicate entries will

# automatically be removed

:
-

In Java, there are a number of classes that implement the Set interface. For our example
purposes, we will use the HashSet. The other possibilities are LinkedHashSet and

emresssasatsasstarsnnrrrnnny

TreeSet, which will not be covered here. Using HashSet requires the import of two libraries:

Java
import java.util._HashSet;
import java.util.Set;
// Creating a HashSet of type Integer
Set<Integer> mySet = new HashSet<>();

B4.1 Fundamentals of abstract data types

@

ATNO TH

B Set methods
To add and remove elements:
r

t
1
T
: my set = {1, 2, 3, 4, 5}
1 my_set.add(e6) # Add 6 to the set
r
:I my_ set.remove(l) # Remove 1 from the set
T

Java
Set<Integer> mySet = new HashSet<>();
! myset.add(6); // Add 6 to the set
myset.remove(l) // Remove 1 from the set
BT R

T

T
T TT

LT L L L LT E T T TP P TP P PPH

L LT T T T

To check whether elements are present in the set:

Python
if 2 in my set:
print ("2 is in the set")
else:
print ("2 is not in the set")

e ee e b ee e e ee be ee Ee e e e

# Set union: the
union of twao sets is
a new set containing
all the elements that
are in either of the
original sets, effectively
combining them without
any duplicate elements.
# Set intersection: the

intersection of two sets
Is a new set containing

only the elements
that are present in
both of the original
sets, identifying their
common elements.
# Set difference: the

difference between
two sets is a new set

containing elements
that are in the first
set but not in the
second set, effectively
subtracting the elements
of the second set from
the first.

HH
HH
HH
HH
H
HH
HH
H
HH
HH
H
HH
HH

A

eA E e A e

e

eA e e

e e

e ee e eeeeeeaaeaasasaRaa e s s ansaaanns

Java
if (myset.contains(2))

{

System.cut.println("2 is in the set.");
} else {
System.out.println("2 is not in the set.");

}

:T
T T T LT T T T T T T P TP
PP

B Set operations
There are three main operations that are used to manipulate and compare sets. These are

union, intersection and difference. We will show their differences using the set created below.
1

[

: # Define two sets
: A= {1, 2, 3, 4}

:
:

1 B = {3, 4, 5, 6}

11 oA.add(1);

' Python

¢

Java

i

i // Define two sets
Set<Integer> A = new HashSete<x();

]

SNPEp———— G WPY-".Up
1W
i A.add(3);

i A.add(4);

! Set<Integer> B = new HashSete<>({);

!

i B.add(3);
i B.add(4);

i B.add(5);

i B.add(s);

B4 Abstract data types (ADTs) (HL)

Union

=
o
=
ze

A union joins two sets to create one that contains all the elements from both, without
any duplicates.

-

L3

I
1 Python
i
1 # Union
'
' union set = A | B # or A.union(B)
I
1 print ("Union:", union set)
'
1 # Output
'
+ # Union: {1, 2, 3, 4, 5, 6}
1
L3

.H B
HH
HH

T T T

LR T T L E T

T T

P

T T .H
HH
HH

Java
// Union

H
HH
HH
HH
H
HH

Set<Integers> unionSet = new HashSet<>(A);

H
HH
HH
HH

// Creates a new

// set containing all elements from A
unionSet.addall
(B); // Performs a union join with B
System.out .println("Union:

" + unionSet); // Output set contents

// Output
// Union:

[1,

2,

3, 4,

5,

H
HH

6]

Intersection
An intersection of two sets creates a new set that contains only the elements that are present
in both.
P

el

e

e

e

e

e

e

e

e

e

k. |

Python
# Intersection

intersection
set = A & B
print ("Intersection:",

# or A.intersection(B)

intersection_set)

# Output
# Intersection:

[3,

4]

Java
// Intersection
Set«<Integer> intersectionSet = new HashSet«s>(A);
intersectionSet.retainAll (B);
System.out .println("Intersection:

"

+ intersectionSet);

// Output
// Intersection:

B4.1 Fundamentals of abstract data types

[3,

4]

@

ATNO TH

Difference
The difference between two sets is a set containing elements that are in the first set but not in
the second.
L
i Python
1
i # Difference
1
i difference
set = A - B
# or A.difference(B)
1
: print ("Difference:", difference_ set)
i # Output
1
I

1

# Difference:

[1,

2]

L

Java
// Difference
Set<Integers> differenceSet = new HashSet<s>(A);
differenceSet.removeAll
(B) ;
System.out.println("Difference:

" + differenceSet);

// Output
// Difference:
T T T

[1, 2]
T T T T T

T

T LT T T T

T

Set A: {4, 8, 15, 16, 23}
Set B: {42, 8, 16, 60, 7}

1

Show the output if a union operation is performed.

2

Show the output if an intersection operation is performed.

3

Show the output if a difference operation is performed.

Social Skills: Collaborative group work
Social-media friend recommendation
With a partner, working in your chosen language, create two sets consisting of the
following names:
A: Carlos Gomez, Yuna Kim, Dmitri Ivanov

B: Yuna Kim, Dmitri Ivanov, Leila Al-Farsi, Sean O’'Brien
A and B represent two users on a social-media network. A and B are friends with
each other.
1 Using set operations, identify the users’ common friends.
2 Using set operations, identify friends of B that are not friends with A, so the platform
can recommend new connections.

B4 Abstract data types (ADTs) (HL)

Bl Check whether subset or superset

z
o
=

I

A subset or superset describes the relationship between two sets.
Set A is considered a subset of B if all of A's elements are present in B — which would be

=<

considered the superset. All elements of the subset can be found in the superset.
To check whether set A is a subset of set B, or whether B is a superset of A:
e
e
|

# Set subset: a set
where all elements
of this set are also
elements of another set,
indicating that the first
set is entirely contained
within the second set.

Python

1
1
1

# Define two new sets

:

A= {1, 4,

7}

1

B=1{1, 2, 3, 4, 5, 5, 7}

-

# Check if A is a subset of B

:

# Both of these methods are acceptable

:

print (A.issubset
(B))

:

print (A <= B)

# True

# True

1

# Check if B is a superset of A

:

# Both of these methods are acceptable

:

print (B.issuperset
(A)) # True

:

print
(B »= A)

# True

:
-

: Java
// Define two new sets

i

Set<Integer> A = new HashSet<>();

A.add (1) ;
A.add(4);
A.add(7);

bW W

w ww

Set<Integer> B

new HashSet<> () ;

.add (1) ;
.add (2) ;
.add (3) ;
.add (4) ;
.add (5) ;
.add (6) ;
.add (7) ;

// Check if A is a subset of B
System.out.println(B.containsAll
(a)); // True

// Check if B is a superset of A by checking if A is contained within B,
: // is not contained within A
E System.out.println(B.containsAll
(A) && !A.containsAll(B)); // False
H
T

L

L

LT T

LT T

but B

H
T LT TP T PR PP PP PP P

B4.1.6 Core principles of abstract data types
B Hash tables
Hash tables are a particularly important data structure in Computer Science. They offer rapid
retrieval and insertion capabilities into an array-like structure. However, rather than an
abstract integer being used by the programmer for the index, a key can be provided instead.
B4.1 Fundamentals of abstract data types

@

ATNO TH

# Hashing algorithm:

This key is then processed through a hashing algorithm to find which array index to store

a function that converts

the data in. This allows the data to be stored in an array-like structure that provides an O(1)

input data of any size
into a fixed-size string
of characters, which
typically represents the
data in a compressed
and seemingly

average-time complexity for search, insert and delete operations under ideal conditions.

random format and

the index.

For example, “name” could be used as the key by the developer. A hashing algorithm then
processes this with the aim of producing an integer so that where the data this key is linked to

can be stored in the array. One example method where this could be achieved is by adding up
the ASCII values of all the letters and then using modulus and the size of the table to determine

is used primarily for

indexing and retrieving

# Hash table size

items in databases
-

table

more efficiently.

-

size = 10

# ASCII values for letters

+0(1) time

complexity: describes
an algorithm that takes

'n'
2l

= 110
= 97

the same amount
i

'm'

= 109

of time to execute
regardless of the size of
the input data set.

‘et = 101
110 + 97 + 109 + 101 = 417

# ASCIl (American

417 % table

Standard Code
for Information
Interchange): a

size = 7

This data would then be stored at index 7.

character-encoding

Hash tables: Creating, inserting and retrieving data

standard used to
.
represent text in
computers and other
devices, defining a

This is how we can create a hash table, as well as insert, delete and retrieve items:

R
R
R
S
s
1 Python
1
I # Creating a hash table as a Python dictionary
1

numerical value for each
symbol and character

.
commonly used in the

1 hash_table = {}
1
)

English language.

y

L

T

T

T

1
1

)

# Inserting two items

: hash table["keyl"]

P

SH
1
1
!
1
1

= "valuel"

:

: hash table["key2"] = "value2"
I # Retrieving and printing cne item

:
1

:

value = hash table["keyl"]

:

:

print ("The value for

:
I
1

# Deleting an item
del hash table["key2"]
T

T

'keyl'

T

is:",

wvalue)

:

:
1
1
T T T T T LT T T

R T TP T

Java
;

import java.util.HashMap;

i

! public class Main {

3

i
;

i
i

public static void main(String[] args) |{
// Creating a hash table using HashMap

;

// The first data type is for the key,

;

HashMap<String,

?

// Inserting two items

]

hashTable.put ("keyl", "valuel");

i

hashTable.put ("key2",

the second is for the data

;

String> hashTable = new HashMap<>();

BT
T T LT T T
T

;
;

i

"value2");
T

LT T T T T

§
T T T

T LTI TTETTr TN

B4 Abstract data types (ADTs) (HL)

// Retrieving and printing one item

=
o
Z

=

String value = hashTable.get ("keyl");

System.out.println
("The value for

'keyl'

is:

" + value);

=<

// Deleting an item by key
String removedValue = hashTable.remove ("key2");

// Returns the value

// associated with the key

Collision factors
As you may have already guessed, the hashing algorithm demonstrated above is not foolproof.
There could be other example keys that also generate the number 7 for the index — when this
happens it is called a “collision”. Ideally, our hashing algorithm should generate a unique index

for each key and, while there are some more complex algorithms than the one we looked at
that are better at doing this, there is no complete solution available. We cannot store two data

items in an array at the same index, so how do we get around this problem? There are two
main methods used: “chaining” and “open addressing”. Before we look at these methods, it is

important to understand the impact of the number of items we are trying to store in the hash
table. This is called the “load factor™.

Load factors
The load factor is a measure that indicates how full the hash table is. The load factor is defined

as the ratio of the number of elements currently stored in the table to the total number of slots
available. The formula for load factor is:
Load factor =

number of entries in the table
total number of slots

The load factor can heavily affect the performance of the hash table. A hash table with a
# Rehashing: a process

high load factor will have more collisions, which will impact performance when performing

in hash tables where the

operations on the table.

data is redistributed into
a new, larger array to
reduce the load factor

and minimize collisions,
maintaining efficient
performance.

Rehashing
‘When the load factor exceeds a certain threshold, rehashing is necessary to maintain efficient
performance. Rehashing involves creating a new, larger array and redistributing the existing
elements using a new hash tunction or the same hash function applied to the new array size.
This process reduces the load factor and minimizes collisions, ensuring that the hash table
operations remain efficient.

(;Common
mistake
Do not overlook the

impact of a high load
factor on hash-table
performance. Keeping
the load factor low is
incredibly important
for efficiency.

Steps involved in rehashing:
1

Monitor the load factor of the hash table and, when this exceeds 0.7 (70 per cent),

2

Prepare a new array that is at least double the size of the current array. Ideally, the new size

3

For each element already in the hash table, all new hash values need to be computed based

trigger rehashing.
should be a prime number to help reduce collisions.

on the new array size.
4 Insert the elements into the new, larger array, ensuring that any collisions are
handled appropriately.

B4.1 Fundamentals of abstract data types

@

ATNO TH

Chaining
# Hash table chaining:
a collision-resolution
technigue in hash tables
where each bucket or
index in the array can
store multiple elements
in the form of a linked
list, allowing more than
one entry to be stored
at the same index.
# High load factors
(hash tables): a
condition where a
sizeable portion of
the hash table's slots
are filled, leading to

increased collisions and
potentially degraded
performance, due
to more frequent
need for collision

Chaining utilizes linked lists (or a similar structure) to be able to store more than one item of

data at a single index. When a collision occurs, and two keys hash to the same index, the new

key-value pair is added to the end of the list at that index.
Let us consider a simple hash function as “key mod 6” and a sequence of keys as 35, 800, 82,
92,122 and 94.
M Empty table

M Insert 35

M Insert 800 and 82

0

0

0

1

1

1

2

2

2

3

3

3

4

4

4

82

5

5

5

35

35

M Insert 122: Collision, so it is added to a chain

M Insert 94: Collision, so it is added to a chain

0

0

1

1

2

800

92

122

2

800

92

94

resolution mechanisms.

3

4 Open addressing:
a collision resolution
method in hash tables
where, instead of using
structures like linked lists
to store multiple items
at the same index, any
colliding item is placed
into the next available
open slot in the hash

4

82

4

82

5

35

5

35

table itself, according to

a probing sequence.

800

122

3

Advantages:
B Simplicity: It is relatively easy to implement.
B Handles high load factors well: If the number of items you are inserting is greater than the
amount of spaces in the table, it will still operate efficiently. However, lookup times may
become slower when having to access a linked list.
B Good for unknown data sizes (connected to the point above): If you do not know in
advance how many items you will be inserting into the table, chaining will have an

advantage as you will not need to rehash the table to resize it.
Disadvantages:
B Memory overhead: As it is urilizing a linked list, the more items there are in the chain, the
more memory it will require.
® Complexity for deletion: If the deletion is within a linked list, performance will degrade
due to the need to adjust pointers.
B Variable performance: When accessing an index with a linked list, this will perform worse
than one without, which can impact search and delete actions.

Open addressing
Open addressing only stores data within the hash rable itself. When a collision occurs, it will

find another empty slot in the hash table, according to a predefined sequence, and store the
data there.
Several methods can be used to achieve this:
B Linear probing sequentially checks the next spot until a space is found. However, this can

lead to clustering, where a group of adjacent slots get filled, increasing the search time for
these elements in particular.
B4 Abstract data types (ADTs) (HL)

B Quadratic probing searches in a more spaced-out manner for an available slot using the

original hash value and a quadratic function. If the next space is also full, it increments the
value of the quadratic function and searches again until it finds an available slot.
B Double hashing uses a second hash function to determine the probe step. The first hash
function is performed first, and then a second one to give an offset from the original index.
This offers better distribution and minimizes clustering compared to linear and quadratic

probing, but requires more computational overhead.
Advantages:
B Space efficient: Stores all elements directly within the hash table array, eliminating the
need for extra data structures, such as linked lists.
More memory efficient: No pointers are required.

Simpler to serialize: As it is a simpler data structure with contiguous memory allocation,
converting the structure to a format to be stored or transmitted is simpler than a hash table
using chaining.
Disadvantages:
B Increased computational overhead: If there are high load factors, performance may
decrease due to the probing methods required.
B

Clustering: This can be an issue especially when using linear probing, where consecutive
slots are filled, which increases the average time for insertions, deletions and searches that
do not find the element they are searching for.

B

Complex deletion: Deleting an element is a complex process as you may break

probe sequences.

Using a hash table, create a simple voting system. The system should have the ability to add
and remove candidates. Use the name input by the user as the key in the hash table. Once the

candidates have been input, it should allow voters to cast votes for the candidates in the system
and allow the current totals to be viewed. There should be an option to end the election when
the voting is over, and the winner should be output to the user.

Working in a team, conduct a small experiment by implementing two different ADTs to solve the
same problem and compare the performance. You could consider execution time and memory
usage, for example.
Collaborate on this project by assigning roles, managing your time and co-operating to achieve

your goal. You could create a shared code repository to help you work together.
When you have finished, prepare a presentation summarizing your project. Include the problem
definition, implementation details, test results, analysis and conclusions.

An example project:
Spell checker
Implement a spell checker using a hash table and a binary search tree. Compare the performance
for the following operations:
B Inserting words into the dictionary.
B Checking whether a word is in the dictionary.
B Suggesting corrections for a misspelled word (finding the nearest match).

B4.1 Fundamentals of abstract data types

@

=
o
=
ze

-

ssssssssssnssnnsas

AINO TH

@ Linking questions
1
2
3

What role do stacks and queues play in handling CPU interrupts and polling? (A1)
(Can abstract data types be used to manage data? (A2)
How can abstract data types be used to optimize the file-processing operations like read
and write? (B2)

4

(Can a binary search tree play a role in the quicksort algorithm? (B1)

D
TP T
Y

1

2

Construct a diagram to represent a double-linked list that holds the following sequence
of names:
Kaja, Aiko, Carlos, Fatima
The names of a group of people attending a conference were recorded in a stack data
structure. The first name stored in the stack was “Sofia”.

4]

Tariq
Maya

Jasper
Rina
Rafael
Aisha
Zara

Sofia

3

4

5

Note that “Tariq” is currently in position 0 in the stack.
a Compare and contrast the use of a binary search tree and a stack when searching for
a specific item.
2]
b The tree is populated with the data from the stack. By considering only the data
visible in the stack above, sketch the binary search tree that has been created from the
items removed from the stack.
2]
Sketch a binary search tree that would allow the following output when traversed using an
in-order traversal:
Zebu, Tapir, Hedgehog, Falcon, Dugong, Bison, Armadillo
2]
A hash table has been used to store a company’s current stock. The hashing algorithm
used is:
stock number MOD 100.
a Determine the value returned by the hashing function when it is applied to stock
number 1021.
1]
b Explain how a value is stored in a hash table.
[]
¢ Describe the steps involved in rehashing.
2]
Given two sets, A ={1, 2, 3, 4} and B = {3, 4, 5, 6}, perform the following operations and

provide the resulting set:
a Union

2]

b

Intersection

2]

¢

Difference.

2]

B4 Abstract data types (ADTs) (HL)

\
GPE—

———

e

B4 Abstract data types (ADTs) (HLonly) ... e 548
B4.1
Fundamentals of ADTs ... o e, D49
B4 Abstract data types (ADTs) (HL only)
B4.1 Fundamentals of ADTs

Coding within the

be frustrating when you are learning, but it is fun to
practise resilience and try another way until you solve

computer science course

the problem. The best coders learn from their mistakes,

You will not be surprised to learn that there is quite a lot
of coding in the computer science course. However,

so the more mistakes you make, the more you learn!
The best thing you can do when learning to code is just
to try and then try again.

this course is accessible, especially at standard level,

if you are willing to put in the work. Everyone learning
to code experiences moments of failure followed by
moments of joy when things finally click. Everyone
learns coding at their own pace but, most importantly,
everyone can learn to code. There are lots of resources
to help you, including this book!

@ Self-management skills
When starting to learn to code, it is often useful
to copy and paste the coding fragments into a
document and then add notes to help you remember
what they do. The first time you encounter an error,
take a screenshot of the error and write the solution
with the screenshot. The next time you encounter
the
error, you will know how to solve it.

Getting started
This book covers a lot of theory, with no assumption
of prior knowledge. You may find it useful to begin by
reading the programming topic. There are practice
questions to test your learning. The book also includes
lots of worked examples and activities to help you get
started with your coding.

Create a new document or folder to store all your
notes on coding and problem-solving. Maintain this
document throughout the course, adding notes as
your coding skills develop.

Many people also find it useful to follow along with
online videos when coding. There are many websites
to help you if you get stuck, and the coding community
can be very supportive.

Looking at past IB examination questions will help
you to understand what code you need to memorize
for the exam. However, keep in mind that not all past
paper questions will be relevant for this course.

Practice makes perfect

Find some past papers for this course. As you
progress through the course, work through the
questions and annotate your answers. Reference
the relevant section of your notes for easier revision,
and add tips to help you remember things you find
challenging.

As with any other skill you might learn throughout your
lifetime—speaking another language, driving, painting,
playing piano—practice makes perfect! It is true that
the more you practise a skill, the easier it becomes, and
coding is no exception.
Computational thinking is the ability to understand
and identify solutions to problems. When you first start
on your coding journey, the vocabulary and coding
syntax can be a lot to remember. Writing down what
you want to do—your solution—step-by-step, and then
translating this into code can help you develop both
your computational thinking and your coding skills.
When learning to code, you will probably have to
reference example code repeatedly, checking all
spaces, full stops and quotation marks. The more you
practise this, the more you will remember commands
without needing to reference code. As you become
more confident, the code you are referencing will
become more complex and you will be able to develop
more intricate programs. Don’t worry if you find
yourself referencing previous code even after a few
months—most coders do!

Resilience
Part of the fun of coding is problem-solving. It is
very rare that code works straight away. This can

Where to get help
When learning to code, the following resources may
be useful.
*

Your teacher: Teachers are usually a good place
to start when learning a new skill.

*

Textbooks: There are many books dedicated to

learning to code.
*

Online communities: These are a good place to
get specific help when a section of code does
not work.
Friends: Working together to develop code can be
helpful. Talking through your ideas and working
together to solve problems helps you to learn.

Learning to code can be challenging but it can also be
rewarding. Wherever you are on your coding journey,
practising coding and talking about coding will help
you to learn.

Course book definition

The IB learner profile

The IB Diploma Programme course books are resource
materials designed to support students throughout
their two-year Diploma Programme course ofstudy
in a particular subject. They will help students gain an
understanding of what is expected from the study of
an IB Diploma Programme subject while presenting
content in a way that illustrates
the purpose and aims
of the IB. They reflect the philosophy and approach of
the IB and encourage a deep understanding of each
subject by making connections to wider issues and
providing opportunities for critical thinking.

The aim of all IB programmes is to develop
internationally minded people who work to create
a better and more peaceful world. The aim of the
programme is to develop this person through ten

The books mirror the IB philosophy of viewing the
curriculum in terms of a whole-course approach:
the use of a wide range of resources, international
mindedness, the IB learner profile and the IB Diploma
Programme core requirements, theory of knowledge,
the extended essay, and creativity, activity and
service (CAS).
Each book can be used in conjunction with other
materials and, indeed, students of the IB are required

and encouraged to draw conclusions from a variety
of resources. Suggestions for additional and further
reading are given in each book and suggestions for
how to extend research are provided.
In addition, the course companions provide advice
and guidance on the specific course assessment
requirements and on academic honesty protocol.
They are distinctive and authoritative without being
prescriptive.

IB mission statement
The International Baccalaureate aims to develop
inquiring, knowledgeable and caring young people
who help to create a better and more peaceful world
through intercultural understanding and respect.
To this end, the organization works with schools,
governments and international organizations to
develop challenging programmes of international
education and rigorous assessment.
These programmes encourage students across the
world to become active, compassionate and lifelong
learners who understand that other people, with their
differences, can also be right.

learner attributes, as described below.

Inquirers: They develop their natural curiosity.
They acquire the skills necessary to conduct inquiry
and research and show independence in learning.
They actively enjoy learning, and this love of learning
will be sustained throughout their lives.
Knowledgeable: They explore concepts, ideas and
issues that have local and global significance. In so
doing, they acquire in-depth knowledge and develop
understanding across a broad and balanced range of
disciplines.
Thinkers: They exercise initiative in applying thinking
skills critically and creatively to recognize and approach
complex problems and to make reasoned, ethical
decisions.
Communicators: They understand and express
ideas and information confidently and creatively in
more than one language and in a variety of modes of
communication. They work effectively and willingly in
collaboration with others.
Principled: They act with integrity and honesty, and
with a strong sense offairness, justice and respect for
the dignity of the individual, groups and communities.
They take responsibility for their own actions and the
consequences that accompany them.
Open-minded: They understand and appreciate their
own cultures and personal histories and are open to the
perspectives, values and traditions of other individuals
and communities. They are accustomed to seeking and
evaluating a range of points of view and are willing to
grow from the experience.
Caring: They show empathy, compassion and respect
towards the needs and feelings of others. They have
a personal commitment to service and to act to make
a positive difference to the lives of others and to the
environment.
Risk-takers: They approach unfamiliar situations and
uncertainty with courage and forethought and have

the independence of spirit to explore new roles,
ideas and strategies. They are brave and articulate in
defending their beliefs.
Balanced: They understand the importance of
intellectual, physical and emotional balance to achieve
personal well-being for themselves and others.

categories (for example, books, magazines, newspaper
articles, internet-based resources and works of art)
and providing full information so that a reader or
viewer of your work can find the same information.
A bibliography is compulsory in the extended essay.

What constitutes malpractice?

Reflective: They give thoughtful consideration to their
own learning and experience. They are able to assess
and understand their strengths and limitations in order
to support their learning and personal development.

Malpractice is behaviour that results in, or may resultin,
you or any student gaining an unfair advantage in one
or more assessment component. Malpractice includes
plagiarism and collusion.

A note on academic

Plagiarism is defined as the representation of the ideas
or work of another person as your own. The following
are some of the ways to avoid plagiarism:

integrity
It is of vital importance to acknowledge and
appropriately credit the owners of information when
that information is used in your work. After all, owners
of ideas (intellectual property) have property rights.
To have an authentic piece of work, it must be based on
your individual and original ideas with the work of
others fully acknowledged. Therefore, all assignments,
written or oral, completed for assessment must use
your own language and expression. Where sources

*

using the words and ideas of another person to
support your arguments must be acknowledged

*

passages that are quoted verbatim must
be enclosed within quotation marks and
acknowledged

*

must be treated in the same way as books and
journals

are used or referred to, whether in the form of direct

the sources of all photographs, maps,
illustrations, computer programs, data, graphs,

quotation or paraphrase, such sources must be
appropriately acknowledged.

How do | acknowledge the work
of others?
The way that you acknowledge that you have used the
ideas of other people is through the use of footnotes
and bibliographies.
Footnotes (placed at the bottom of a page) or endnotes
(placed at the end ofa document) are to be provided
when you quote or paraphrase from another document
or closely summarize the information provided in
another document. You do not need to provide a
footnote for information that is part of a “body of
knowledge”. That is, definitions do not need to be
footnoted as they are part of the assumed knowledge.
Bibliographies should include a formal list of the
resources that you used in your work.
“Formal” means that you should use one of the several
accepted forms of presentation. This usually involves
separating the resources that you use into different

email messages, and any other electronic media,

audio-visual and similar material must be
acknowledged if they are not your own work
*

when referring to works of art, whether music,
film dance, theatre arts or visual arts and where
the creative use ofa part ofa work takes place,
the original artist must be acknowledged.

Collusion is defined as supporting malpractice by
another student. This includes:
*

*

allowing your work to be copied or submitted for
assessment by another student
duplicating work for different assessment
components and/or diploma requirements.

Other forms of malpractice include any action that
gives you an unfair advantage or affects the results of
another student. Examples include taking unauthorized
material into an examination room, misconduct during
an examination and falsifying a CAS record.

How to use this book
The aim of this book is to develop conceptual understanding, aid in skills
development and provide opportunities to cement knowledge and
understanding through practice.
Feature boxes and sections throughout
the book are designed to support these
aims, by signposting content relating to particular ideas and concepts, as well as
opportunities for practice. This is an overview of these features:

Developing conceptual understanding
Guiding questions
Each topic begins with a guiding question to get you thinking. When you
start studying a topic, you might not be able to answer these questions
confidently or fully, but by studying that topic, you will be able to answer
them with increasing depth. Hence, you should consider these as you
work through the topic and come back to them when you revise your
understanding.

@

Linking questions
Linking questions within each topic highlight the connections between
content discussed there and other parts of the course.

Theory of knowledge (TOK)
This is an important part of the IB Diploma Programme. It focuses on critical
thinking and understanding how we arrive at our knowledge of the world.
The TOK features in this book pose questions for you that highlight these
issues.

Parts of the book have a coloured bar on the edge of the page or next to
a question. This indicates that the material is for students studying the DP
computer science course at higher level. AHL means “additional higher level”.

Link features in the margin will direct you to other parts of the book where a
concept is explored further or in a different context. They may also direct you
to prior knowledge ora skill you will need, or give a different way to think
about something.

viii

Developing skills

These approaches to learning (ATL) features prompt you to develop

The key practical skills

strategies to support the ATL skills of communication, self-management,

in computer science are

research, thinking and social skills.

algorithmic thinking and
programming. These boxes
highlight opportunities to
practical skills as part of the

This feature explores examples of computer science applied to solving

computational thinking process.

real-world problems.

These sections of the book provide guidance on how to apply the

These introduce the definitions

computational thinking process to your computational solution, which is

of important terminology used in

the internal assessment for computer science, and how to prepare for your

COmMPLREN SCence.

Paper1 and Paper 2 examinations.

Practising
Worked examples
These are step-by-step examples of how to answer questions. You should
review these examples carefully, preferably after attempting the question
yourself.

Practice questions
These are designed to give you further practice at using your knowledge and
to allow you to check your own understanding and progress.

These give you an opportunity to apply your knowledge and skills, often in
a practical way.

End-of-topic questions
Use these questions at the end of each topic to draw together concepts from that topic and
to practise answering exam-style questions.

Computer fundamentals
What principles underpin the operation ofa
computer, from low-level hardware functionality to
operating system interactions?

AN

Computer hardware
and operation

Syllabus understandings
A1.1.1 Describe the functions and interactions of the main CPU components
A1.1.2 Describe the role ofa GPU
A1.1.3 Explain the differences between the CPU and the GPU
A1.1.4 Explain the purposes of different types of primary memory
A1.1.5 Describe the fetch, decode and execute cycle
E A1.1.6 Describe the process of pipelining in multi-core architectures
A1.1.7 Describe internal and external types of secondary memory storage
A1.1.8 Describe the concept of compression
A1.1.9 Describe different types of services in cloud computing

A1.1.1 Describe the functions and
interactions of the main CPU components

A Figure1 What s inside a CPU?
_

In this section, you will learn about the function and interaction of computer

hardware, focusing specifically on the central processing unit (CPU), which is the

Components Distinct functional

engine of a computing system.

units that perform specific

You will explore components of the CPU, such as the arithmetic logic unit (ALU)
and control unit (CU). You will discuss the roles and interactions of registers,
including the instruction register (IR), program counter (PC), memory address
register (MAR), memory data register (MDR), and accumulator (AC). Additionally,

operations essential for processing
instructions.

you will examine the various buses—control, data, and address—that facilitate

communication within the CPU and across the system. This section also covers
different types of processaors, from single-core to multi-core processors, as well as
specialized co-processors.

The CPU
The CPU is the primary computational engine of the computer, responsible
for executing instructions. It plays a central role in coordinating data
movement within the system, working in conjunction with other components.
Understanding its components and their interactions is fundamental to

A Figure2 ACPU
You will learn in more detail how
these parts work together in

understanding computer operations.

section A1.1.5 The fetch, decode

)
.
The CPU contains components, registers and buses.

and execute

cycle.
<

Al Computer fundamentals

TOK
To what extent does understanding
the fundamentals of a system help a
person use it?
Consider this question in the
context of both a car engine
and a computer. Does your
answer change, depending on
the context? Now consider the
same question in the context of
something less tangible, like human
rights or your physical health.
Does understanding how
a system
works change the way a person can
use it?

Components
A component refers to a distinct functional unit or part within the CPU that has
a specific role in the processor’s operation. The CPU—being the computational
engine of the computer—contains key components which work together to
execute instructions.

Key components inside of the CPU include the following.
Arithmetic logic unit (ALU) Performs arithmetic and logical operations. It is
where the actual computation happens, such as addition, subtraction, and
logical operations like AND, OR, NOT, and so on.

Control unit (CU) Responsible for orchestrating the fetch—-decode—execute cycle.
lts primary functions include decoding and interpreting instructions fetched from
memory and generating control signals to activate the appropriate hardware units
within the CPU. This involves parsing the instruction’s opcode (operation code),
which determines the specific action such as reading data, writing data, performing
calculations or testing logic (ADD, SUB, AND, OR, and so on).

Registers
A register is a small-capacity, very fast storage location available within the CPU,
used to store data temporarily during the execution of programs. It is capable of
holding instructions, storage addresses or data.
Table 1 Key registers inside a CPU
Register
Instruction

register (IR)

Description
Holds the current instruction being executed. It acts as
a temporary holding area for the instruction before it is
decoded and executed.

A register that stores the address of the next instruction
Program counter | to be executed. Itis incremented automatically after each
(PC)

instruction is executed, pointing to the next instruction in the

program'’s memory location.
Stores the address in memory where the next piece of data
Memory address | or instruction is to be found or stored.
register (MAR)
The MAR interfaces directly with the system’s memory
address bus.
Memory data
register (MDR)

Holds the data or instruction that is being transferred to or
from primary memory.

A special-purpose register used to store intermediate results
of operations. It is often used for arithmetic and logical
operations. It can also be used as a temporary storage
Accumulator (AC) | location for other data.
While commonly used with arithmetic/logic operations,
accumulators can also function as temporary storage for
various types of data.

Buses
A bus is a shared communication pathway which transfers data between
components within a computer. Key buses connecting a CPU with other
components include the following.

Control bus Carries control signals from the Control Unit (CU) to other
components, managing actions and timing. These signals can be unidirectional
or bidirectional. Examples of control signals are read/write commands, interrupt
signals, timing, and acknowledgment signals.
Data bus
A pathway for transferring actual data between the CPU, memory, and
other components. Its width (e.g., 32-bit, 64-bit) influences transfer speed. The

data bus is bidirectional, allowing data flow in both directions.

L

Al.l Computer hardware and operation

= 99 =
[NERER

Dual-core

CPU

Quad-core
CPU

A Figure 3 Multi-core CPUs. A multi-core
CPU can have more than 128 cores

Address bus A pathway which carries memory addresses from the CPU to
specify where data should be read or written.

Types of CPU processors
Single-core processors possess one processing unit (core) integrated into
a single circuit. This core is the fundamental unit that reads and executes
instructions from processes. With a singular processing path, it handles
one instruction at a time, following a sequential execution model. This
architecture was standard in early CPUs, where task completion relied on the
linear processing of instructions. Its primary limitation is in executing parallel
processing demands. As computational tasks become more complex and
multitasking becomes essential, single-core processors face limitations in
performance, leading to potential bottlenecks in processing efficiency.

A Figure4 GPUsare common examples

Parallel processing A computing technique in which multiple processors
or cores within a single machine, or across multiple machines, simultaneously
execute different parts ofa task or multiple tasks to improve the overall speed
and efficiency of computation.

of co-processors

Architecture The design and organization ofa computer system’s hardware
and software components. This includes the structure and functionality to
perform computational tasks.
Multi-core processors consist of two or more independent cores, each
capable of processing instructions simultaneously. These cores are integrated
onto a single integrated circuit die (chip) or multiple dies in the same package.
This architecture enables the processor
to handle multiple instructions at once,
significantly improving performance over single-core designs, especially for
multitasking and parallel processing tasks. Each core can execute a different
thread (sequence of instructions) concurrently, enhancing computational speed
and efficiency. Multi-core processors are better suited to modern computing
needs, including advanced multitasking, complex computations, and
high-demand applications. They offer improved performance and efficiency
by distributing workloads across multiple processing units.
Co-processors are specialized processors designed to supplement the main
CPU, offloading specific tasks to optimize performance. They can be integrated
into the CPU or exist as separate entities. By taking on specific tasks, such
as graphics rendering, mathematical calculations, or data encryption, coprocessors free the main CPU to focus on general processing tasks. This division
of labour enhances the overall system performance and efficiency. Common
examples include graphics processing units (GPUs) for rendering images and
videos and data signal processors (DSPs) for handling signal processing tasks.

A Figure 5 Components and registers are
on the CPU chip. Buses connect the inside
of the CPU to outside components such

as memory

Rendering The process of
generating an image from a model by
executing a series of computational
operations that transform 3D scene
datainto a 2D image.

Al Computer fundamentals

@ Self-management skills
The correct use of subject-specific terminology is essential to your ability
to communicate your knowledge and understanding of key concepts in
computer science. Correct terminology enables the efficient transfer of highly
technical information between computer scientists.
In this section, you learned about the main computer components: what they
do and how they work. Make a glossary that has an entry for each term that
includes this information, such as in the example below.

Term (Abbreviation) | Definition
Arithmetic logic unit
(ALU)

Core component of the
CPU, where the actual
computation happens.

Linked terms
Central processing unit
(CPU), control unit (CU)

Include page references so you can find where the term was used in this
book — this can be useful for revision.
Continue to add terms to your glossary throughout the course.

A1.1.2 Describe the role ofa GPU
A graphics processing unit (GPU) is a specialized electronic circuit containing
numerous processing cores. For example, the Nvidia GeForce RTX 4080 has
9728 cores.
A GPU is designed to rapidly manipulate and alter memory, accelerating the
creation of images for output to a display device. Unlike central processing
units (CPUs), which handle a broad range of computations, GPUs possess a

highly parallel structure, ideal for complex graphical calculations. GPUs can be
integrated (part ofa CPU) or discrete (on a separate card). GPUs communicate
with software using APls such as DirectX and OpenGL. As well as processing

A Figure6 Amodern GPU

graphics, GPUs are increasingly used for machine learning and other
computationally intensive workloads.

GPU architecture
GPUs have a distinct architecture which sets them apart from conventional CPUs
and allows them to process large blocks of data concurrently, leading to more
efficient processing for certain types of tasks.

Al.l Computer hardware and operation

Table 2 Features and characteristics of GPUs

GPU feature | Characteristic

Example

i
i
o
.
;
Parallel
optimized for sequential, serial
.
processing
processing, GPUs have thousands of
L
)
capabilities | smaller cores designed for parallel
processing.

In image processing, a task such as applying a filter
to an image
9 _D_
]
9
PPIYINg
A
.
9
can be divided into smaller tasks where the filter is applied to
)
.
)
L
different parts of the image simultaneously. A GPU, with its
)
.
thousands of cores, can process multiple pixels at the same
.
L
.
.
.
time, significantly reducing the time required to apply the filter
.
to the entire image.

Unlike CPUs, which have a few cores

Hiah
9
throughput

GPUs are optimized for high
In graphics rendering, such as in video games or 3D
throughput, meaning they can process | simulations, a GPU’s high throughput allows it to process
alarge amount of data simultaneously. | and display complex scenes in real-time. It can calculate the
o
.
:
.
This is particularly beneficial in graphics | colour, position and texture of thousands of pixels concurrently,
rendering and complex calculations.
enabling detailed graphics.

Memory

GPUs are equipped with high-speed
.
memory (VRAM), which handles the
.
large textures and data sets required
.
;
in high-resolution video rendering and
.
complex scientific calculations.

In the context of high-resolution video rendering, the GPU
.
.
g
9:
relies on its VRAM to store and manage the textures and data
.
)
needed for rendering scenes. The high-speed memory allows
.
.
.
.
.
.
for the rapid manipulation of this data, enabling the rendering
.
.
.
.
)
.
)
of high-resolution video in real-time without buffering or
o
significant delays.

Real-world applications that require graphics rendering
and machine learning

DRR

GPUs are indispensable for rendering complex graphics in video games. They
enable the rendering of high-resolution textures, realistic lighting effects and
smooth frame rates, enhancing the gaming experience, providing higher frame
rates, and off-loading rendering work from the CPU.

A Figure 7 A screenshot of
an alien world from the game No Man’s Sky

Consider Figure 7. Notice the lighting, shading, and colours in the sky and grass.
Think of the individual leaves on the tree. Each of those colours, pixels, and

shapes needs to be calculated and rendered. Itis a lot of computational work,
especially if the player is moving around (because the lighting and perspective of
the shapes change) and the grass and clouds are moving in the breeze.

A Figure8 GPUs have thousands
of cores capable of handling multiple

operations simultaneously. This is beneficial
for multidimensional data sets where
operations often need to be performed

across various dimensions in parallel

Al Computer fundamentals

You will learn more about machine
learning in topic A4 Machine
learning.

GPUs are increasingly used in Al and machine learning. Their ability to perform
parallel processing allows for faster processing oflarge data sets which is
essential in training neural networks. For example, neural networks, which are
at the heart of many Al applications, require the processing of large amounts
of data during their training phase. These training processes involve extensive
matrix multiplications and other operations which can be parallelized effectively
ona GPU.

Scientific computing and large simulations

A Figure9 Researchers can use models
and simulations
to test drugs or understand
disease. Human DNA has 3.1 billion base
pairs—that is a lot of possible combinations

to model and simulatel

GPUs are used in various scientific fields for large simulations and data analysis.
Their parallel processing capabilities allow for quicker computations in areas
such as physics simulations, climate modelling and bicinformatics. For example,
in biocinformatics, GPUs play an important role in the processing and analysis of
genetic information. One specific application is in genome sequencing, where
GPUs are used to align sequences and identify genetic variations quickly. This
process involves comparing a massive number of DNA sequences (millions of
seguences) against reference genomes to identify mutations and variations, a task
that is highly parallelizable.

Graphics design and video editing
In graphics design, especially in the creation of 3D models and environments,
GPUs enable designers to visualize their work in real-time. For example, when
using software such as Blender or Autodesk Maya, GPUs are utilized to render
complex scenes, including lighting effects, shadows and textures, in real-time.

A Figure 10 GPUs can facilitate very rapid
changes to lighting, colours and more. In
this image, every single pixel needs to be
assigned a colour and brightness

A1.1.3 Explain the differences between the
CPU and the GPU
Design philosophy, usage scenarios
Design philosophy
The design philosophy of CPU architecture emphasizes flexibility and
generalizability, enabling CPUs to efficiently process a wide variety of
instructions and data types. In addition, CPUs are designed for low latency,
meaning they prioritize getting things done quickly, even ifit is just one task at a
time. Flexibility, generalization, and low latency translate to design choices where
CPUs typically have a smaller number of cores compared to GPUs, but each core
is more powerful with features such as larger caches and complex logic units.
This allows CPUs to handle a wider variety of instructions efficiently.
Another design choice is a focus on branch prediction. CPUs excel at predicting
which instruction will be needed next and fetching it in advance. This minimizes
wasted time and keeps the core running smoothly.
Finally, instruction versatility is an important design choice. CPUs are built to
understand and execute a large set of instructions, making them ideal for running
general-purpose software such as web browsers, office applications, and even
video games (though not for the intensive graphics processing needed in some
games).

Al.l Computer hardware and operation

The GPU is built for high throughput. It is optimized for tasks that can be
decomposed into smaller, independent pieces. GPUs have a large number
of cores, each less powerful than a CPU core but designed for simpler tasks.
This allows GPUs to process a large amount of data simultaneously. GPUs are
optimized for single instruction, multiple data (SIMD) operations, where the same
instruction is applied to many data elements at once. GPUs are designed to move
data efficiently between cores and memory, prioritizing high bandwidth over
complex logic components in each core.

Usage scenarios
Usage scenarios for CPUs include running operating systems and managing
system resources, executing general-purpose software tasks, decoding and
handling user input (mouse clicks, key presses), and multitasking between
different applications.
Usage scenarios in GPUs include processing graphics and rendering images
and videos for gaming and video editing, accelerating scientific simulations
and machine learning algorithms, encoding and decoding video streams, and
cryptocurrency mining.

Core architecture, processing power, memory access,
power efficiency

TOK
CPUs and GPUs are specialized to
solve specific types of problems.
Working together, they can
leverage their specializations
to solve much more complex
problems than they could
individually.
To what extent do the differences
between GPUs and CPUs influence
our understanding and approach
to computational efficiency and
problem-solving in modern
computing?
In what ways can other systems
be combined to solve more
complex problems? Are our most
stubborn problems the result of not
combining the right systems?

Core architecture
An element in the core architecture of a CPU is the instruction set architecture
(ISA), which defines the fundamental operations a CPU can perform. Each

instruction in an ISA specifies a particular operation involving arithmetic
operations, data movement, logical operations, control flow changes, or system
interactions. Unique to a CPU are specific types of instructions such as system
management instructions and complex branching instructions.
GPUs also have an ISA. Each instruction in a GPU's ISA is designed towards
handling extensive arithmetic operations and data movement, and there is less
emphasis on complex logical operations and control flow changes compared
to CPUs. This is because GPUs are optimized for throughput over task versatility.
Unigue to a GPU's ISA are specific types of instructions optimized for graphics
rendering and parallel data processing tasks, such as the following.

Instruction set architecture

(ISA) The element of the CPU
that specifies the commands
that a processor can understand
and execute, such as arithmetic
operations, data handling, and

control instructions.

SIMD instructions: Allow a single operation to be applied simultaneously to a
large set of data, which is ideal for the parallel nature of graphics processing and
certain types of computational tasks in scientific computing and deep learning.
Texture mapping and manipulation instructions: Essential for graphics
processing, these instructions handle tasks like pixel interpolation and texture
fetching, which are important for rendering images and videos.

Processing power
Processing power refers to the ability of the device to perform computational
tasks. It is a measure of how much work a CPU or GPU can perform in a given
amount of time, which directly impacts the performance ofsoftware applications
running on these processors. Different factors can influence the processing
power ofa CPU or GPU; for example, the number of cores, clock speed, thermal

management, and power delivery
to the processor.

Processing power The ability of
the CPU to execute instructions,

often quantified in terms of clock
speed.
Clock speed The frequency at
which a CPU executes instructions.
It is typically measured in gigahertz
(GHz).

Al Computer fundamentals

GPUs were devised to render
graphics, off-loading that work

CPUs are designed with fewer, more powerful cores than GPUs. They feature
higher clock speeds and advanced technologies such as branch prediction and
out-of-order execution, which optimize sequential task processing. Multithreading
capabilities and a high instructions per cycle (IPC) rate enable CPUs to efficiently
manage multiple tasks and complex computational instructions.

from the CPU. In 2024, GPUs

are indispensable for machine
learning and are perfect for highly
repetitive tasks.
To what extent do CPU
design choices influence our
understanding oftheir role and
efficiency in processing diverse
instructions? These choices may
include prioritizing flexibility,
generalizability or low latency. How
does the CPU’s ability to work with
diverse instructions compare to the
specialized tasks handled by GPUs?
The nature of the choices made
during design can dictate how a
system is used in the future. Should
systems be highly specialized?
Do any design choices for current
systems limit our ability to solve
highly complex problems?

GPUs possess a large parallel architecture with hundreds to thousands of cores,
enabling efficient handling of large-scale parallel processing tasks. High memory
bandwidth and specialized cores, such as tensor cores, enhance their ability to

process large blocks of data quickly and effectively. The SIMD capabilities allow
GPUs to perform the same operation on multiple data points at once, maximizing
throughput for suitable tasks. While individual GPU cores may operate at a lower
clock speed and with simpler instructions compared to CPU cores, the sheer
number ofthese cores allows for a tremendous amount of parallel processing
power. Remember, the “simple instructions” in GPU cores are designed for
parallel execution, making them specialized rather than inherently less powerful.

Memory access
Memory access in the context of computing hardware such as CPUs and GPUs
refers to how these processors retrieve and manipulate data stored in computer
memory. Each type of processor handles memory access differently based on its
architectural design, which impacts its overall performance.
CPUs utilize a memory hierarchy to manage data access efficiently (for more on
this, refer to A1.1.4). This hierarchy typically includes several levels of caches
(L1, L2, and sometimes L3). This hierarchy is optimized to minimize memary

latency—the delay from issuing a memory request to receiving the data. CPUs
often operate in multi-core environments, necessitating mechanisms such as
cache coherence protocols. These protocols ensure that multiple CPU cores
have a consistent view of the data in the memory, preventing data conflicts and
ensuring data integrity across the cores.
Modern GPUs often use a unified memory architecture, which allows them
to access a large, shared pool of memory which both the GPU and CPU can
address. GPUs are designed with high bandwidth memory. These memory types
are optimized for the high-throughput requirements of GPU tasks, enabling
fast data transfer rates that support the processing capabilities of hundreds to
thousands of parallel cores. Unlike CPUs, which are optimized for low-latency
access, GPUs prioritize memory throughput.
To summarize memory access, CPUs utilize low-latency memory because they
need to rapidly switch between tasks, retrieve data from memory, and execute
operations based on that data with minimal delay. GPUs utilize high memory
throughput because they handle large volumes of data and need to feed
hundreds to thousands of parallel cores simultaneously.

Power efficiency
CPUs and GPUs use electrical power to perform computational tasks. Power
efficiency is a significant aspect of processor design and operation, especially in
environments where energy consumption impacts cost, thermal management,

and system longevity.
For CPUs, power efficiency is often defined by how much computing work can
be performed per watt. This ratio measures the computational output relative to
power consumption, providing a benchmark to compare the efficiency of different
CPU models. Higher performance per watt indicates a more power-efficient CPU.

Al.l Computer hardware and operation

Modern CPUs incorporate advanced power management technologies that
adjust the power usage based on the workload. Techniques such as dynamic
voltage and frequency scaling (DVFS) allow CPUs to reduce power consumption
when full processing power is not needed. Another aspect of power efficiency is
thermal design power (TDP). TDP is the maximum amount of heat generated by a
CPU that the cooling system in a computer is designed to dissipate under normal
conditions. Efficient CPUs manage to deliver more performance while staying
within a lower TDP envelope.
GPUs, particularly those used in high-performance computing and gaming, also
prioritize power efficiency, given their potential for high power consumption.
Since GPUs handle many tasks simultaneously, their power efficiency often
benefits from their ability to spread workload across many cores, reducing the
power per task when compared with serial processing. Like CPUs, many GPUs
incorporate features that help reduce power usage when full graphical power is
not required, such as lowering clock speeds or powering down idle cores. GPUs
are generally more power-efficient at parallel processing tasks than CPUs.

CPUs and GPUs working together: Task division, data
sharing, and coordinating execution
CPUs and GPUs must collaborate effectively to optimize computing tasks.
Understanding how they work together is important.
CPUs are designed for general-purpose processing, and GPUs are designed
for parallel processing capability. General-purpose processing is executing
a variety of instructions with complex logic and decision-making. Parallel
processing is performing the same operation simultaneously on multiple pieces
of data. You can think of this like the roles in a professional kitchen: the head chef
(CPU) ensures everything is in order. The specialized cooks (GPU) handle the
high-volume tasks.
Task division
When CPUs and GPUs work together, tasks are typically divided based on
their nature and requirements. Sequential and control-intensive tasks remain
the domain of the CPU, which manages the system, performs logic and
control operations, and processes tasks that require frequent decision-making.
Some examples of tasks executed by a CPU are OS management, network
communication, and input/output handling.
Parallelizable data-intensive tasks are offloaded to the GPU, where hundreds or

thousands of smaller, independent tasks can be executed simultaneously. This
includes operations such as matrix multiplications in machine learning algorithms,
pixel processing in graphics rendering, and data analysis in scientific computations.

Data sharing
For CPUs and GPUs to work together effectively, they must share data. Initially, data
is stored in primary memory, accessible by the CPU. For the GPU to process this
data, it must be transferred to the GPU’s memory through the peripheral component
interconnect express (PCle) bus, which can be a bottleneck. Some architectures

offer unified memory, allowing both the CPU and GPU to access the same physical
memory space, simplifying data sharing and minimizing transfer overheads.

A Figure 11 Managing heat is direc
related to performance

Al Computer fundamentals

Coordinating execution
Coordinating the execution between CPUs and GPUs involves using
programming languages such as CUDA (for Nvidia GPUs) and OpenCL. These
languages provide the necessary tocls to manage how tasks are divided between
CPUs and GPUs, including memory management and task synchronization. This
often involves synchronization primitives like barriers or events. Modern systems
can dynamically allocate tasks to CPUs and GPUs based on the current workload
and the nature of the tasks, optimizing for performance and energy efficiency.
A barrier is a synchronization mechanism used to ensure that multiple threads or
processes reach a certain point in execution before any are allowed to proceed.
Think of it as a checkpoint in a race that all runners (threads) must reach before the

race can continue to the next segment. In parallel programming, barriers are used
to implement a point of synchronization where threads pause their execution until
all participating threads have reached the barrier point. Once the last thread arrives
at the barrier, all threads are released to proceed with their subsequent operations.
An event is a synchronization primitive that allows threads to wait for certain
conditions to be met before continuing their execution. Unlike barriers, which
synchronize a group of threads at a predefined point, events are more flexible
and can be used to signal one or more waiting threads that a specific condition
has occurred, such as the completion of a task or the availability of required data.

A1.1.4 Explain the purposes of different
types of primary memory
Registers, cache (L1, L2, L3), random-access memory

(RAM), and read-only memory (ROM)
Primary memory serves as the central workspace for the CPU, facilitating the
storage and quick access to data and instructions which are in active use.
Volatile memory Requires power
to maintain the stored data. When
the power is tumed off, the data is
lost. An example of volatile memory
is RAM (random-access memory).
Non-volatile memory Retains
stored information even when

the power is tumed off. Examples
include ROM (read-only memory),
SSDs (solid state drives), and HDDs
(hard disk drives).

Registers
The fastest and smallest type of memory, built directly into the CPU. They store
data, instructions and addresses the CPU is actively executing. This memory is
volatile. The fundamental unit of data handled by a CPU’s architecture is the
“word size”, which describes the size ofa register. In general, registers hold
32 or 64 bits of data.

Cache (L1, L2, L3)
High-speed memory residing on or close to the CPU. Caches bridge the speed
gap between registers and RAM, holding frequently used data and instructions
for quick retrieval. This memory is volatile.
*

|1 cache typically ranges from 32 KB to 256 KB per core, with data and
instruction caches separate in some architectures.

*

|2 cache typically ranges from 256 KB to 16 MB per core or shared across
multiple cores.

*

|3 cache typically ranges from 2 MB to 32 MB shared across all cores in
aCPU.

Al.l Computer hardware and operation

Main memory (RAM)
The primary workspace of the computer. RAM temporarily stores the currently
running operating system, processes, and active data and instructions. This
memory is volatile. RAM capacity is typically measured in gigabytes (GB). In
2024, 16 GB of RAM would be adequate for multitasking, light gaming, and
content creation, while 32+ GB would be ideal for power users, heavy gaming,
video editing, and professional applications. 32-bit operating systems generally
have a limit of around 4 GB of RAM, while 64-bit systems can address a much
larger amount of RAM. The authors are quite certain these memory baselines will
increase significantly in the future.

Read-only memory (ROM)
A non-volatile memory that stores essential instructions and data for the computer
to start up (for example, the BIOS or firmware). Data in ROM is typically not
modifiable during normal computer operation, although it is modifiable via
special processes. ROM's role is primarily for firmware storage and it is not
directly involved in the day-to-day memory access hierarchy involving registers,
cache and RAM. ltis better considered as a separate entity focused on system
boot-up and low-level startup operations.

The interaction of the CPU with different types of memory
to optimize performance
Computing systems are designed to be as efficient as possible. The CPU
interacts with different types of memory in a hierarchical manner to optimize
performance. This interaction is guided by the principles of minimizing latency
and maximizing throughput for data and instruction access. Latency is the
time it takes for data to move from its source to its destination. Latency is
usually described as low or high. Throughput is the amount of data that can be
processed or transmitted in a given amount of time.
The hierarchical memory system, from registers to RAM, serves an important role
in this optimization process. The CPU interacts with these different memory types
as follows.

Registers
Direct interaction: The CPU has internal registers, which are the fastest type of
memory available. These registers are used to store immediate data which the
CPU needs for current operations, such as operands for arithmetic operations,
address pointers, and the results of operations.

Latency The time delay between
the transmission of a data packet
and its reception. It is typically
measured in milliseconds. Latency
represents the total time taken for
the data to travel from the source
to the destination. It is synonymous
with the term “lag”.

Smallest - Fastest

Registers (closest to the CPU):
Tiny, ultra-fast memory for
immediate calculations.

Cache (L1, L2, L3): Still very fast.
Holds recently used data for
quick access by the CPU.

BN

e

Main memory (RAM): Holds the currently
running programs and their data.
Slower than cache but larger capacity.

I

Storage (SSD, hard drive): Mass storage
for files and data not in immediate use.
Largest capacity but also the slowest.

One of the guiding principles in hierarchical memory design is to keep
frequently used, related data as close to the CPU as possible: this enables
faster processing of data and instructions.
How does the hierarchical structure of memory components influence our
understanding of processing speed and data accessibility in computer systems?
Grouping similar data involves making assumptions about how data is similar.
How might assumptions about relatedness of data be helpful or problematic?

Largest

Slowest

A Figure
12 The hierarchical memory
system. The closer the memory is to the
CPU, the faster and smaller in capacity it is

Al Computer fundamentals

Optimization: By utilizing registers for the most immediately necessary data
and instructions, the CPU minimizes the need to access slower types of memory,
significantly speeding up processing times.

Cache (L1, L2, L3)
Hierarchical use: Cache memory serves as a high-speed intermediary between
the CPU and the slower main memory (RAM). ltis divided into levels (L1, L2, L3)
based on proximity to the CPU, with L1 being the smallest and fastest, and L3
being larger and slightly slower but still faster than RAM.
Data and instruction prefetching: Modern CPUs use sophisticated algorithms
to predict which data and instructions will be needed socn, and pre-emptively
load them into the cache. This anticipatory action reduces the time the CPU
spends waiting for data, thus optimizing performance.
Spatial and temporal locality: Caches exploit the principles ofspatial (data
near recently accessed data is likely to be accessed soon) and temporal (recently
accessed data is likely to be accessed again soon) locality to keep relevant data
close at hand, further optimizing performance.

Main memory (RAM)
Central data repository: RAM holds the operating system, applications and
data that are currently in use. It provides a much larger space for data storage
compared to caches and registers.
Interaction through memory controller: The CPU interacts with RAM via
the memory controller, a chipset that manages data transactions between the
CPU and RAM. This controller plays a critical role in managing access times and
optimizing the flow of data between the CPU and RAM.
Virtual memory: The system can use a portion of the hard drive (or SSD) as
virtual memory, extending the available memory space. The CPU manages the
swapping of data between RAM and virtual memory, though this process is
significantly slower than accessing RAM directly.

Read-only memory (ROM)
Boot-up process: While not directly involved in the CPU's data processing
tasks, ROM contains the firmware or BIOS necessary
for the initial booting of the
computer and basic hardware initialization. The CPU accesses this read-only data
at startup to load the operating system from secondary storage (for example,
HDD or SSD) into RAM.

The relevance of terms “cache miss” and “cache hit”
The CPU first checks the registers for the data it needs. If the data is not found
in the registers, the CPU checks the L1 cache, then the L2 cache, and then L3
cache, and finally the main memory (RAM). Sometimes, the CPU finds the data it

needs (a hit) and sometimes the data is not found (a miss).
A cache hit occurs when the CPU finds the data it needs in a cache. This is the
fastest case, as the CPU can access the data almost instantaneously. A cache
miss occurs when the data is not found in the cache. In this case, the CPU needs

to fetch the data from main memory, which is slower than accessing the cache.

Al.l Computer hardware and operation

To minimize cache misses, the CPU uses a variety of techniques, including the
following.
Prefetching: The CPU can predict which data it will need in the future and fetch
it into the cache before it is actually needed.
Memory allocation: The operating system can allocate data to appropriate
memory locations based on usage patterns to maximize cache hits.
Cache replacement policies: The operating system can choose which data to
evict from the cache when it is full to optimize cache hit rates.
By optimizing the interaction between the CPU and different types of memary,
the CPU can significantly improve the performance of computer systems.
Figure 13 shows some additional points to remember about the interaction of the
CPU with different types of memory.
Table 3 |ust how fast is memory?
Unit of time

1 nanosecond

(ns)

1 microsecond

(ps)

Smallest

Fastest

The CPU prefers to access
registers for the fastest
possible access to data.
L1 cache is the fastest type of
memory thatis not located
directly on the CPU.

N

e

L2 cache is slower than L1
cache but still faster than
main memaory.

I
L3 cache is slower than
L2 cache but still faster
than main memory.

BN

Definition

Examples

Main memory is the largest
type of memory but also
slower than cache memory.

one billionth ofa second

The time to execute one machine
cycle by an Intel Pentium 4 1 GHz
MiCroprocessor.
Light travels 12 inches (30 cm) in 1 ns.

one millionth ofa second

The time to execute one
machine cycle by an Intel 80186
MiCroprocessor.

1 millisecond

one thousandth ofa

The length of the flash strobe on a
camera.

(ms)

second

It takes around 50-80 ms to blink

gsiecond

1 second

an eye.
:
,
m:l:;:gfeatll(r;:]z t_o say ‘one

N
2
ROM is the slowest type of memory but is
non-volatile, meaning it retains its contents
when the power is turned off.

Largest

Slowest

A Figure
13 The interaction of the CPU
with different types of memory

Type of memory

Access time

Size

Latency

Register

0.2-0.5 nanoseconds

Smallest

Lowest

Level 1(L1) cache

3-7 nanoseconds

Small

Lower

Level 2 (L2) cache

5-10 nanoseconds

Larger than L1 cache

Moderate

Level 3 (L3) cache

10-40 nanoseconds

Larger than L2 cache

Moderate to high

Main memory (RAM)

50-70 nanoseconds

Largest

Highest

Al Computer fundamentals

Fetch

A1.1.5 Describe the fetch, decode and
execute cycle
Decode

The fetch-decode-execute cycle is the fundamental cycle of instruction
execution in a computer. This cycle is also known as the instruction cycle. When
you run a program, itis executed by your CPU. The fetch-decode-execute cycle
describes how instructions are executed.
It consists of three main steps.

A Figure 14 The fetch-decode-execute
<

cle

1. Fetch: The CPU fetches an instruction from memory.
2. Decode: The CPU decodes the instruction, which means it interprets the

instruction into a set of low-level operations that the CPU can execute.
3. Execute: The CPU executes the instruction, which means it carries out the
low-level operations that were specified in the decoded instruction.
The fetch-decode—-execute cycle is repeated for each instruction in a program.
The speed of the CPU is largely determined by how quickly and efficiently
it can execute this cycle. Executing a single machine language instruction
involves a sequence of operations which are performed by the CPU. These
operations can be broadly categorized into three main phases: fetch, decode
and execute.

Representing primary memory
Table 4 Example reference table
showing memory address and
corresponding data or instructions
Address

Data/Instructions

01

42

Whenever you think about primary memory (RAM), drawing a table like Table 4
can be helpful. This is a simplified representation where the memory address is
on the left, and the corresponding data or instructions are on the right. This is
especially useful when working with the fetch-decode-execute cycle because
it helps you understand the relationship between addresses and their contents
in RAM.

02

69

03

LOAD 01

In the Table
4 example:
¢

address 01 and O2 store data values

04

ADD 01, 02

*

address 03 contains a LOAD instruction to load data from address O1

05

STORE 04, 03

*

address 04 has an ADD instruction to add the contents of addresses 01
and 02

*

address 05 includes a STORE instruction to store the result from address 04
into address 03.

This example is quite basic, and real primary memory is much more complex,
with all values stored in binary. However, using this representation can help you
conceptualize how the fetch-decode-execute cycle operates in practice.

Fetch phase
In the fetch phase (Figure 15), the CPU retrieves a machine language instruction
from main memory (typically RAM). This involves the CPU sending a request
to the memory to fetch the instruction. The address of the instruction to be
fetched is stored in the memory address register (MAR), and the fetched

A Figure15 Fetch

instruction is then transferred to a special register called the instruction register
(IR)
in the CPU.

Al.l Computer hardware and operation

Decode phase
In the decode phase (Figure 16), the CPU interprets the machine language instruction
fetched during the previous phase. This phase is managed primarily by the CPU's
control unit, which decodes the instruction by analysing these components:

*

opcode (operation code): dictates the type of operation

*

operands: the data to be operated on

*

addressing modes: determine how to locate the operands.

Additionally, the decode phase involves checking the validity of the instruction
and ensuring that the operands are within an acceptable range. This phase also
calculates the effective address of the operands, which is the actual memory
address where the operands are located.
A Figure 16 Decode

Execute phase
During the execute phase, the CPU performs the operation specified by the
instruction decoded in the previous phase. The specific operation carried out is
dictated by the opcode. Common operations include the following.
Arithmetic operations: Addition, subtraction, multiplication, and division,

typically performed by the ALU.
Logical operations: Logical functions like AND, OR, and NOT, also managed by

the ALU.
Memory access operations: Load (reading data from memory into a register)
and store (writing data from a register to memory) operations, which involve
interaction with the system’s memory.
A Figure17 Execute

Control operations: Conditional and unconditional jumps which alter the flow
of execution based on specific conditions.

TOK
Recognising patterns is an important part of being a
computer scientist. The fetch-decode-execute cycle is
a pattern that is still used today. Modern computers can
cycle through this pattern more than a billion times a
second. What patterns could be developed today that
may be helpful in the future?

@ Research skills
Opcodes (operation codes)
Opcodes are part of the instruction in a machine
language program which specifies the operation to be
performed. Here are some examples of opcodes in
assembly language, which is directly related to machine
code opcodes.

Outside of computing, are there patterns of doing
work that are better than other patterns?

*

MOV Move datafrom one location to another.

*

ADD Add two operands.

Outside of computing, how do you identify if some
working patterns are better than other patterns?
Consider this in the context of completing homework for
school. You might work for 30 minutes, then takea 10
minute break and repeat this cycle until you have finished
the work. Is that the best pattern? How do you know?

*

SUB Subtract one operand from another.

*

MUL Multiply two operands.

How does knowledge ofa cycle of instruction shape
our perception of computational efficiency and
program execution?

Each opcode corresponds to a specific machine
language instruction. The binary codes for these
operations can differ between each architecture, such as
x86, ARM or MIPS.
Research the following opcodes to find out what
operations they specify: DIV, AND, OR, JMP.

Al Computer fundamentals

Worked example 1
The instruction ADD R1, R2, R3 adds the values in registers R2 and R3 and stores the result in register R1.
Describe the fetch, decode and execute phases of an ADD instruction cycle ina CPU.

Solution
Fetch phase

1.

Memory address: The program counter (PC) points to
the memory address where the instruction is stored.

3. Operands: It identifies R2 and R3 as the source

Fetch: The CPU fetches the instruction ADDR1, R2,

4.

registers containing the operands.

R3 from this address.

where the result will be stored.

IR: The fetched instruction is placed into the

Execute phase

instruction register (IR).

1.

Decode phase

1.

Control unit: The control unit reads the instruction in

Decoding: The control unit decodes the instruction

ALU operation: The ALU receives the contents of
R2 and R3.

2. Addition: The ALU performs the addition Value in

the IR.
2.

Destination: It identifies R1 as the destination register

R2 + Value in R3.

3.

and understands it needs to perform an addition.

Store Result: The result of the addition is stored back

into R1.

Worked example 2
The instruction CMP R1, R2 compares the values in registers R1 and R2 and sets the CPU status flags (for example,
zero flag, carry flag) based on the comparison result. Describe the fetch, decode and execute phases ofaCMP
instruction cycle in a CPU.

Solution
Fetch phase

1.

Memory address: The PC holds the memory address

Execute phase

of the next instruction to be executed, which is where

1.

the CMP R1, R2 instruction is stored.

ALU operation: The ALU receives the values stored in
registers R1 and R2.

Fetch: The CPU fetches the CMP R1, R2 instruction

Comparison: The ALU compares the values in R1 and

from the memory location specified by the PC.
IR: The fetched instruction CMPR1, R2 is placed into
the IR.

R2. This operation involves subtracting the value in R2
from the value in R1 to determine the result.

Decode phase

Set flags: Based on the comparison result, the ALU
updates the status flags:

1.

Control unit: The control unit reads the instruction in

»

Zeroflag: SetifR1is equal to R2.

the IR to understand what needs to be done.

*

Negative flag: Set if R1 is less than R2.

Decoding: The control unit decodes the instruction and
determines that it is a compare operation. |t understands
that it needs to compare the values in R1 and R2.

*

Carryflag: Setif there is a borrow in subtraction
(often used in unsigned comparisons).

Operands: The CU identifies R1 and R2 as the source
registers containing the operands for the comparison.
No Destination: Unlike arithmetic operations, CMP
does not have a destination register for storing results,
as it only affects the status flags.

*

Qverflow flag: Set if there is an arithmetic
overflow (less relevant for a basic compare).

PC update: The PCis incremented to point to the next
instruction in sequence, preparing the CPU for the
next fetch phase.

Al.l Computer hardware and operation

Worked example 3
Outline how a CPU processes a command for calculating an average score.

Solution
1.

Initial setup
*

Scores: Stored in consecutive memory addresses.

*

Number of scores: Stored in a special memory
location.

*

Sum of scores: Accumulated in Register R1.

*

Current score: Loaded into Register R2.

*

Counter: Number of scores processed, kept in
Register R3.

*
2.

Fetch-decode-execute cycle 1: Initialize registers
*

Fetch: LOAD R1, #0 (Initialize R]tozero
for sum)

*

Decode: Recognize LOAD operation. Operand is
immediate value #0.

*

Execute: SetR1to 0.

*

Fetch: LOAD R3, #0 (Initialize R3 as counter).

*

Decode: Decode to a load immediate value

e

3.

Average: To be calculated and stored in
Register R4.

Execute: Access memory and put the number of
scores into R5.
Sum scores loop
Loop start: Check if R3 (counter) is less than R5
(total scores).
Fetch:LOAD R2, (address_of_ scores +
R3) (Load current score to R2).
Decode: Decode load instruction, calculate

address as offset by R3.
Execute: Access memory, load score into R2.
Fetch:ADD R1, R1,

R2(Add currentscore
to

sum).
Decode: Recognize add operation, operands R1
and R2.
Execute: Compute sum, store back in R1.
Fetch: ADD R3, R3, #1 (Increment counter).
Decode: Decode addition, immediate increment.
Execute: Increment R3 by 1.

into R3.

Conditional loop: Check if R3 is still less than R5.

Execute: Set R3 to O.

Execute: IfR3 <R5, jump back to loop start.

Load number of scores

Calculate average

*

Fetch: LOAD R5, address_of num_scores
(Load number of scores into R5).

Fetch: DIV R4, R1, RS5 (Dividesum by
number of scores to get average).

*

Decode: Decode to load from memory address
into R5.

Decode: Decode divide operation.
Execute: Perform division, store result in R4.

Al Computer fundamentals

The interaction between memory and registers via the
three buses (address, data, and control)
Data, instructions, and control signals need to be transferred between a CPU and
Control bus

[

|

Address bus

A Figure 18 Interaction between buses
and registers. Arrows indicate data flow

off-chip components in an organized, predictable and efficient manner.
This movement between memory and registers isfacilitated through a set of three
buses.
A bus is a communication system which transfers data between various
components within a computer. The term is used to refer to both the physical
connection—wires and printed circuit tracks—as well as the protocols (rules and
signalling standards) used to manage the communication.
The three buses are the address bus, data bus, and control bus. These buses
form the communication channels between the CPU, main memory, and other

components within a computer system. Sometimes these three buses are
referred to collectively as the system bus.
Address bus
Bits and bytes are units of data.
You will learn more about them in

subtopic Al.2.

The address bus carries memaory addresses from the CPU to the memary
controller. The memory address specifies the location of the data or instruction
that the CPU wants to access. The address bus is typicallya parallel bus, meaning
it consists of multiple wires, one for each bit of the memory address. The number
of wires in the address bus determines the maximum amount of memory that the
CPU can address.
Data bus
The data bus carries data between the CPU and memory. It can be used to
transfer both instructions and data. The data bus is typically a parallel bus,
meaning it consists of multiple wires, one for each byte of data. The width of the
data bus determines the maximum amount of data that can be transferred in a
single operation.
Control bus
The control bus carries various control signals necessary for managing
and coordinating the interactions between the CPU and other system
components such as the memory. These signals include—but are not limited
to—read, write, and acknowledge. The read signal prompts the memory
controller
to retrieve data from a specified address and send it to the CPU.
The write signal initiates a data storage operation at a specific memory
address. The acknowledge signal confirms the completion of a data transfer.
Additional signals on the control bus may include interrupt requests, which
allow peripherals to request CPU attention, and clock signals, which help
synchronize data transfers and ensure that operations occur at the correct
times and in the right sequence.
The three buses work together to enable the CPU to read data from memory,
write data to memory, and access instructions from memory. The address bus
specifies which memory location to access, the data bus transfers the data
between the CPU and memory, and the control bus provides the signals that
control the data transfer.

Al.l Computer hardware and operation

Examples of the interaction between memory and registers
Worked example 4
Outline howa CPU processes a command to read the value stored at memory location Ox1A3B.

Solution
:

Address | The CPU sends the memory address Ox1A3B to the memory controller via the address bus. This bus
bus
carries the memory address specifying where the data the CPU needs is located.

5 Control | The CPU sends a read signal over the control bus to the memory controller. This signal instructs the
bus
memory controller
to retrieve data from the address specified.
3

Data
bus

Once the memory controller receives the read signal, it fetches the data from memory location Ox1A3B
and sends it back to the CPU using the data bus. This bus carries the actual data from memory to the CPU.

Control | An acknowledge signal is sent back to the CPU via the control bus once the data has been successfully
bus
transferred to indicate that the read operation is complete.

Worked example 5
Qutline how a CPU processes a command to write the value Ox7E to memory location Ox4F2.

Solution
1

Address
bus

2 | Databus

3

Control
bus

The CPU uses the address bus to send the target memory address Ox4F2 to the memory controller,
indicating where the data should be stored.
The value Ox7E is sent to the memory controller via the data bus. This bus carries the data that the
)
.
CPU intends to store in memory.
The CPU sends a write signal to the memory controller over the control bus. This signal commands
the memory controller to store the data received on the data bus at the address provided by the
address bus.

Control
After the data has been written to the specified memory location, the memory controller sends an
4 | bus,
acknowledge signal back to the CPU via the control bus, confirming that the write operation has
continued | been successfully completed.

A1.1.6 Describe the process of pipelining in
multi-core architectures
Pipelining
Pipelining allows a processor to execute multiple instructions at the same time.
This can significantly improve the overall throughput of the system.
The following laundry analogy is not perfect, but it helps to explain pipelining.
Non-pipelined laundry
1.

Wash: Put a load of clothes in the washing machine and wait for the cycle
to finish.

2.

Dry: Transfer the wet clothes to the dryer and wait for them to dry.

3.

Fold: Take the dry clothes out and fold them.

Pipelining A technique for
improving the performance of
computer processing by dividing
the execution of a process into
multiple parts and allowing those
parts to operate simultaneously.

Al Computer fundamentals

-$-9
DIRTY

WASHING

DRYING

FOLDING

A Figure 19 Thelaundry process

In this scenario, each task must be fully completed before starting the next. If each
task takes 30 minutes, completing a single load of laundry would take 1.5 hours.
Pipelined laundry
1.

Wash (Load A): Put the first load of clothes in the washing machine.

2.

Dry(Load A): When Load A finishes washing, transfer it to the dryer.

3.

Wash (Load B): While Load A is drying, start a second load of laundry in the
washing machine.

4.

Fold (Load A): When Load A finishes drying, fold the clothes.
Dry (Load B): When Load B finishes washing, transfer it to the dryer.

6.

Wash (Load C): While Load B is drying, start a third load of laundry in the
washing machine.

7.

Fold (Load B): When Load B finishes drying, fold the clothes.

Notice that, in the pipelined example, tasks 2 and 3 can happen at the same time
(apart from moving the clothes from one task to the next). You do not need to
wait for the clothes to finish drying before you start the wash cycle. Similarly, tasks
4,5 and 6 can all happen at the same time.
By overlapping tasks, you increase efficiency. After the initial setup time, you can
complete a load of laundry every 30 minutes instead of every 1.5 hours.

Multi-core processors

Multi-core architecture A
computing architecture where a
single physical processor contains
multiple integrated cores. A
processor can have a single core or
multiple cores.

Each core in a multi-core processor includes all the fundamental components
you would find in a single-core processor, such as an ALU, control unit, registers,
and often their own Level 1(L1) and sometimes Level 2 (L2) cache. While each core
operates independently, they typically share some higher-level caches (like L3
cache) and primary memory (RAM). This is different from single-core processors,
which do not need mechanisms for inter-core communication.
Single-core processor

Multi-core processor
Core 1

Core

Core 2

’

Shared memory

@
Y

‘

Off-chip components

Y

‘

‘

Off-chip components

A Figure 20 Comparison of single-core and multi-core processor architecture

‘

Al.l Computer hardware and operation

This integration facilitates faster communication between the cores compared
with separate processors or chips, leading to improved performance for
applications designed to take advantage of parallel processing.

How pipelining improves the overall system performance
in multi-core architectures
Pipelining enables multi-core computing. Each core typically has its own
pipeline, allowing it to fetch, decode, execute, and write back instructions

concurrently. This means that while one instruction is being executed, another
can be decoded, and yet another can be fetched, thus improving overall
processing efficiency and speed.
In the fetch phase, each core independently fetches instructions from memory.
When cores share L3 cache or RAM, the fetch mechanism must manage

cache coherency. Cache coherency ensures CPUs have data consistency and
data correctness when multiple caches store copies of the same data from
main memory.

In the decode phase, after fetching, each core decodes the instruction into its
opcode and operands. This decoding happens in parallel in each core, allowing
diverse instructions to be processed simultaneously across the cores.
In the execute phase, each core executes its decoded instructions. This
could involve ALU operations (such as arithmetic and logic), accessing
registers, or interacting with memory. Execution units in each core

work independently, though they might need to synchronize access to
shared resources.
Finally, in the writeback phase the results from the execution phase are written
back to the memory or registers. This phase is also managed independently by
each core, though write operations to shared memory may require coordination
to maintain data integrity and coherence.

Overview of how cores in multi-core processors work
independently and in parallel
Each core in a multi-core processor can operate independently of the others.
This means that each core has its own set of resources, including registers, the
ALU, and sometimes its own L1 cache, allowing it to execute a separate thread
or process. The operating system (OS) allocates different tasks or threads
to individual cores based on scheduling algorithms and the current load on
the system.
In parallel operation, the cores work together on a single task to improve
performance. This is often achieved through parallel processing, where a
task is divided into smaller subtasks which can be executed simultaneously
by different cores. For example, in a quad-core processor a task can be
divided into four parts, with each core working on one part. This division
and simultaneous execution of tasks can significantly reduce the time
required to complete complex computations or process large amounts
of data.

TOK
What happens when several
different people try to talk to you
atthe same time? Imagine you are
watching a movie, chatting with
a friend and reading a message.
How easy is it to pay attention to

everything that is happening?
What is the cost of doing many
things at the same time? Is faster
always better?
What are the implications of
simultaneous instruction execution
in computing systems?

Al Computer fundamentals

For cores to work in parallel effectively, they must coordinate and communicate
with each other. This is often facilitated by shared resources, suchas L2 or L3

cache, which allow cores to exchange data and synchronize their operations.
The effectiveness of this communication and the ability
to minimize contention
for shared resources are important factors in the overall performance of multi-core
processors in parallel tasks.

Worked example 6
Imagine a task which involves processing a list of numbers to calculate their squares and then storing the results.
Work through the steps ofa problem to clarify how pipelining functions.

Solution
1.

Divide the task into the four stages: fetch, decode,

execute and writeback.
2.

Breakthe problem into smaller tasks, and put these
into the four stages from part 1.
i.
Fetch: Retrieve numbers from an array.
Se e T R
e

iii.

Execute: Perform the calculation (square

the number).
iv. Writeback: Store the result back ina
result array.
Here is how the pipelining could be visualized
overtime (T1, T2, T3, and so on represent time units).

performed (in this case, squaring the number).

Explanation
Look at T1to T4. In the first time unit (T1), Core 1 fetches the first number. In the next time unit (T2), while Core 1 decodes
the squaring of the first number, Core 2 fetches the second number. In the next time unit (T3), Core 1 executes the
squaring of the first number, Core 2 decodes the second number and Core 3 fetches the third number, and so on. At T4,

each core is working on a different stage of the process for different data elements.
The tasks are overlapping. Notice how each core picks up a new task as soon as it completes its part of the previous task. For
instance, as soon as Core 1 finishes executing the squaring of the first number at T3, it immediately moves on to the writeback
stage at T4 and then fetches the next number at T5.
Each core processes different data elements in parallel, significantly speeding up the overall process comparedto a
single-core processor performing each task sequentially.

Al.l Computer hardware and operatlo‘

A1.1.7 Describe internal and external types
of secondary memory storage
Unlike primary memory (RAM), which is volatile and temporary, secondary
memory storage is non-volatile and retains data even when the computer is
powered off, enabling data persistence. Examples of secondary memory storage
include hard disk drives (HDDs), solid-state drives (SSDs), optical discs, and flash
drives. Secondary memory can be broadly classified into two categories: internal
and external storage. You might also encounter secondary memory storage
referred to as external memory, auxiliary storage, or mass storage.
A Figure 21 A 5.25inch floppy disk

Internal hard drives (SSD, HDD) and embedded
multimedia cards (eMMCs)
Internal hard disk drives (HDDs)
HDDs are the most common type of internal storage, and they are typically used
in desktop computers, laptops and servers. HDDs offer high storage capacities

Secondary memory storage A
type of data storage which is not
directly accessible by the CPU and

and are very reliable, but they can be comparatively slow to access data (average

is used for storing data on a long-

sustained data transfer rate for a hard disk is between 100 MB/s to 200 MB/s).

term basis.

Hard disk drives were named “hard” to distinguish their rigid, non-removable
platters coated with magnetic material, where data is stored, from the flexible
and removable media used in earlier floppy disks. The term “hard” reflects the
physical durability and fixed nature of these storage devices, in contrast to the
easily bendable early floppy disks.
An HDD consists ofa spindle that rotates at high speed and a read/write head
that moves across the surface of the platters. The read/write head can read and
write data to the platters by magnetizing tiny areas on the surface.

Hard disk drive (HDD) A type of
storage device that stores data on
magnetic disk platters.

Advantages of HDDs include large storage capacities, high reliability, and relative
affordability. Disadvantages of HDDs include slow data access speeds, and they
can also be noisy. HDDs are used in desktop computers, laptops, servers and
external hard drives.

Internal solid state drives (SSDs)
SSDs serve the same purpose as traditional hard disk drives (HDDs) but are faster

and consume less power. Unlike HDDs, which use mechanical parts and magnetic
platters to read and write data, SSDs have no moving parts, leading to quicker access
times and lower latency. The average data transfer rate for an SSD can significantly
exceed that of HDDs, in some cases reaching 2,500 MB/s to 7,000 MB/s.
A Figure 22 A hard disk drive

Solid state technology's non-volatile nature allows it to retain data without power,
similar
to traditional hard drives but without the physical constraints of rotating disks.
The core storage mechanism in an SSD is NAND flash memory, characterized
by its_ ability to retain data without power. Datg is _stored in floating-gate
transistors (memory cells) arranged within a grid-like structure on the flash
.
.
.
.
)
chip. To store data, the floating gate in each cell is electrically charged or
disch
d. This t
dch
t< a bi
lue
(0 or 1). NAND
ischarged.
This trapped charge represents a binary value (O or 1).
flash is organized into blocks, which are further subdivided into pages. Data is
written to flash memory in pages and erased in blocks.

_
Solid state drive (SSD) A type of
.
.
storage device that uses integrated
o
.
circuit assemblies to store data
persistently, typically using flash
memo
.

Computer fundamentals

To read data, the charge level within the floating gate is sensed, determining
the stored binary value. A specialized SSD controller manages operations
within the SSD, including data transfer and error correction. Due to the physical
limitations of flash cells (they can only endure a finite number of write and erase
cycles), SSDs employ wear-levelling algorithms. These techniques ensure
that write and erase operations are distributed evenly across all blocks in the
memory, prolonging its lifespan. NAND flash comes in several varieties (SLC,
MLC, TLC, QLC), with each storing a different number of bits per cell. These

types offer variations in cost, speed and endurance.
Advantages of SSDs include rapid access times, higher data transfer rates,
reduced power consumption, and increased durability due to the lack of
mechanical parts. However, SSDs can be more expensive per gigabyte than
HDDs and may have limited write cycles, although technology improvements are
continually mitigating these downsides.

Embedded multimedia cards (eMMCs)

A Figure24 A16MB eMMC card

Embedded multimedia card

(eMMC) A type of solid-state
storage device that is typically
used in portable devices such as
smartphones, tablets and digital
cameras.

,

I

A Figure 25 An external hard drive

External hard disk drives (HDDs)
and solid-state drives (SSDs)
External storage devices that can
be connected to a computer via
a cable (for example, a USB or

Thunderbolt cable).
Optical drives Devices that can read
and write data to optical discs, such
as CDs, DVDs and Blu-ray discs.

An eMMC is a type of flash storage found in many low to mid-range devices.
It integrates the multimedia card interface, flash memory, and flash memory
controller on a small package on the device's motherboard. While eMMC is
solid-state and offers decent performance, it is generally slower than most SSDs,
especially in terms of sequential read/write speeds and input/output operations
per second (IOPS). eMMC storage usually offers lower capacities than SSDs
(typically ranging from 16 GB to 256 GB) and is less expensive. Its lower cost
makes it an attractive option for manufacturers of budget-friendly devices.
eMMCs utilize NAND flash memory, described above. Advantages of
eMMCs include fast data access speeds, highly reliable, relatively shockproof.
Disadvantages of eMMCs include greater expense than HDDs, and
comparatively lower storage capacities than HDDs and SSDs.

External hard drives, optical drives, flash drives, memory

cards, and network attached storage
External hard drives (SSD, HDD)
External hard drives come in a variety of sizes and capacities, and they can be
used to back up important data, transfer files between computers, or simply store
data. The basic functionality of external HDDs and SSDs is the same as for internal
HDDs and SSDs.

Optical drives
Optical drives were once a common type of external storage, but they
have been largely supplanted by HDDs and SSDs. However, optical drives
are still useful for archiving large amounts of data and for compatibility with
older devices.
An optical disc stores data as tiny indentations known as pits, encoded in a spiral
track on the disc’s surface. The areas between pits are known as lands.
The process of reading and writing data on an optical disc involves a
combination of physical structure, optical technology, and digital encoding. An
optical disc is made ofa polycarbonate plastic disc, with a reflective metal layer
(usually aluminium) on which data is encoded. The top of the disc may have a
label, and the entire disc is coated with a protective lacquer.

Al.l Computer hardware and operation

The data on an optical disc is stored in a single spiral track that starts near the
centre and moves outward, containing a sequence of pits and lands. To read
data, an optical drive uses a laser diode to emit a beam of light that passes
through the polycarbonate layer of the disc and reflects off the metal layer. The
presence of pits and lands causes variations in the way light is reflected back to
a photodiode sensor in the player.

A Figure 26 An external DVD drive

pits land
A Figure 27 Pitsand lands on an optical disk

Specifically, when the laser hits a land, it is reflected directly back, but when it hits
a pit, the light is scattered or reflected at a different angle, causing a change in
the intensity of the light received by the sensor. The photodiode sensor detects
these changes in light intensity and converts them back into an electrical signal,
which is then processed and interpreted as the original digital data.
The advantages of optical drives include high storage capacities and
compatibility with older devices. However, they have slower data access speeds,
and discs can be fragile and susceptible to scratches and dust.
A Figure 28 Alaserinan optical drive

Flash drives
Flash drives, also known as USB flash drives, are small, portable storage devices

that can plug directly into a computer’s USB port. They are convenient for
transferring small to medium-sized files between computers. Flash drives are also
relatively affordable.
Flash drives utilize NAND flash memory, described above.

The advantages of flash drives include portability, fast data transfer speeds and
relative affordability, while disadvantages include lower storage capacities
than HDDs and SSDs, and they can be susceptible to data loss if not properly
handled. Losing a flash
drive can present a security risk if confidential data is
'
stored on the flash drive.

A Figure 29 Atypical flash drive

Memory cards
Memory cards are small, removable storage devices that are typically used
in portable devices, such as smartphones, tablets and digital cameras. They
come in a variety of sizes and capacities. Memaory cards are very convenient for
transferring files between devices and for backing up data.
Memory cards utilize NAND flash memory, described above. Advantages of
memory cards include portability, compact design, and varied storage capacities.
However, memory cards can be lost or damaged easily, and may not be
compatible with all devices.

A Figure 30 A collection of memory cards

Al Computer fundamentals

Network attached storage
Network attached storage (NAS) devices provide centralized storage for multiple
devices on a network. NAS devices are typically connected to a router, and they
can be accessed by any device on the network. NAS devices are ideal for sharing
files, backing up data and storing media files. NAS typically uses hard disk drives
(HDDs), solid state drives (SSDs), ora combination of both in hybrid setups.
NAS can be configured with RAID (redundant array of independent disks) to
protect data against drive failures and ensure data availability. NAS can be easily
expanded by adding additional hard drives to accommodate growing data needs.
A Figure 31 Network attached storage

(NAS)

Advantages of NAS include centralized storage, shared access for multiple
devices, scalable storage, and a high degree of control for system administrators.
The disadvantages of NAS devices are they are more expensive than individual
external drives, they require configuration, and they require a network connection.

A1.1.8 Describe the concept of compression
You compress data to reduce its size, enable more efficient storage, and enable
faster transmission over networks. Compression can significantly decrease the
amount of disk space needed for files and the bandwidth required for transferring
them, facilitating more efficient use of resources.

In general, the more storage you need, the more expensive it is. Network speed
can be metered, meaning you pay for what you use. The basic point here is that
compression can save money.
Additionally, compression is vital in managing large data sets, optimizing web
content delivery, and enhancing the performance of applications by minimizing
load times and storage requirements.

TOK

Lossless and lossy compression methods

Do you remember what you
learned in all your subjects at
school last week? What about last
term? And last year? If you need to

Lossless and lossy compression are two methods of reducing the size of digital
data. While both aim to decrease file size, they differ in their approach and the
impact they have on the original data.

revise this information, how do you

find it? Compare the persistence
and relative accessibility of
this data. Things you learned
more recently may be easier
to
remember without prompting. For
topics you studied some time ago,
you may need to reread your class
notes. Making revision notes while
you are learning a topic can help
you remember
it later.
How does the distinction between
secondary memory storage and
primary memory challenge our
understanding of data persistence
and accessibility?

Lossless compression
Lossless compression identifies redundant patterns and eliminates them without
losing any essential information. This ensures that the decompressed file is an
exact replica of the original file, preserving its integrity and quality. However,
the compression ratio achieved through lossless methods is generally lower
compared with lossy compression.

Worked example 7
A text file contains the following sequence of characters:
AAAAAAABBBBBCCCCCCCCCCDDDDDDDDDD

Use run length encoding (RLE) to compress this sequence.
Solution
To use RLE to compress this sequence,

There are 7 As, 5Bs, 9 Cs, and 10

count the number of consecutive

Ds. So the code becomes:

occurrences of each character.

7A5B9C10D

Al.l Computer hardware and operation

In the worked example, the compressed version ZA5B9CT0D requires significantly
fewer characters to represent the original sequence. When decompressing, the
process is reversed, and the original sequence is perfectly reconstructed. This
illustrates how lossless compression removes redundancy without losing any
original data, ensuring an exact replica of the original file upon decompression.

Lossy compression
Lossy compression employs a more aggressive strategy to achieve higher
compression ratios. It deliberately discards some data, typically minor details that
are less noticeable to the human eye or ear. This allows for significantly smaller file
sizes, making it suitable for applications such as audio, video and images. However,
the discarded information can compromise the quality of the reconstructed file.
For example, consider an image that is a simple 4x4 pixel grid, where each
pixel is either black or white. This image could be part of a larger picture, with a
segment looking like this:
Black

White

Black

White

White

Black

White

Black

Black

White

Black

White

White

Black

White

Black

Fora lossy compression, you might reduce the resolution by averaging the
colours of every 2x2 block, a process known as downsampling. In this simplistic
case, the result of averaging black and white is grey, so the 4x4 grid might be
compressed to a 2x2 grid like this:
Grey

Grey

Grey

Grey

Here, the specific details of which pixels were black and which pixels were
white are lost—only the average colour is retained. This demonstrates how
lossy compression achieves higher compression by sacrificing some details—in
this case, the exact colour of each pixel—while trying to preserve the overall
impression of the image.

Differences between lossless and lossy compression
Lossless compression prioritizes data integrity and ensures that the original file
is preserved, while lossy compression prioritizes smaller file sizes and sacrifices
some data quality for the sake of efficiency. The choice between lossless and lossy
compression depends on the specific application and the trade-off between file
size and data integrity.

There is a difference between
freshly made food and frozen food;
between a home cooked meal and
fast food. Compression changes
an original data into something
smaller, and in some cases (with

lossy compression) we lose
something from the original.
How does the practice of data
compression influence our

understanding of resource
efficiency and cost management in
digital storage and transmission?
What broader implications does
this have for the accessibility and
performance of technology?

Al Computer fundamentals

Table 5 Key differences between lossless and lossy compression

Data integrity

Compression
ratio

Lossless

Lossy

Preserves the original data, ensuring that
the decompressed file is identical to the
original file.

deliberate discarding of certain data deemed less critical

Achieves lower compression ratios
compared to lossy compression. This is
because it aims to preserve all original data,
reducing the redundancy potential.

Achieves higher compression ratios by discarding parts of
the data that are considered less important, significantly
reducing file size at the cost of some loss in quality.

Introduces variations in the reconstructed file due to the
for the intended use case.

Preferred for applications where data
Applications | integrity is critical, such as backups, archival
storage, and editing original documents.

]
.
quality may be acceptable for smaller file sizes.

Perceptual
redundancy

Lossy compression algorithms often exploit perceptual
redundancy—the fact that the human senses may not
.
)
.
.
)
distinguish between certain subtle differences in data. This

Does not use perceptual redundancy.

Used in audio, video and images, where minor loss of

allows them to discard information that is less noticeable

without significantly impacting the overall quality.
Reversible vs
irreversible

Reversible, allowing for the perfect
reconstruction of the original data from the
compressed file.

Irreversible, meaning once data has been discarded
during the compression process it cannot be restored,
leading to a permanent loss of certain information.

Run-length encoding, transform coding
Run-length encoding (RLE) and transform coding are two techniques
employed in data compression, each with its own approach and applications.

Run-length encoding (RLE) A basic
form of lossless compression. The
number of consecutive occurrences
of each character are counted
and the code changed to a mix of
numbers and letters. For example,
KXXXXYYY becomes 5X3Y.

Run-length encoding is a simple and efficient lossless compression technique that
is well suited for data with repetitive patterns. It works by identifying and replacing
consecutive occurrences of the same value with a single code that represents the
length of the run. Forinstance, the sequence AAAAA would be encoded as 5A.
RLE is particularly effective for compressing data such as text files, which often
contain long runs of blank spaces or punctuation marks. It is also used in image
compression algorithms such as fax compression, where it efficiently represents
large areas of uniform colour. (If you want to make your computer science teacher
feel old, ask them what a fax machine is!)

Transform coding is a more complex and powerful compression technique based
on mathematical transformations. It works by applying a transformation to the
data, such as the discrete cosine transform (DCT), which rearranges the data into

a representation that highlights its statistical structure.
By transforming the data into a more manageable form, transform coding can identify
and exploit redundancy in the data more effectively. This allows it to achieve higher
compression ratios compared with RLE, particularly for data with complex patterns.
Transform coding is widely used in image compression algorithms such as |PEG,
where it transforms the image into a frequency domain representation before
applying quantization to reduce the number of bits required to represent each
component. Itis also used in audio compression algorithms such as MP3, where
it transforms the audio signal into a frequency domain representation before
applying various coding techniques to achieve efficient compression.

Al.l Computer hardware and operation

Applications of RLE and transform coding
RLE is commonly used for compressing text files, images with repetitive patterns
(for example, fax images), and binary data with long runs of consecutive zeros.
Transform coding is primarily used for compressing images and audio signals,
where its ability to exploit statistical redundancy and achieve high compression
ratios is highly beneficial.
Table 6 Types of compression and their applications
Type

Example

*

Application

GIF (graphics interchange format)
While GIF can support lossless compression, it is not always the case. GIF has a
limited colour palette (256 colours) so is better for simple graphics.

*

TIFF (tagged image file format)
TIFF is commonly used in professional photography and desktop publishing, as

Backups,

it supports lossless compression and various colour depths.

documents,

*

PDF (portable document format)
Images or objects within a PDF might be compressed using lossy techniques,
even while the overall structure supports lossless).

archives

e

ZIP

*

PNG (portable network graphics)

*
*

|PEG (Joint Photographic Experts Group)
)
MP3(MPEG-1 Audio Layer Ill)

Run-length

*

Faxcompression

Fax images,

encoding (RLE)

|«

Text compression

text files

»

|PEG

.

MP3

Lossless

Lossy

Tran_s.form

coding

*

MPEG (Moving Picture Experts Group)

The choice between RLE and transform coding depends on the specific type of
data and the desired compression ratio. For data with simple repetitive patterns,
RLE offers a straightforward and efficient approach. For data with complex
patterns and higher compression requirements, transform coding provides a
more powerful and versatile solution.

A1.1.9 Describe different types of services in
cloud computing
The term “cloud” refers to cloud computing, a paradigm which allows organizations
to access and utilize computing resources (such as servers, storage, databases)

over the internet to offer flexible resources. The cloud is not a physical entity but a
network of remote servers in data centres around the globe. Organizations can save
money by only paying for the computational resources they use, rather than paying
for an expensive server which they might not use at full capacity all the time.
The three main cloud service models are software as a service (Saa$S), platform

as a service (PaaS), and infrastructure as a service (laaS). Each model provides
a different level of control and flexibility over IT infrastructure and software,
influencing resource availability and management. The choice between these
models depends on the specific needs and capabilities of the organization.

Images, audio,

.
images

Ir_nages, audio,

videos

Al Computer fundamentals

A Figure 32 How people imagine the cloud

A Figure 33 What the cloud really looks like

Software as a service (SaaS)
SaaS is a cloud computing model where software applications are hosted
and managed by a third-party provider and accessed by organizations through
a web browser or mobile app. Saa$S eliminates the need for organizations to
install and maintain software on their own devices, making it convenient
and
cost-effective.

Key characteristics of SaaS
All-inclusive: Organizations have access to the entire application suite, including
updates and maintenance, without any upfront costs or ongoing maintenance.
Scalability: Saa$S applications can be easily scaled up or down to meet changing
organizational needs, ensuring optimal performance and resource utilization.
Accessibility: SaaS applications are accessible from anywhere with an internet
connection, providing organizations with flexibility and mobility.
Security: SaaS providers implement robust security measures to protect sensitive
organizational data and ensure the integrity of the applications.

Examples of SaaS applications
Salesforce: This is a classic example ofa Saa$S application. It provides a core
CRM (customer relationship management) platform delivered entirely over the
web, with subscriptions managed by Salesforce.
SurveyMonkey: SurveyMonkey is an online survey development cloud-based
company. It provides a tool that allows users to create and distribute surveys,
collect responses, and analyse data, all through a web interface. There is no need
to install any software—it is a perfect example ofa pure Saa$ application.
Canva: Canva is a graphic design platform that allows users to create social
media graphics, presentations, posters, documents, and other visual content. It
is accessible entirely through a web browser, offering design tools and templates
without the need for any desktop software. It epitomizes the pure SaaS model.

Hybrid SaaS examples
Gmail/Google Apps: While core components of Google Apps (Gmail, Docs
and Sheets) are Saa$S, Google also offers downloadable components.

Al.l Computer hardware and operation

Zoom, Microsoft Teams and Skype: These all have web-based platforms,
which could be considered SaaS. However, they also offer installable desktop
applications. It is more accurate to say they offer a SaaS component alongside
traditional software installation.
Microsoft Office 365: This blends Saa$ and traditional software models. Core
components such as Word Online or Excel Online are pure SaaS. However, Office
365 subscriptions include downloadable desktop versions of the full software suite.
Moodle: An open-source learning management system. Most organizations
self-host their solution, installing and managing it on their own web servers or
through a hosting provider. This traditional model does not fit the strict definition
of SaaS, where the software is hosted by the service provider and accessed
over the internet without the need for local installation. However, there is a SaaS

option called MoodleCloud. This offers Moodle's capabilities as a hosted online
service, allowing users to use Moodle's features without needing to install, host
or maintain the software themselves.

Platform as a service (Paa$S)
PaaS provides a cloud-based environment for developers to build, deploy, and
manage their applications. It offers a pre-built infrastructure including operating
systems, databases, middleware, networking, and developer tools. This frees

developers from managing the underlying infrastructure and allows them to focus
on coding.

Key characteristics of PaaS
DevOps-friendly: PaaS supports rapid development and deployment cycles.
DevOps is a set of practices which combines software engineering (Dev) and
information technology (Ops).
Infrastructure abstraction: PaaS simplifies application management by
handling OS updates, database administration, and networking configuration.
Reduced operational costs: PaaS eliminates the need to purchase and maintain
hardware and software.

Examples of Paa$S platforms
*

Google App Engine

*

Amazon Elastic Beanstalk

e

Heroku

*

Red Hat OpenShift

¢

Microsoft Azure App Service

Imagine a student named Alex, who is passionate about creating a personalized
fitness application called FitTrack. Alex has great ideas for features such as
workout tracking, nutritional advice, and social challenges, but has limited

experience and resources for setting up and managing servers, databases, or
dealing with complex infrastructure issues.
Alex decides to use a PaaS solution. With PaaS, Alex does not need to worry

about installing operating systems, configuring databases, or managing network
settings. Instead, Alex can focus entirely on writing the code for FitTrack using
preferred programming languages and tools.

Al Computer fundamentals

The Paa$S environment provides all the backend services Alex needs. It
automatically handles scaling the application to accommodate more users
as FitTrack grows in popularity. It also takes care of security updates and
maintenance tasks without Alex having to dive into the details.

A Figure 34 An athlete using a fitness app

By using Paa$, Alex can bring FitTrack from idea to live application much faster
and with fewer hurdles, enabling a focus on innovation and user experience
rather than infrastructure management. This example demonstrates how PaaS
empowers developers with limited infrastructure knowledge or resources to build
and scale applications effectively.

Infrastructure as a service (laaS)
laa$S provides virtualized computing resources, such as servers, storage and
networking, over the internet. It gives businesses the flexibility to provision and
manage their own IT infrastructure without the need to invest in physical hardware
and software.
Virtualization refers to the process of creating a virtual version of something,
such as operating systems, servers, storage devices or network resources,
rather than a physical version. This technology involves using software to
simulate the functionality of hardware to create a virtual computing system,
enabling multiple virtual machines (VMs) to run on a single physical machine’s
hardware resources. Each VM operates independently and can run its own
operating systems and applications as if it were a separate physical device.
Virtualization allows for more efficient utilization of hardware, greater flexibility,
scalability, and isolation between virtual machines for improved security and
ease of management.

Key characteristics of laaS
Customization: |aaS allows businesses to tailor their [T infrastructure to their
specific needs and requirements.
Scalability: Resources can be easily provisioned and scaled up or down as
needed, ensuring optimal performance and cost efficiency.
Control: Businesses have full control over the configuration and management of
their laa$ infrastructure.

Examples of laaS providers
*

Amazon Web Services

*

|BMCloud

*

Microsoft Azure

*

QOracle Cloud Infrastructure

*

linode

*

Google Cloud Platform

Al.l Computer hardware and operation

SaaS provides a fully managed solution where the service provider
manages all aspects of the software, including the underlying
infrastructure, application code, and updates. Organizations simply
access the software through a web browser or mobile app. It is
ideal for services such as customer relationship management (CRM)
systems, email platforms, project management tools, and collaborative
workspaces.
With Saa$, organizations have no need to install, configure or maintain
the software, reducing need for technical support. It eliminates the
need for upfront software purchases or ongoing maintenance costs,
making it a cost-effective option for organizations of all sizes. SaaS
providers can quickly scale up or down the number of users and
resources to meet changing demand, ensuring optimal performance
and cost efficiency.
Paa$ provides a pre-built development environment where developers
can build, deploy and manage
their applications without worrying
about the underlying infrastructure. It is suited for developing web
applications, mobile apps, APls, and microservices.
PaaS provides a pre-integrated set of tools, frameworks and
middleware that are managed by the service provider, simplifying the
development process. Developers do not need to invest in their own
infrastructure, saving them time and money.
laaS provides virtualized computing resources, such as servers,
storage and networking, that businesses can provision and manage
on-demand. It is suited for high-performance computing, big data
analytics, seasonal or bursting workloads, and web hosting (allowing
organizations to host websites and applications entirely on laaS
infrastructure).
With laaS, organizations control the configuration and management
of their laa$ infrastructure, optimizing performance and tailoring the
environment to their specific needs.
They can scale resources up or down as needed, ensuring optimal
performance and cost efficiency, and tailor their IT infrastructure to their
unique requirements, including specific hardware specifications and
software configurations.

TOK
When you think of your own
computer, you may think your data,
your applications and your memoary
are all stored on the machine on
your desk. However, as the cloud
has grown and evolved, thisis

not always true. Organizations
asked a simple question: why do
they need to pay for computing
resources that they are not using?
With subscription options, as with
utilities such as water or electricity,
they can pay only for the computing
resources they use.
How does the paradigm of cloud
computing challenge traditional
notions of resource allocation and
cost efficiency in organizations?
What implications does this have for
our understanding of technology
infrastructure and its scalability?

Al Computer fundamentals

Choosing the right cloud service model
The choice between SaaS, Paa$ and laaS depends on the specific needs and
capabilities of the organization. Here is a summary of the key considerations.
Table 7 SaaS, PaaS and laaS comparison
Feature

SaaS

Paa$S

laaS

Control

Lowest

Medium

Highest

Flexibility

Lowest

Medium

Highest

Resource
management

Service provider | Service provider | Customer
manages
manages most
manages most
.
everything
resources
resources

Cost

Most cost.
effective

)
Medium cost

)
Most expensive

Suitability

.
Basic
applications
bp
‘
general user
access

Custom
applications
!
rapid
development

Custom
applications,
specialized
hardware
)

requirements

In general, Saa$S is a good choice for organizations that need simple, easy-touse applications and are willing to pay for the convenience. PaaS is suitable
for organizations that want more control over their applications but still value
rapid development and reduced maintenance costs. laaS is the best choice for
organizations that have complex IT requirements, need full control over their
infrastructure, and are willing to manage their own resources.
Cloud computing allows organizations to provide the optimal balance of control,
flexibility and cost-effectiveness.

Al.l Computer hardware and operation

Practice questions
1.

Describe two applications of GPUs other than graphics rendering.

[3 marks]

2.

Describe how GPUs contribute to enhancing video game experiences.

[3 marks]

3.

Discuss how the design philosophy of CPUs and GPUs reflect their roles in computing systems.

[5 marks]

4.

Describe the significance of energy efficiency in the design of CPUs and GPUs.

[3 marks]

5.

Evaluate the effectiveness of the collaborative work between CPUs and GPUs in a

6.
7.

9.

computing system.

[6 marks]

Describe the roles and characteristics of registers and cache memory within a
computer system.

[4 marks]

a.

[2 marks]

Outline the role of ROM in a computer system.

b. Compare ROM with volatile memory types, referring to data preservation and access during
power cycles.

[3 marks]

Describe the primary functions of the data bus during the execute phase.

[3 marks]

Describe how the control bus facilitates the interaction between the CPU and memory
during a read operation from memory.

[3 marks]

10. Evaluate the impact of bus architecture (address, data and control) on the performance

of CPU operations.

[4 marks]

11. Describe the basic principle of pipelining as used in multi-core architectures.

[4 marks]

12. Describe how pipelining can improve the throughput ofa multi-core processor.

[3 marks]

13. Describe the potential challenges of implementing pipelining in multi-core architectures.

[3 marks]

14. Evaluate the effectiveness of pipelining in a scenario where a multi-core processor is used
for a highly parallel task.

[6 marks]

15. Explain how data is stored and accessed on an optical disc.

[6 marks]

16. Describe the advantages of using NAS in a multi-device environment.

[3 marks]

17. Describe the differences between internal HDDs and eMMCs in terms

of performance and use.

[3 marks]

18. Evaluate the use of external SSDs for data backup compared to using flash drives.

[5 marks]

19. Evaluate the impact of the physical limitations of NAND flash memory on the
performance and longevity of storage devices like SSDs and eMMCs.

[5 marks]

'\ WA

Data representation and
computer logic
Syllabus understandings
A1.2.1 Describe the principal methods of representing data
A1.2.2 Explain how binary is used to store data
A1.2.3 Describe
the purpose and use of logic gates
Al1.2.4 Construct and analyse truth tables
A1.2.5 Construct logic diagrams
In this subtopic, you will learn about principal methods of representing data.
Representing data in a computing system involves encoding information in a
structured format, such as binary, that can be processed and stored by digital
devices.

A Figure 35 How are images, sound and
video represented in binary?

This subtopic will also cover binary, hexadecimal, and character encodings such
as ASClland UTF-8, each tailored to specific applications, from data storage in
binary
to text and numerical representations. You will explore how binary serves
as the cornerstone for data storage in computers. At its core, binary operates
on a base-2 numeral system, representing the simplest form of data encoding.
This system represents every data type, from basic numerals to rich multimedia,
as sequences of Os and 1s. These binary states often correlate with physical
conditions such as on or off (electrical charge presence), north or south (magnetic
orientation for storage), or low or high (voltage levels).
Next, you will learn about constructing and analysing truth tables. Truth tables
are used to describe the functionality of logic gates and circuits, showing every
possible input combination and the resulting output. They are important for
understanding and predicting the behaviour of digital systems.
Finally, you will learn about constructing logic diagrams. Logic diagrams visually
represent the relationships of logic gates within a circuit. They are essential for
designing, analysing and understanding how digital systems operate, facilitating
the conceptualization and implementation of digital logic solutions.

A1.2.1 Describe the principal methods of
representing data
The representation of integers in binary
Binary is a base-2 number system, using only two digits, O and 1, to represent all
integers. Binary numbers may be shown by a subscript 2, for example, 1011101.,.
The subscript helps to clarify which number system is being used. 11, 11,,
and 11

. are all different numbers. The first number is base-10, the second is

base-2 and the third is base-16.

Al.2 Datarepresentation and computer logic

In binary, each digit in a binary number is called a bit (short for binary digit). Each
bit position has a corresponding power of 2, starting from 2° at the rightmost
bit and increasing to the left. The first bit represents 2°, the next bit represents
2!, then 22, 23, 24,25 26,27, 28 and so on. Bits are almost always organized into
groups of 8 known as a byte. A group of
4 bits is known as a nibble.
Table 8 Key terms for data representation
Term

Definition

Decimal/Dena
/
M

A base-10 numbering system that uses ten digits, O through 9. Itis the standard system for denoting
.
)
integer and non-integer numbers.

Binary

A base-2 numbering system that uses two digits,

Hexadecimal
exadecma

Oand 1. Each digit is called a bit.

A base-16 numbering system that uses sixteen digits, numbers O to 9 and letters A to F representing
numbers 10 to 16. Each digit (number or letter) is called a nibble because it represents four bits.

Bit

The smallest unit of data in computing, representing a single binary digit (0 or 1).

Byte

A unit of digital information that consists of8 bits. It is the standard chunk size for most computer
architectures and represents a single character of data.

Nibble

A unit of digital information that consists of4 bits, or half ofa byte. It can be represented as a single
hexadecimal digit.

Place value

The value ofa digitin a number, determined by its position within the number. For example, in the
decimal number 345, the place value of4 is 40 because itis in the tens place.

+

The addition operator

-

The subtraction operator

/

The division operator

*

The multiplication operator

%
7

The modulo operator (modulo refers to an operation that finds the remainder after division of one
number by another)

i

The exponent operator

It can be helpful to read binary numbers from right to left, and to set out the
number in a place value table.
Binary is the most compact representation for computers, as it directly aligns
with their hardware, which uses transistors operating in two states.

Sublopic Al 1 disausses Hiow data
is represented in binary.

Convert from binary to decimal
1.

ldentify the place values. Each bit in a binary number represents a power of
2, starting from 2° at the rightmost bit and increasing to the left. This table is
useful when working with binary.
Bit
Place value

27

26

25

24

23

22

2!

20

Decimal value | 128

64

32

16

8

4

2

1

Al Computer fundamentals

TOK
Everything in a computing system
is eventually reduced to binary.
Binary was initially used for early

2.

Multiply each bit by its place value. For each 1 in the binary number, multiply
it by the corresponding power of 2.

3.

Add the products: Add up the results of all the multiplications to get the
decimal value. For example, converting 1011 in binary
to decimal looks like
the following.

computing systems because it was

Bit

easy to implement, is reliable and
expresses logic well.

Place value

27

26

25

24

Decimal value

How does the use of the binary

1

0

1

1

23

2?2

2!

2°

8

0

2

1

1%2340%22+1%2141%20=8
+ 0 + 2 + 1=1I

system in computing shape our

understanding of numerical
representation and data processing?
What implications does this have
for the broader field of digital
technology and its applications?

Note that, in computing, the asterisk (*) is used instead of the multiplication

symbol ().

Worked example 8
1.

State the decimal number represented by each of these binary numbers.
a.

101

b.

1001

2. Write 11001, as a decimal number.

Solution
1.

a.

Tochangeanumberfrom binaryto decimal, work out
the decimal value of each digit of the binary number.

b.

Draw a place value table. Write in the bits and fill
in the rest of the table.

Draw a place value table. Write the bits first, then
the equivalent binary place values.

Bit
Place

Bits

1

0

1

1

value

Place value

2°

22

2!

2°

Working | 1*23 [ 0*22 [ O*2" | T*2°

_
_
_
Flna_l ly, add the working to convert each bitto a
decimal number.
:

*

73

*

72

*

71

*

Working

]: g

O: 3

]: 22

]: ]2

Decimal

3

0

5

]

1
23

0
22

=8
3

Decimal

0
2

=0
0

1
20

=0
0

=1
1

value
0

value

Find the sum of the decimal values:

8+0+0+1=09.

So, binary 1001 is decimal 9.
2.

Draw a place value table. Fill in the working and

equivalent decimal values.
Find the sum of these individual decimal values: 8

+0+2+1=11.

So, 1011 in binary is the same as 11 in decimal.

Bit

1

1

0

0

1

Place value

24

23

2?2

2

20

Working
Decimal
value

1*24 | 1*%22|10*22|0*21 | 1*20
=16 | =8
=0
=0
=1
16

8

0

0

1

Find the sum of the decimal values: 16 + 8 + 0+ 0+ 1

=25.
So, 11001, is decimal 25.

Al.2 Datarepresentation and computer logic

State the decimal number represented by the binary number 10011010.
1.

Write these decimal numbers

Solution

as binary numbers.

Write the number in a place value table. Complete the table.

a.

12

Bit

1

0

0

1

1

0

1

0

b.

28

Place value | 2’

26

25

24

23

22

2!

20

c

71

1*21

|0*2°

2

0

Working

1*#27[0*26|0*2° | 1*24|1%2310*%22|

Decimal

128

0

0

16

8

0

value

2.

Find all the unique 4-bit
(4-digit) binary numbers.

How many are there? What are

Find the sum of the decimal values:

0+ 2+ 0+ 8+ 16 +

0+ 0 + 128 = 154.

their decimal equivalents?

So binary 10011010 is decimal 154.

Convert from decimal to binary
1.

Divide the decimal number by 2. Repeat as many times as necessary to get
to the end of the number. Keep track of the remainders (0 or 1). Note that, in

computing, the solidus symbol (/) is used instead of the division symbol (+).
2.

Write the remainders in reverse order: these form the digits of the binary number.

Binary is usually represented in 8 bits, known as a byte. When a base-10
(decimal) number is stored in an 8-bit register, it must first be converted to base2 (binary). When converting decimal to binary for this purpose, ensure you use
all 8 places in the register. Remember to work from right to left, from smallest
value to largest. Fill any places that do not have a digit with a zero. For example,
4]0(decimal 4)is 100 in binary. However, 4,,inan 8-bit register would look like

this: 00000100.

Worked example 10
1.

Convert each decimal number to binary.
a.

2.

13

b.

45

State the binary number that represents decimal 97.
How do these decimal numbers appear in an 8-bit register?
a.

207

b.

34

Solution
1.

a.

Divide the decimal number by 2, keeping track of

Divide your answer to the

the remainders.

second division (3) by 2.

13/2=6R

Write the remainder. The

(remainder) T

binary number starts with

6/2=3R0O

3/2=1R1
1

Write the third remainderin
front of the second.

Divide your answer to the first

The binary number is now

division (6) by 2.
Write the second remainder

Divide your answer to the
third division (1) by 2.

ie
T
The binary numberis now

1/2=0R1
01

101

Write the fourth remainder in
front of the third.

The binary number
is now:

1101

e

Al Computer fundamentals

3. a.

When the answer to the division is O, the remainder is

the final digit in your binary number.

207 / 2=103 R1 Write the binary

So, decimal 13is 1101 in binary.
b.

Convert the number to binary in the same way,
by repeatedly dividing by 2.
number, working right
to left.

Divide 45 by two until you get an answer of zero.
Write down the remainder at each step.
103/2=51R1

45 /2 =22R1 The first (smallest) binary
digitis 1.

1

22/2=11R0O The second binary digit is
0.
Write this in front of 1 from
the previous step.

0l

M /2=5R1

The third binary digitis 1.

101

5/2=2R1

The fourth binary digitis 1.

1101

2/2=1R0

Thefifth digitisO.

01101

1/2=0R1

The sixth (highest) digitis1.

101101

The answer to the division is zero, so thisis the final digit.

Write each remainder
in front
of the previous
one.

11

51/2=25R]1

111

25/2=12R1

1111

12/2=6R0O

01111

6/2=3R0O

001111

3/2=1R1

1001111

1/2=0R1

The 8-bit number is
complete.

11001111

So, 207, appears as 11001111 in an 8-bit register.
b.

So, decimal 45 is 101101 in binary.

1

Convert the number to binary in the same way,
by repeatedly dividing by 2.

Divide 97 by two until you get an answer of zero. Write
down the remainder at each step.

34/2=17R0

97/2=48R1 The first (smallest) binary
digitis 1.

17/2=8R1

10

8/2=4R0

010

4/2=2R0

0010

2/0=1RO

00010

1/2=0R1

100010

1

48 /2=24R0 The second binary digit
is 0.

01

24 /2=12R0 The third binary digit is
0.

001

12/2=6R0

The fourth binary digit
isO.

0001

6/2=3R0O

Thefifth binarydigitis0.

00001

3/2=1R1

The sixth binary digitis1.

100001

1/2=0R1

The seventh (and last)
binary digitis 1.

Write the remainders,
from right
to left.

0

The binary conversion is complete, but there are
fewer than 8 bits. Fill in the empty spaces at the front
(the large end) of the number with zeros.
So, 34,,appears as 00100010 in an 8-bit register.

1100001

Binary number 1100001 is decimal 97.

Ay
1.

State the decimal of:
a.

11000111

The representation of integers in hexadecimal
Hexadecimal is a base-16 number system. Hexadecimal uses 16 digits—0, 1, 2,
3,4,5,6,7,8,9 A, B, C,D, E, F—torepresentintegers. A subscript 16 may be
used to show numbers are written in hexadecimal, for example, C47B9,
..

b. 11111111
c. 10101111
2.

State the 8-bit binary of:
a.

/9

b. 203
c. 241

Hexadecimal is more human-readable than binary, especially for longer numbers,
as it uses fewer digits to represent the same value. Both binary and hexadecimal
are efficient for computer processing and storage. Each hexadecimal digit, called
a nibble, directly corresponds to 4 bits in binary, making conversion between
them straightforward.

Al.2 Datarepresentation and computer logic

As with binary, using a table can be a helpful for remembering which place holds
which value.

| Placevalue | 167 | 16° | 16° | 16* | 16 | 16 | 16 | 16° |

Table 9 Hexadecimal numbers and
their equivalents in binary and decimal
Hexadecimal | Binary | Decimal

It can be helpful to read hexadecimal numbers from right to left.

Convert from hexadecimal to decimal
1.

Identify the place values. Each digit (bit) in a hexadecimal number represents
a power of 16, starting from 16° at the rightmost digit and increasing to the
left. This table is useful when working with hexadecimal.
Nibble
Place value

168 | 167 | 165 | 16° | 16* | 16% | 162 | 16" | 16°

Convert letters to decimal equivalents. If the hexadecimal number contains
letters (A-F), convert them to their corresponding decimal values (A =10, B =
11,C=12,D=13,E=14,F=15).
Multiply each digit by its place value. For each digit in the hexadecimal
number, multiply it by the corresponding power of 16.
Add the products. Add up the products of all the multiplications to get the
decimal value.

0

0000

0

1

0001

2

0010

2

3

0011

3

4

0100

4

5

0101

5

6

0110

6

7

0111

7

8

1000

8

9

1001

9

A

1010

10

B

1011

1

C

1100

12

D

1101

13

E

1110

14

F

1111

15

Worked example 11
Write each hexadecimal number as a decimal number.

2A
2.

b.

1B4

c.

1M

Change FFF,; to a decimal number.

Solution
As you did when converting binary numbers, draw a place value table with four columns. Put the hexadecimal
bits (digits) in the first row, working right to left. If there are fewer than 4 bits, fill in the spaces with zeros. Add the
equivalent hexadecimal place values underneath.

Nibble

0

0

2

A

Place value

16*

162

16'

16°

Add the working to convert each hexadecimal bit to a decimal number.
Working
Decimal value

0*16°=
0*4096=0
Q0

0*162=
2*16'=
A*16°=
|0*256=0 | 2*16=16 | 10*1=10
0

32

10

Now, find the sum of the individual decimal values: 0 +0 + 32 +10=42.

So, hexadecimal 2A is decimal 42.

Al Computer fundamentals

e

b.

Draw and complete a place value table.

Nibble

0

1

B

4

Place value

163

162

16!

16°

Working

0*16%=
0*409 =0

1*16%=
|[1*256=1

0

256

Decimal value

A*le'=
4*16°=
|11*16=160 | 4*1=4
176

4

Find the sum of the decimal values: 0 + 256 + 176 + 4 = 436.
So, hexadecimal 1A4 is decimal 436.

c.

Draw and complete a place value table.
Nibble

0

1

1

1

Place value

163

162

16

16°

Working

0*16%=
1*162=
0*4096=0(1*256=256|

Decimal value

0

1*16'=
1*16°=
1*16=16|
1*1=1

256

Add the decimal values: 0 + 256 + 16 +

16

1

1= 2/3.

So, hexadecimal 111 is decimal 273.

2.

The subscript 16 shows that this is a hexadecimal number. Draw and complete a place value table.

Nibble

0

F

F

F

Place value

163

162

16

16°

Working

0*16*=
F*16%2=
F*16'=
F*16°=
0*4096=0|15*256=3840|15*16=240| 15*1=15

Decimal value

0

3840

240

15

Add the decimal values: O + 3840 + 240 + 15 = 4095.

So, FFF,is4095,.

_
1.

Convert from decimal (integers) to hexadecimal
1.

Divide the decimal number by 16. Repeat as many times as necessary to get
to the end of the number. Keep track of the remainders (0 to 15).

2.

Convert remainders to hexadecimal digits. Remainders from O to 9 stay the
same. Convert remainders greater than 9 to their hexadecimal equivalents

State the base-10 of:
a. C7
b. FF

'

(A,B,C,D,EF).
3.

2.

State the hexadecimal of:
a. 420
b. 900
c.

256

Write the remainders, in their hexadecimal form, in reverse order. This forms

the hexadecimal number.

Al.2 Datarepresentation and computer logic

Worked example 12
1.

Change each decimal toa hexadecimal number.
a.

2.

b.

26

398

Write 204010 as a hexadecimal number.

Solution
1.

a.

Divide 26 by 16 until you get
an answer
of O.
Write down the remainders.

26 /16=1R10

24/16=1R8

Convert the remainderto
hexadecimal: 10 becomes A.

Write the second remainder
in front of the first.

The hexadecimal number

starts with
1/16=0R1

The hexadecimal number is

A

now

Look
at the remainder:

1/16=0R]1

1is

8E

the same
in decimal and

decimal Tisalso 1in

hexadecimal.

hexadecimal.
Write the second remainder

Write the third remainder in
front of the second.

in front of the first.

The hexadecimal number is

The hexadecimal number is
now

NOW.
1A

So, decimal 26 is written as 1A in hexadecimal.

b.

8 is the same in decimal and
hoedEamEL

18E

Decimal 398 is written as 18E in hexadecimal.

Divide 398 by 16 until you get an answer of
O.

2.

Divide 2040 by 16 until you get an answer of 0. Write
down the remainders.

Write down the remainders.

2040/16=127R8 Write 8 and divide 127

398 /16 = 24 R14 Convert the remainder
to

by 16.

hexadecimal: 14 becomes E.

127/16=7R15

The hexadecimal number

starts with

Write 15 in hexadecimal,
in front of 8.

E

7/16=0R7

Write
7 in front of F.

So, 2040, is the same as /F8,
..

Convert integers from binary to hexadecimal
1.

Group binary digits into nibbles. Divide the binary number into groups of4
bits, starting from the rightmost bit. Each group of
4 bits represents a single
hexadecimal digit.
Convert each nibble to its hexadecimal equivalent. Use Table 9 to match
each 4-bit binary group to its corresponding hexadecimal digit (0-9, A-F).
Combine hexadecimal digits: Read the hexadecimal digits in order from left
to right to get the final hexadecimal representation.

Worked example 13
1.

Convert each binary number to hexadecimal.
a.

2.

11010110

b.

11101011

What is the hexadecimal equivalent of 1001110,7?

8
F8

7F8

Al Computer fundamentals

©

Solution
1.

a.

Breakthe binary numberinto nibbles (groups of4
digits), working from right to left.
Convert each nibble into its hexadecimal
equivalent. Use a conversion table to help you.
1 | 1 ‘ 0 ‘
D

110 l 1 | 1 | 0
6

117

oli1lololn

E
)
So, binary 11101001 is E9 in hexadecimal.
2.

So, binary 11010110 is D6 in hexadecimal.
b.

1

Breakthe numberinto nibbles, working from right
to left. There are only seven digits in this number, so
add an extra O in front to complete the second nibble.
Write the hexadecimal equivalent for each nibble.

Break the number into nibbles, working from

([T

10O

O[T

right to left.

4

Write the hexadecimal equivalent for each nibble.

|O|T]1
B

So, 1001110, is the same as 4B,
.

Convert integers from hexadecimal to binary
1.

Convert each hexadecimal nibble to its 4-bit binary equivalent. Use a
conversion table to find the 4-bit binary representation for each hexadecimal
digitin the number.

2.

Combine binary representations. Join the binary representations of all digits
in order to get the final binary string.

Worked example 14
1.

Convert each hexadecimal number to binary.

a.
2.

D56,

b. 1A4,

State the binary equivalent of CFO,
.

Solution
1.

a.

Converteach hexadecimal nibble into its binary
equivalent.
.
.
.
Use a conversion table if you wish.
-

gnarybit

[1]1]0]1]o]1]o[1]o[1]1]0

So, the binary representation of D56 is
110101010110.
b.

Convert each hexadecimal nibble into 4-bit binary.
Ifyou don't use a table, keep each nibble separate.
Headecmal:
1
A
4

1.

4-bit binary:
Write the binary

1010

0100

representation without spaces.

yrep
P
So, the binary representation of 1A4_is

2.

Convert each hexadecimal nibble into 4-bit binary.
Hexadecimal:

C

i

0

4-bit binary:

1100

1111

0000

Binary representation: 110011110000
So, the binary representation of CFO, is
110011110000.

State the hexadecimal of:

a. 11110010
2.

0001

b. 00010001

c. 11011110.

b. 4(:15

C.

State the 8-bit binary of:
a.

ES16

9915

Al.2 Datarepresentation and computer logic

A1.2.2 Explain how binary is used
to store data
How data—integers, strings, characters, images, audio

and video—are stored in binary form
Integers
An integer is a type of numerical data that represents a whole number without
any fractional or decimal component.
Integers are represented in computers as fixed-width binary numbers, allowing for
the representation of both positive and negative whole numbers. A fixed-width
binary representation refers to the practice of allocating a constant number of bits
to represent each data item within a computer system. This approach ensures
every piece of data, regardless of its actual value, occupies the same amount of
space in memory.
The primary encoding mechanism for integers include the following.
*

The unsigned integer representation, which utilizes the entirety of the
bit space to denote the magnitude ofa number, with the maximum value
determined by 2"-1 where n is the number of bits. Unsigned integers only
represent non-negative values.

*

Two’'s complement representation for signed integers: This method
allows for the representation of negative numbers by designating the most
significant bit as the sign bit (O for positive, 1 for negative) and inversely
flipping the bits of the absolute value before adding one, to represent
negative values efficiently.

A 4-bit unsigned integer uses all four bits to represent positive numbers and
zero. Here, the maximum value is 1111 in binary, which is 15 in decimal. For
example, the binary number 1010 as an unsigned 4-bit integer represents the
decimal value 10.
A 4-bit two's complement integer uses the most significant bit (leftmost bit)
as the sign bit. If the sign bitis O, the number is positive or zero. Ifthe sign bitis 1,
the number is negative. They can represent values from -8 to 7.
For example, the binary number 1000 as a two's complement 4-bit integer
represents the decimal value 8. The first 1 indicates that this is a negative
number, and 000 is the binary form of 8 in a two's complement system, which
is calculated by inverting all bits of the absolute minimum value (0111 for 7) and
adding one.

Strings and characters
Characters and strings are encoded using character encoding standards that map
characters to binary values.
ASCIl (American Standard Code for Information Interchange) employs a 7-bit
binary code to represent 128 unique characters, enabling the encoding of
English letters, digits, and punctuation.
Unicode provides a comprehensive system to represent characters from all
writing systems through variable-width encodings (such as UTF-8, UTF-16).

TOK
The decomposition of music,

images and video almost always
involves a reduction of the original
waork. Viewing original video or an
image can be so computationally
expensive that it is impractical.
To what extent does the reduction
of diverse data types—such as
integers, strings, characters,

images, audio and video—into
binary form inhibit our broader
understanding of data and its
inherent complexities in digital
technology?

Al Computer fundamentals

UTF-8 uses one to four bytes for each character, ensuring global text
representation and compatibility.
Pixels The tiny dots that make up
images. Each pixel carries colour
information. The resolution of an
image—the detail an image holds—
is directly related to the number of
pixels it contains.

For example, the character ‘A’ is represented as 01000001 in ASCIl and the same
in UTF-8, whereas a character like ‘&’ (a Japanese hiragana character) cannot
be represented in ASCII and requires more than a single byte in UTF-8, so is
represented as 11100011 710000001 T0000010.

Images
One of the most common methods of representing colour in digital images is
through the RGB colour model, where colours are represented as a combination
of red, green, and blue light. Each colour channel is typically represented by
one byte (8 bits), allowing for 256 intensity levels (0-255). Thus, a single pixel’s
colour in a true-colour image can be represented by a 24-bit number, made up of
8 bits for each colour channel.
In binary form, each pixel’s colour is encoded as a sequence of bits. For a 24-bit
image, each pixel would be represented by a binary sequence divided into three
parts, each corresponding to one of the RGB components. For example, a bright
red pixel might be represented as 11111111 00000000 00000000, where the red
channelis at its maximum intensity, and the green and blue channels are off.
Fora simple example, consider storing a very small image of2 X 2 pixels where
each pixel is encoded in 24-bit RGB, as shown in Figure 36:
Top-left pixel is red: 11111111 00000000 00000000
Top-right pixel is green: 00000000 11111111 00000000
Bottom-left pixel is blue: 00000000 00000000 11111111

A Figure 36 A2 x 2 pixel image

Bottom-right pixel is white (all colours at full intensity): 11111117 11111111 11111111
These binary sequences directly represent the colour of each pixel. Ina BMP
(bitmap) file format, they are stored directly as such, possibly preceded by a file
header specifying the image’s dimensions and colour depth. In contrast, formats
like |PEG first process and compress this information before storing it in binary form.
Audio

Hertz (Hz) The unit of frequency,

:

equivalent to one event per second.
A sampling rate of 48 kHz means
48,000 samples per second.

A Figure 37 Ananalogue sound wave.
To sample this, you measure the amplitude
44 thousand times a second (if you are using
44.1 kHz sampling)

To store audio in binary form, analogue sound waves must be converted
into a digital representation that can be processed, stored, and played back
by electronic devices. This digital representation involves several key steps
and concepts, including sampling, quantization, and possibly compression,
depending on the chosen audio format and quality.
Sampling is the process of measuring the amplitude (volume) of a sound wave at
regular intervals to create a series of discrete data points. The rate at which these
measurements are taken is known as the sampling rate, measured in hertz (Hz),
which indicates the number of samples taken per second. Common sampling
rates include 44.1 kHz (used in CDs), 48 kHz (common in professional audio), and
96 kHz (high-resolution audio). A higher sampling rate captures more detail of
the sound wave but requires more data.
Quantization is the process of mapping the amplitude of each sampled point to
a nearest value within a finite set of possible values. This step effectively converts
the continuous amplitude of the sound wave into a digital format. The bit depth

Al.2 Datarepresentation and computer logic

determines the number of possible values for the amplitude of each sample,
directly influencing the precision of the sound’s digital representation. Common
bit depths include 16-bit (65,536 possible values) and 24-bit (16,777,216
values), with professional audio using higher values. Higher bit depth allows for
a more precise representation of the sound wave’s amplitude, resulting in higher
fidelity audio.
Each quantized sample is then encoded as a binary number, with the bit depth
determining the length of this number. For example, in a 16-bit audio file, each
sample is represented bya 16-bit binary number. In stereo audio, two separate
channels (left and right) are recorded and stored, effectively doubling the amount

High Resolution

22 bits

16 hits

of data compared to mono (single-channel) audio. Multi-channel audio, such as

5.1 surround sound, involves more channels and more data.
& bits

For example, consider a simple sine wave captured at a sampling rate of 44.1 kHz
and a bit depth of 16 bits. At each sample point, the amplitude of the wave is
measured and mapped to the nearest value within the range provided by the
16-bit depth. If the wave's amplitude at the first sample point corresponds to half
of the maximum possible amplitude for positive values, it would be quantized
and represented as the binary number OTTTTTTTTT111111 (in a signed binary
format, where the first bit indicates the sign).
Video
Video is a sequence ofstillimages (frames) presented at a rate that gives the
impression of continuous motion. Each frame operates as a bitmap image, where
the pixels are encoded in binary. For instance, within a 24-bit colour depth
framework, every pixel is encoded using three bytes (24 bits), which delineate
the intensity levels of the red, green and blue components.

MM%@"*"*\?
1

2

3

1

L]

L]

w

n

n

A Figure 39 12 frames ofa cat jumping

In addition to visual data, video files comprise an audio track, which undergoes a
process of sampling, quantization and binary encoding, as with standalone audio
files. The binary representations of audio and video are combined (multiplexed)
to ensure that the auditory and visual elements of the video are synchronized
during playback. This multiplexing process interleaves the audio and video data
in a manner that maintains their temporal alignment, enabling simultaneous and
coherent audio-visual playback.
The encoding of video into a binary format involves representing each frame’s
visual information as a sequence of bits. This binary representation facilitates the
storage, processing and transmission of video data by digital systems. For the
actual display of the video, various video coding formats, such as H.264 (AVC) or
H.265 (HEVC), are utilized. These formats provide the necessary instructions for

decoding the binary data back into a sequence of images that, when played at
the appropriate speed, recreate the original video content.

A Figure 38 A sampled sound wave at
different bits

Al Computer fundamentals

Considera 10-second video clip recorded at 30 frames per second (fps) and a
resolution of 1920 by 1080 pixels (Full HD), with 24-bit colour depth. Each frame

consists of 1920 x 1080 pixels = 2,073,600 pixels.
Each pixel is represented by 24 bits (or 3 bytes), so one frame is:
2,073,600 pixels X 3 bytes = 6,220,800 bytes (about 6.2 MB).
For a 10-second clip at 30 fps, the total size is:
6.2 MB/frame x 30 frames/second X 10 seconds = 1,860 MB (about 1.86 GB).

The fundamentals of binary encoding and the impact on
data storage and retrieval
Binary encoding
The primary purpose ofa binary encoding scheme is to convert data from its
original form (which could be text, numbers, audio, video, and so on) into a

binary form thata computer can process, store, or transmit.
At its core, binary encoding involves representing data using bits. A single bit
can represent two states, often conceptualized as off/on, false/true, low/high,

A Figure 40 Binary

or 0/1. Eight bits form a byte, which is the basic unit of data storage. Larger data
units—such as kilobytes (KB), megabytes (MB), gigabytes (GB), and so on—are
multiples of bytes and are used to quantify digital data storage.
Table 10 Data units and their equivalents in bytes and bits
Unit

Equivalent in bytes

Equivalent in bits

1 biti

15(0.125)

1

1 nibble

1(0.5)

4

1byte
1
1KB (kilobyte) | 1,024
1MB
1,0242

8
8,192
10242* 8

(megabyte)

or 8,388,608

1GB
(gigabyte)

or1,048,576

1,024°
or1,073,741,824
1,0244
1TB (terabyte) | ") 199 511627776
1,0245
1PB(petabyte) | 1155 899.906,842.624

1,0243* 8
or 8,589,934,
592
1,0244* 8
or 8,796,093,022,208
1,0245* 8
| or9,007199,254,740,992

(After petabytes, there are exabytes, zettabytes, yottabytes, brontobytes and

geopbytes).
Different types of data require different binary encoding schemes. For instance,
text is commonly encoded using ASCIl or Unicode, where each characteris
assigned a unique binary value. For images, encoding schemes like |JPEG or PNG
translate pixel colour and intensity into binary. Audio and video data are encoded
into binary using formats that consider temporal changes and compression needs.

Al.2 Datarepresentation and computer logic

Data storage
Binary encoding allows for the efficient storage of data, with specific encoding
schemes optimized for types of data to minimize space without sacrificing
quality (for example, compression algorithms). The binary system scales well
with technological advancements in storage media, from magnetic tapes
to solid-state drives. Despite exponential growth in storage capacity, the
basic binary nature of these storage technologies has remained constant.
Finally, standardized binary encoding formats ensure that data can be stored,
retrieved, and understood across different systems and platforms, facilitating
interoperability and data exchange.

A Figure
41 Hard drive disk

Data retrieval
Binary encoding, coupled with the binary architecture of computer processors,
enables rapid data retrieval and processing. Computers are inherently designed
to work with binary data, which allows them to quickly perform operations on
encoded data.
The efficiency of searching and analysing stored data is significantly influenced by
how it is encoded. Indexing techniques and algorithms are optimized for binary
data, enabling quick searches through large data sets and complex analyses,
such as pattern recognition in machine learning models.
Finally, binary encoding schemes often incorporate mechanisms for error
detection and correction, which are important for reliable data retrieval. For
example, parity bits help identify errors that might occur during data storage or
transmission.

A1.2.3 Describe the purpose and use of
logic gates
Logic gates are electronic circuits that operate on one or more binary inputs to
produce a binary output, based on a specific logical function. Each type of logic
gate implements a Boolean operation such as AND, OR, NOT, NAND, NOR, XOR

and XNOR, corresponding to the fundamental operations in Boolean algebra.
The output of each gate reflects the result of its logical operation. Logic gates can
be constructed using transistors—semiconductor devices that act as electronic
switches. The arrangement of these transistors determines the type of logic gate
and its corresponding logical operation.

A Figure 42 An AND logic gate

The word “gate” in “logic gate” metaphorically signifies its function as a control
mechanism for the flow of information in digital circuits, similar to how a physical
gate controls the passage of entities through an opening. In the context of digital
electronics, a logic gate performs logical operations on one or more binary inputs
to produce a single binary output.
When working with logic gates, the number one (1) represents True, or on, while
the number zero (0) represents False, or off.

The purpose and use of logic gates
Logic gates perform simple logical operations, such as AND, OR and NOT. The
outputs of these gates depend on the input values and the type of gate, enabling
basic data processing functions.

A Figure 43 A gate controlling access

Al Computer fundamentals

For example, a fire alarm system may have multiple sensors for smoke, heat and
carbon monoxide monitoring connected to an OR gate. If any sensor triggers
(inputis 1), the output of the OR gate activates the alarm system. If there is smoke
OR heat OR carbon monoxide, then an alarm is sounded.

By combining different types of logic gates, more complex circuits can be
created. Logic gates are physical manifestations of Boolean algebra. Boolean
algebra is a branch of mathematics that deals with variables and operators, using
truth values (true or false) to perform logical operations.
Logic gates are used:
*

indigital displays to control the representation of numbers, characters and
symbols

*

incontrol systems, such as elevators or automated doors, helping to process
input signals (like buttons being pressed) to produce appropriate responses
(like opening a door)

*

intiming circuits, such as clocks and timers, determining the timing of various

*

incommunication systems, helping with the processing and transmission of
digital signals

operations

*

insafety systems, such as alarm systems, where they process inputs from
various sensors, to trigger alarms or other safety responses.

The function and applications of logic gates
in computer systems
Logic gates enable conditional logic in computer operations, allowing for
decision-making processes based on binary conditions. This is foundational for
implementing if-else and switch-case statements in programming languages.
Consider a simple security system that requires two conditions to be met before
access is granted: a correct keycode and a security badge scanned.
This can be modelled using AND logic, where both conditions must be true (1)

foraccess to be granted.

K (keycode) ——
AND

A (access)

B (badge) —

(D) Dark outside
(O) Occupied

D
AND } L I‘_lght
activates

(N) Do not w.

Consider a custom light control system where a light should be turned on either
if itis dark outside or if the room is currently occupied. There is an additional
condition that ifa “do not disturb” mode is active, the light should remain off
regardless of the other conditions.
This scenario can be modelled using OR logic for the first set of conditions and
AND logic along with NOT to consider the “do not disturb” condition.

disturb

A Figure 44 |ogic gates for asimple
security system as shown in the photograph
(top), and for a custom control system

The role of logic gates in binary computing

(bottom)

Logic gates are used to implement conditional statements in hardware, allowing
a computer to execute specific instructions based on whether certain conditions
are true or false. For example, an AND gate outputs a true signal only when all of
its inputs are true, which is like executing an "if all conditions are true” statement
in programming. By combining different logic gates, complex decision-making
processes can be built, enabling the execution of complex algorithms and
control flows within digital circuits.

Data processing and decision making

Al.2 Datarepresentation and computer logic

Arithmetic operations
In the ALU ofa computer’s CPU, logic gates are arranged into circuits capable
of performing arithmetic operations on binary numbers. For instance, adder
circuits, constructed from a combination of AND, OR and XOR gates, enable the
execution of addition, which can be extended to subtraction, multiplication and

division through algorithmic approaches.

Memory storage
Logic gates are integral to the design and function of memory devices. Flip-flops,
which are circuits made from logic gates, can store a bit of data by maintaining a
stable state until explicitly changed. This principle is scaled up to create registers,
RAM, and other storage devices, allowing binary data to be stored and retrieved
as needed.

Boolean operators: AND, OR, NOT, NAND, NOR, XOR,
XNOR
Truth tables provide a clear and systematic way to visualize the behaviour ofa
logical expression for all possible inputs. The table will have a column for each
input and each output, wherever they occur in the system. The ultimate output is
labelled Q.

Table 11 Boolean operators
Gate

Symbol

Function

What the gate asks | Truth table
Input
A

AND

A
B

Q

A

NOT

A

Q

Outputs 1 (true) only if all its
inputsare 1.

Are both inputs on?

Outputs 1if at least one of its
inputsis 1.

Is either input on?

Outputs the inverse of its
input: outputs 1ifthe input is
0, and vice versa. This gate is
also known as an inverter.

B

Output
Is A off?

Al Computer fundamentals

e Gate

Symbol

Function

A
NAND

}Q

What the gate asks | Truth table
Input

Output

Input

Qutput

Outputs 1 unless all its inputs
are 1 (the inverse ofthe AND | Is either input off?

gate).

A
BD Q

A
XOR

B

Outputs1 only if all its inputs
are O (the inverse of the OR
gate).

Outputs 1ifthe inputs are

Q

different: if one is 1 and the
otheris 0.

0

0

Are both inputs off?
o

NOR

0

Are the inputs

0

different?

0

0

Input

XNOR

|

A

Outputs Tif the inputs are the
Q

)

same: both Oorboth 1 the | A7 NenPuts the
inverse of the XOR gate).

Same:

A

B

0

(0]

Output
Q

0

0
0

_ A1.2.4 Construct and analyse truth tables
Truth tables are powerful tools for

Truth tables to determine outputs from inputs for a

summarizing logical expressions.
Some systems are so complex
they cannot be summarized in a
truth table.

problem description

How does the use of truth tables to
determine outputs from inputs based
on a problem description affect our
understanding oflogical reasoning
and problem-solving? What
limitations might this impose on our
comprehension of complex systems?

A truth table is a diagram of the outputs from all possible combinations of input.
Truth tables are used to predict the output of simple logic circuits.
In the previous section, each gate had a logic diagram. Sometimes, you might
encounter problems that only have a description of a problem. You must read
the description carefully and decide which logic gates would be appropriate,
then construct a suitable truth table. The underlying process is the same for
constructing the truth table, but you must first understand the problem correctly.

Al.2 Datarepresentation and computer logic

Worked example 15
A security system activates an alarm if both a motion sensor and a door sensor are activated simultaneously. Draw a
suitable truth table for this system.

Solution
First, consider
the input(s).
There are two inputs: a motion sensor and a doar sensor.
Label them A (motion sensor) and B (door sensor).

1 (True) only if all its inputs are 1. Draw and complete the
logic table.

A

Q

Second, consider
the output(s).

0

0

0

In this case, there is one output: an alarm is activated.
Label this Q (activate the alarm).

0

1

0

1

0

0

1

1

1

The alarm only sounds if the door AND motion sensor are
activated at the same time. So, the required logic gate is
an AND gate.
Now construct the truth table.

Rewrite the output in the context of the question. Q is only
1 (the alarm is activated) if both A (the motion sensor) and

There are two inputs, A and B, and one output, Q. The

B (the door alarm) are True. This makes sense and fits the

total number of possible outputsis 2. In this case n = 2, so
22 = 4. The system uses an AND logic gate. This outputs

problem description perfectly.

Worked example 16
In an automatic lighting system, a light turns on if at least one of two sensors detects darkness. The lighting system also
has a manual override switch that, when activated, ensures the light stays off regardless of the input from the sensors.
Draw and complete a truth table for this system.

Solution
First, think about the input(s). There are two light sensors:
label them A and B. There is also a manual override switch:

A

B

AORB

NOTC

Q

label this C.

0

0]

0

0

0]

Next, think about the output(s). In this case, the light is the
output. Label it Q.

0

0]

0

1

0

0

1

1

0

1

0

1

1

1

0

1

0

1

0

1

1

0

1

1

0

1

1

1

0

1

1

1

1

1

0]

To decide which logic gate(s) you need, read the question
carefully: “A light turns on if at least one of two sensors
detects darkness”. So, the light tumns on if sensor A OR
sensor B OR both sensors detect darkness, so the first gate
isan OR gate.
The override switch is an additional logic gate: when
activated, this means the light always stays off, irrespective
of the inputs. So, the second gate is a NOT gate.
The logical statement is (A OR B) AND (NOT C).
Construct the truth table. You have three inputs, and
you know the total number of possible outputs is 2" = 23
(since n= 3) = 8. There are eight outputs, so give your
table eight rows.

Check if your answer makes sense. In row 7 of the table,
notice that both sensors (A and B) have detected darkness.
Notice also that C (the override switch) is not on. And Q,
the light, is True, which means it is on.
In row 8 of the table, notice that both A and B have
detected darkness, but because C (the override switch)
is True, the lightis not on (Q is False).

Al Computer fundamentals

Worked example 17
An automatic watering system for plants only activates when it is daytime and either the soil moisture is low or the
temperature is high.
Draw and complete a truth table for the system.

Second, think about the output: the watering system
activates (Q).
Next, think about the logic gates you need: A AND
(BORC).
Now construct the truth table. There are three inputs. The
total number of possible outputs is 2" = 23(sincen=3) =8
outputs. Your truth table needs eight rows.

(BORC)

—|=|—|lO|lO|lO|O|C|
D

—|—jo|lo|—=|—|lclO|
W

First, think about the inputs. There are three: daytime (A),
soil moisture (B) and temperature (C).

—|o|—|oc|=|o|=|oc|n

Solution

0

Finally, check your work. In row 1, even thoughitis
daytime, neither the soil moisture nor the temperature
are true. Therefore, the water system is not activated.
However, in row 6, it is daytime and the temperature is

high (1), so the water system activates.

_ Truth tables and their relationship to a Boolean expression
with inputs and outputs
Boolean expression An algebraic

So far, you have built truth tables from logic diagrams and problem descriptions.

expression forme_d using Boolean

You can use Boolean expressions to build truth tables without the need for

variables and logical operators such
as AND, OR, NOT, NOR, and so on.

diagrams or problem descriptions. Boolean expressions are clearly stated, with
little to no need to interpret them. Here are three Boolean expressions:
1.

ANOT(BORC)

2. AAND(BXORC)

3.

(ANORB)ANDC

You will generally encounter truth table problems with only three inputs.

Worked example 18
Construct a truth table for this logic statement:

(AAND B) ORNOTC.

-

B

-

==

o

Q

©c 1 0]

60

0

1

1

0

0

1

0

0

0

Solution

0

]

0

0

1

1

Identify the inputs. In this case there are three: A, B and C.

0

1

]

0

0

0

Construct the truth table. You have three inputs, and you

1

0

0

0

]

1

know the total number of possible outputs is 2". Since
n =3, the number of outputs is 2% = 8. Add eight rows to
your truth table.

1

0

1

0

0

0

1
1

1
1

0
1

1
1

1
0

1
1

Al.2 Datarepresentation and computer logic

Worked example 19

A

Construct a truth table based on the following logic

statement: (A XOR B) AND NOT C.

B

¢ | AXORB

NOTC

a

0 | 0]

60

0

1

0

0

0

1

0

0

0

Solution

0

1

0

1

1

1

Identify the inputs; in this case there are three:

0

1

1

1

0

0

A BandC.

1

0|

o

]

1

1

Construct the truth table. There are three inputs, and
you know the total number of possible outputs is 2.
Since n = 3, there are 23 = 8 outputs.

1

0

1

1

0

0

1
1

1
1

0
1

0
0

L
0

0
0

(S
Construct a truth table for each of these logic statements:
1.

(ANORB)ORC

2.

(AANDB)NORC

3.

AXCR(BORC)

Truth tables derived from logic diagrams to aid the
simplification of logical expressions

’;‘ WO

Truth tables derived from logic diagrams help simplify logical expressions by
providing a clear and complete overview of the output for all input combinations.

AND
NOT
4 Figure 45 A more complex logic

Given a slightly more complex logic circuit, how should you approach solving it?
Remember, with a truth table you are concerned with predicting all possible input
combinations and their corresponding outputs.

diagram
A

B

Decimal

.

0

0

0

Listall input combinations. With two inputs
(A and B) there are four
combinations (00, 01, 10, 11), so add four rows to your truth table. This will

]

0

>

help you to not forget a possible input.

1

1

3

For n given inputs, there are a total of 2" possible input combinations. So,
with two inputs there are 22 = 4 input combinations. For three inputs, there
are 22 = 8 input combinations.

A
0

B
0

AND output
0

Make sure that you arrange your inputs logically. Notice that the inputs count
up in binary, starting at O in the first row. (The decimal equivalent is shown
here for reference only—do not include this in your table.)

0
1
]

1
0
]

0
0
]

.

Creating a truth table from a logic diagram
1.

2.
3.

Apply the first operation (AND). Calculate the AND operation result for each
input combination.
_
)
Apply the second operation (NOT) to the result of the AND operation.
This gives the final output of the circuit. Do you recognize this simple logic
circuit? Hint: it has an AND and a NOT gate.
.
This is the same output as a NAND gate.

5

:

:

A | B |AND output | NOT output
0]0
01

0
0

1
1

110
11

0
:

1
o

Al Computer fundamentals

Worked example 20
Construct a truth table for this diagram.
XOR

A
B

XOR
Q

C

Solution
Determine the total possible
number of input permutations. With
three inputs (A, B and C), there are
eight possible combinations
(27 = 2% = 8). Listall the input
combinations in a logical order by
counting up in binary: columns A,
B and C will show numbers O to 7
in binary. (Not1 to 8: you must start
counting atQ.)
Calculate the first XOR operation
result for each input combination of
AandB.

Calculate the second XOR operation
by comparing A XOR B and C.

e

A

B

C

0
0
0

0
0
]

0
1
0

0
1

1
0

1
0

1
1

0
1

1
0

1

1

1

A

B

<

AXORB

0

0

0

0

0

0

1

0

0

1

0

]

0
1

]
0

1
0

1
1

1

0

1

1

1

]

0

0

1

1

1

0

A

B

Cc

AXORB

Q

Construct truth tables for each of

0

0

0

0

0

these diagrams

0

0

1

0

1

0

1

0

]

1

1

0

1

1

1

0

1

0

(0]

1

1

1
1

0
1

1
(0]

]
0

0
0

1

1

1

0

1

Simplifying output expressions with algebra and
Karnaugh maps
Karnaugh maps (K-maps) are a method for simplifying Boolean algebra
expressions by minimising the number of terms needed to express a logic
function. A K-map can also be thought of as a special type of truth table that
makes finding patterns easier.

Al.2 Datarepresentation and computer logic

AND

2.

Consider
the number of inputs. In this case, there are two inputs.

3.

Now constructa K-map.
Draw a grid: the number of columns = the number of possible inputs for A.
The number of rows is the number of possible inputs for B. In this case, both
AandBcanbeOorl,sodrawa 2 X 2 grid. From the top left corner of the
grid, draw a diagonal line away from the grid to separate the two inputs.

4.

A
B

Above the line, add a label, A, and column headings showing all the possible

0

inputs for
A. Under the line, add a label, B, and row headings showing all the
possible inputs for B. Put the smallest values nearest the diagonal line.

1

Populate the table. Looking at the truth table from step 1, ask yourself: “if Ais
Oand B is 0, what is the output?” The answer is 0. This value goes in the top
left cell of the K-map, where the A = 0 column and the B = O rows intersect.
Repeat the question, using the correct A and B input values for each cell.
The K-map is complete.

Q

0

0

0

0

1

1

1

0

1

—_

Create a K-map for this truth table.

B

1

0

Solution
First, construct the truth table. In this case, the truth table

A

has already been provided in the question.
Next, consider the number of inputs. In this case, there are

0

two inputs.

Now construct a K-map. Note that you have column
headings with all the possible input combinations for
A at the top, and row labels with all the possible input
combinations for B on the left.
Populate the table. Looking at the truth table, you can ask
yourself: “if Ais Oand B is 0, what is the output?”

The answeris 0. If Ais 1and B is O, the outputis 1.
Your K-map is complete.

1

1

0

1

0

1

A
B

Worked example 21
A

—lo|lo|lo|D

First, construct a truth table. K-maps are generally used with no more than
four inputs, and the IB typically uses three inputs for truth tables. This
example uses the truth table shown here.

—lo|=|o|lm

1.

—|—|O|O|r

Constructing a K-map

0

Al Computer fundamentals

Worked example 22
Create a K-map for this truth table.

A

B

C

Q

0

0

0

0

0

0

1

1

0

1

0

1

0

1

1

0

1

0

0

1

1

0

1

0

1

1

0

0

1

1

1

1

Solution
First, consider the number of inputs. In this case, there are three inputs: A, Band C.

Constructa K-map. At the
top, write column headings

P

In

heading

A
BC

0

|

Populate the table. Lociklng

at the truth table, ask: “ifA is

with all the possible input

00

f:gg:i:g;i?\;ﬁ bi[ﬁ.
5

0]

0and BC is 00, what s the

output?” The answer is zero.
If Ais 1and BCis 00, the

with E_” the po?mbée 'ngLé[
combinations for B and C.

1

output is 1. Repeat until the
e ek,

10

BC

&

0

1

0| o
01

1

0

i

5

10

1

©

Simplifying K-maps
To simplifya K-map, such as the one in the solution to Worked example 22, you
first group the 1s together. There are some important rules to remember as you
create groups of 1s.
1.

Agroup can only contain one, two, four or eight 1s.

2.

Youshould make as large a group as possible—do not make a group of two if
you can make a group of four.
Each group should be shaped as a horizontal or vertical rectangle or square.

4.

The groups may overlap if necessary, and you can wrap around the edges of
the K-map to form a group.

5.

Every 1 onthe map must be included in one group.

A Gray code, or reflected binary code, is a binary numbering system where two
successive values differ by one bit. This is useful in K-maps to minimize errors in
switching circuits by reducing the possibility of error during the change of state
from one code to another. In the context of K-maps, the Gray code ensures that
adjacent cells differ by only one variable, simplifying the process of grouping
and identifying commonalities among terms, which helps in minimizing Boolean
expressions.

Note that row labels in K-maps are not in sequential binary order; they differ by
only one bit (e.g., 00 and 01, 01 and 11).

Al.2 Datarepresentation and computer logic

Worked example 23
Simplify the K-map from Worked example 22.

Solution
First, group the 1s together.
BC

A

0

example, notice how C does not change in the column
on the left. You can also notice that
A does not change.
Looking at the two groups in the right column, notice that
A does not change and C does change.

1

00 | {0l
ofi 73]
]

!

nfii|
10

0

Ifa variable changes state within a group (i.e., includes
both its true and complemented forms) it is not included
in the term for that group. In the example, you can
observe that B does change in the group on the left.

o

o
[¢71}
===

|CnotA+A+BnotC

Now, write each term.

Include a variable in the term if it is the same across the
entire group (e.g., all rows or columns the group spans are
labelled with the variable in the true or complement form).

Next, determine the variables for each group.
Each group corresponds to a term in the simplified
Boolean expression.
Look at the rows and columns that your group spans. For
each variable do the following.
Ifa variable does not change within agroup (i.e., all 1s
in the group are in rows or columns marked by the same
variable state), that variable is part of the term. In the

Omit the variable if the group spans areas where the
variable changes from true to complement or vice versa.
Combine the terms. Once you have a term for each
group, combine them with OR operations. This results in
the simplified Boolean expression for the original function
defined by the K-map.

A1.2.5 Construct logic diagrams
Using logic diagrams to demonstrate how logic gates are
connected and interact in a circuit
Logic diagrams are composed of connected logic gates, inputs, and outputs.
Logic diagrams are normally read left to right. When reading and interpreting
a logic diagram, remember that its main purpose is to demonstrate the flow of
logic. These diagrams can be directly transposed to electronic circuits, serving as
a blueprint to build a physical circuit.

N

A Figure 46 A half adder. The halfadder
adds two single binary digits, A and B. It has
two outputs, sum (S) and carry (C)

> D

C

out

A Figure 47 A half subtractor. The inputs
X and Y are the numbers to be subtracted
(specifically,

X—Y) while D is the difference

and B is the borrow signal (if the circuit
needs to borrow)

Al Computer fundamentals

Use standard gate symbols for AND, OR, NOT, NAND,

NOR, XOR and XNOR gates
Table 12 Logic gate symbols
AND

OR

A

A

NOT

NAND

NOR

XOR

XNOR

A

A

A

A

You should use standard gate symbols when constructing logic diagrams. Itis
helpful to label your logic gate to avoid any confusion. Make sure your inputs and
outputs are clearly labelled.

Worked example 24
A simple security system only activates an alarm when both a motion sensor and a door sensor detect a breach
simultaneously. Create a logic diagram to represent this situation.

Solution
First, think about and label the inputs: M for motion

Your diagram might look like this:

sensor, D for door sensor.

Next, think about and label the outputs: A for alarm.

M AND

Consider what logic gate is needed: in this case, itis a
simple AND gate.

D—

A

Worked example 25
An automatic watering system for plants that should only activate under two conditions: it is daytime and either the
soil moisture is low or the temperature is high.
Create a logic diagram based on this problem.

Solution
First, think about and label the inputs. There are three
in this problem: daytime (D), soil moisture (S) and
temperature (T).
Next, think about and label the output, the watering
system activates (Q).

Thinking about the logic gates, create A AND (B OR C).

S

D—

AND

Q

T

Process inputs diagrammatically to produce outputs
When systems or circuits are represented in a diagram, inputs are represented by
lines or arrows coming into the diagram from the left side. These may be labelled
with letters (such as A, B or C) or descriptive names (such as motion sensor or

proximity sensor).
In Worked example 25, the inputs are S for soil moisture, T for temperature, and
D for daylight. The output, Q, tells us whether the watering system activates.
Note that the output goes towards the right side of the diagram.

Al.2 Datarepresentation and computer logic

Remember to read logic diagrams from left to right unless clearly stated
otherwise. You can assume variables on the left side are inputs.

C0 @—‘j:j)::

@50

Po

Look back at the logic diagrams you have drawn or been
given in previous sections of this unit.

By S}

Identify all the inputs and the outputs. If you spot any

G

mistakes, correct them!

Qs

Combine gates to perform more complex
logical operations

A @%J
B, [G}+

CZ

Combinations of gates can lead to more sophisticated logical
operations.
Ao—
Bo

Az @%_‘
B, [oH

~

Q5

P,

2

©2

1

C3

L
[
T
[

B

© S

Py

A Figure 48 A full adder is used to add two binary digits along with a

Az[OH

G3

B4 Abstract data types (HL only)

Each question in paper 2 will be based around computational thinking,
programming and problem-solving. Question 1 covers computational thinking,
giving you a chance to show you understand OOP concepts and can develop
algorithms without coding. The remaining questions will cover coding in either
Java or Python.
It is likely that you will be given one or two scenarios and asked to code solutions
to problems within the scenario as well as answering questions about OOP
concepts.

Example questions
*

State one reason why a flowchart could be used to represent a program.

*

Complete the trace table where x=14.

*

State the Big O notation for the given algorithm.

*

Sketch the stack resulting from the following operations:
push(1)
push(5)
push(40)
peek()

pop()
pop()

push(2)

*

|dentify two consequences of declaring an attribute as private.

*

Construct the method addStudent ()

*

Qutline how a HashSet can be used to ensure only one email is sent to
each address.

Paper 2 aims to assess your knowledge and understanding as well as your ability
to apply what you have learned about theme B.

External assessment: Paper 1 and Paper 2

Remember the following.
Read each question carefully.
When reading a question, identify what it is asking and what tools you
need to answer it. This is particularly important with coding questions. Take
a moment to identify what methods you need, what you need to output
or return, and what tools you need to do this (for example, if statements,

loops, lists).
Use a highlighter to select the key terms in the question.
Spend time writing down the steps involved in the solution before translating
this into code. You might be surprised at how helpful this step is!
Make sure your solution returns or outputs what is expected.
At standard level, you will only look at one class and perhaps reference a
driver class. If you have more than this, you may have made an error.
At higher level, you will deal with multiple classes. Think carefully about what
class the method is in and what you need to access to make it work.
If you find a question that you are unsure how to answer, make a note on the
page and move on to the next question. You can come back to this question
ifyou have time at the end of the exam.
Take time before the end of the exam to review your answers. Fill in any gaps.
There is no negative marking, so you lose nothing from an educated guess!

Study skills for the external assessment
@ Self-management skills
Removing distractions

Tracking your studies

When revising for your exams, focus on the task at hand.
It may help you to set up a study space that will help
you maintain your focus. Having a dedicated space will
help you to get into the “studying mindset”. You may
find it useful to minimize the applications open on your
computers and remove your phone from your desk. To
maximize your time, you may find it useful to set a timer,
complete the task you have set yourself and then reward
yourself with a little break.

As with all courses, the IB computer science course has
prescribed topics and content. You may find it useful to
keep track of your learning on a copy of the course guide
(digital or print).

Work out what conditions help you to revise most
efficiently, and establish this as your general study routine.

The course guide is not sequential, so your teacher may
jump from topic to topic. If you are unsure, ask!

Don't wait until the end of the course to work this out!

*

Highlight the sections you have covered in lessons.

*

Add your own notes, identifying the topics you need
to spend time on at home and which topics you are
comfortable with.

External assessment: Paper 1 and Paper 2

@ Communication skills
Recording information
There are many ways to record information so that you
remember it both in the short term and the long term. In
the computer science course, you will probably encounter
factual and conceptual information that is new to you.
Developing a note-taking system that works for you will be
essential to helping you to recall the information you have
learned closer to the examinations.
*

Work with your preferred learning styles. Make notes
on paper, on your computer, using diagrams, or using
a mixture of different styles.

*

Remember that you need to reproduce your
knowledge in exam conditions, so try to avoid
methods that you cannot use in an exam setting

(for example, listening to personal music, using large
gestures or dance). Make it practicall
Vocabulary skills
All academic disciplines have specialist vocabulary.
Computer science is no different and has an extensive
specialist vocabulary. You may find it useful to develop a
computer science glossary. Whenever you encounter a
new term, you can add this to your glossary and provide
a definition. Continued reading of the term within the
context and using the term yourself
will help you to
develop your confidence using the new vocabulary.
*

Seethe ATl feature on page 6 for more ideas on this.

*

Remember to update your glossary throughout the
course.

*

Once you have an idea of the questions, begin to
identify research sources that might be useful. Your
teacher should help you with this, but planning
your own research will help you gain a deeper
understanding of the case study, which in turn will
enable you to respond to questions fully.

@ Research skills
Information literacy
When completing your research for the case study, you
will need to exercise your information and media literacy
skills. This includes gathering sources, interpreting
information, evaluating the information, and then

communicating the knowledge through your exam
answers. You need to use media literacy skills to consult
online sources and identify the different perspectives
within the sources.

Case study sources

*

Who wrote it?

Case study sources will vary depending on the topic of the
case study and your knowledge of the topic. To identify
sources of research for the case study, you might consider
separating the areas of the case study into different topics
then identifying different sources for each topic. To find
sources, try the following steps.

e

When was it written?

*

e

With what purpose?

Consider your community. Is there anyone working in
the field or who has knowledge of the field you can
ask for help?

*

What assumptions has the author made?

*

What databases does your library have access to?

Planning

*

(Canyou find scholarly articles covering the topics?

Take time to plan your research for the case study.

*

What experiments can you complete that will help
you understand the topics in detail?

Identify the value of each source you use in your research
to determine whether it is reliable or not. Ask yourself
the
following questions.

*

Spend time reading through the case study carefully.

*

Consider what questions you may be asked about it.
Reading through past papers will help you work out
the kind of questions you may be asked.

External assessment: Paper 1 and Paper 2

Computational thinking skills
Algorithmic thinking
To practice algorithmic thinking, you can complete the following tasks.
*

Identify problems in your community. Then, identify the different objects
within the problem and model them using one ofthe system models you
have learned.

*

Develop algorithms to complete a task without coding. Writing steps to
solve a problem helps you develop algorithmic thinking skills.

*

Complete the problems identified in this book, using all the development
skills you have learned throughout the course.

*

Thinking of yourself
as a user of the system, consider what features you would
like within the system. Write down the steps of the algorithm to develop
those features.

Coding
As with any skills you learn, practising that skill will help you to master it. The best
thing you can do when coding is to practice. Here are some ideas to help you.
*

Complete the tasks in the book. If you find them overwhelming, start with a
simple version and develop it in stages.

*

When you complete a task, consider how you could improve the solution.
Then develop those improvements.

*

Ifyou have developed an algorithm to solve a problem you have identified,
try to code the solution to the problem.

*

Set yourselflittle challenges each week and try to complete them. Ask your
teacher or a friend for support if you need it.

+

Continue coding after the coding units have been completed. It is surprising
how natural coding will become if you practise it often for short amounts of
time.

Al is both your friend and your foe. Al can be useful if you need inspiration. But
if you do not understand the code Al produces, then you will not be able to
develop your own code or your own algorithmic thinking skills. Use Al wisely and
always cite your source.
Please note: there are academic guidelines regarding the use of
Al within IB
courses. Please talk to your teacher or IB coordinator for more information.

Index
Page numbers in bold refer to tables; page
numbers in italic refer to figures.

sorting 38596
summing 393
ALU see arithmetic logic unit

ABC (abstract base dlass) 497
abstract data types (ADTs) 548-81
binary search trees 568-72

And command, 5QL 202

bias

AND gate 51,52, 53
ANNs see artificial neural networks

Al systems 307, 310
in algorithms 309, 364
artificial neural networks 292
and data mining 227
gender bias 364

collision resolution 577

anomalies 168, 180, 181, 22/-8

racial bias 364

hashing function 576
linked lists 552-67

anonymity, intemet browsing 131
antivirus software /1
APls (@application programming interfaces)

load factor 577

operations 551
principles 576-9
properties 550
purposes 549, 550
sels 572-6, 5/7-8
abstraction 68
abstract data types 550, 551
computational thinking 323, 326-8,
330,331
object-oriented programming
492-500
AC see accurnulator

340, 341
appending to file code 408-9
application layer, TCP/IP model 119, 120,
122-123

application-specific integrated circuits
(ASICs) 249
Apriorn algorithm 2834
AR see augmented reality
architecture 5

graphics processing units 67
networks 124-43
arithmetic logic unit (ALU) 4

access control lists (ACLs) 140

arithmetic operations 17, 53

access controls 67, 70

Array, Java 442
Arraylist, Java 350, 352, 355, 442-4,

see also firewalls
accessing, programming 517
accountability, Al systems 307, 310
accounting /4
accumulator (AC) 4
ACID (atomicity, consistency, isolation,

durability) properties, database
transactions 211-14, 233-4
ACLs see access control lists

ACP see atomic commit protocol
activation functions
artificial neural networks 294, 295
convolutional neural networks 303
actuators 86, 87, B8
address bus 5, 20

ADTs see abstract data types
advanced persistent threats (ATPs) 155
agents, machine leaming 285-8
convergence 288
examples 285, 287
exploration versus exploitation
trade-off 286-7, 288
feedback loop 287
learning process 287
aggregate functions, SQL 206-9
Average 206-7
Count 207

447-9,477-8

artificial intelligence (Al)
accountability 307
algonthmic faimess 30/
bias 307

decomposition methods 325
environmental impact 308
ethical implications 30/-10
pervasive
Al 312
privacy 308
risk mitigation 313
security 308
societal impact 308, 313
transparency 308, 313
see also machine leaming
artificial neural networks (ANNs) 292-300
activation functions 294, 295

dlassification example 293-4
components and terminology

292, 293

Maximum value 208

pattern recognition example 296-8
regression example 294-5
ASCI (Amencan Standard Code for
Information Interchange) 47, 50
ASICs see application-specific
integrated circuits
assembly language 90, 91

Minimum value 208

assessment

Sum 209
aggregation, class relationships 425, 501-5
Al see artificial intelligence
algebra see Boolean algebra
algorithmic thinking 610
algorithms 376406
Aprion algorithm 283-4
averaging 393-4
bias in 309, 364
Big O efficiency 3/6-80
binary search 382-5, 398-400,

45663
bubble sort 385, 386-8
call 359
control algorithms 86, 87
count occurrences 394-5
cubic algorithms 377
design 323, 328-9, 330, 331
factorial algorithms 377
faimess of 307
linear search 381-2, 455-6, 460
maximum value 395-6

minimum value 395-6
quadratic algorithms 377
quicksort 400-3
recursive algorithms 359, 396-406
routing algorithms 127
search for data 380-5
selection sort 385, 388-92

external assessment 600-10
internal assessment 582-99
association rule discovery 225-6
association rule leaming 282-5
association rule mining 283
asymmetric aryptography 160, 162
atomic commit protocol (ACP) 234
atomicity, databases 182, 211

AlPs see advanced persistent threats
attributes, databases 170, 176

audio, data storage 48-9
augmented reality (AR) 312
authentication, data/network security 156,

158, 231
automalic doors B8-9

autonomous vehicles 87
Average function, 5QL 206-7
averaging 393-4

in training data 308-9
big data, and databases 171
Big O efficency 376-80, 377
binary
data storage 4/-51
equivalents
and conversions 39-42,
43,456
logic gates 51-5
number systern 38-9
strings and characters 47-8
subscript 38-9
binary encoding 49-51
binary executable 90
binary search algorithm 382-5, 398-400,
456-63
binary search trees (BSTs) 568-72, 579
Bitcoin 136
bitmap images 49
bits 39, 50
bit depths 49
Bitlorrent 136
blacklists 154, 159
blockchain 136
Boolean algebra 52, 63, 64-5

simplifying complex logic diagrams
and expressions 63-5
simplifying output expressions 58-61
Boolean data 338
Boolean expressions 56—7
Boolean operators 534
boot-up process 14
bots, customer service 321, 322

breakpoint debugging 346
broadcast address 122

B51s see binary search trees
bubble sort 385, 386-8, 464-72
budgeting 223
BufferedReader, Java 409-10
buses 4-5, 20

business computing 551
business environment
data mining 220, 223-8
file servers 130
online analytical processing 220-3
proxy servers 131
routers 112

virtual local area networks 140-141
wireless access points 113
bytecode 90
bytecode interpreters 95
bytes 39, 50
cache memory 12-15
calaulate function 371
call 359
Canva (graphic design platform) 32
cardinality, entities 170
Chs see certificate authorities
cascading, databases 180
casting 441
catch staternent, error handling 342-3
central processing unit (CPU) 3-6, 8-12, 67
buses 4-5, 20

cache memory 12-15
components 3,4, 5

back propagation, artificial neural networks
293,297,298
background operations /0
bandwidth, data transmission 148

bank account trensactions 212-13
Barker style, entity relationship diagrams 176
barriers 12

batch processing 407
behavioural design patterns 522
Between command, SQL 198

core architecture 9
design philosophy 8
fetch—decode—execule oycle 15-19
graphics processing unit comparison
8-12
interrupts /8-81
latency 8
memaory access 10
memory interactions 13-15, 20-1
performance monitoring 72

pipelining 21-4
polling 78-81
power efficiency 10-11
primary memory 12-15
processing overhead 79
processing power 9-10
processor lypes 5
registers 4, 5,12, 13, 20-1

scheduling 70
centroids 279
certificate authorities (CAs) 161
CF see collaborative filtering
characters 47/-8,338

checksums 71
Chen notation style 176
CIDR see classless inter-domain
routing notation
dircuits, logic gate connection
and interaction 61

arcular linked lists 563-7
citation of sources vii
dasses 417, 418-19, 420, 422-5
abstract classes 492-500

aggregated relationship 425, 501-5
composition relationship 425, 506-10
creation/design of 431-3
inherited relationship 425
instance variables 418
instantiation of 420, 434

library class code 426-30
looping 519, 521
multiple classes, coding for 511-21
runner class 440
see also UML dass diagrams
dassification 238
artificial neural networks 2934
data mining 224
dassification techniques, in supervised
learning 268-75
classless inter-domain routing (CIDR)
nolation 141-3

client-server model 134-5
clock speed 9
cloud-based implementation 215-16
cloud computing 31-6, 104-5
choice of model 36
infrastructure as a service 34, 356

machine learning 249
platform asa service 33-4, 35, 36
software as a service 31-3, 35, 36

clustering techniques 238, 279-82
data mining 224-5
density-based spatial clustering 280
hierarchical clustering 280
K-means clustering 279
mean shift clustering 281
CNNs see convolutional neural networks
CO-Processors 5
code generation 92,93
code sequence 362
cading skills v, 610

collaborative filtering (CF) 271-3
collision resolution strategies, hash
tables 577

comments 450
Commit command, SQL 213
commutative law 64
comparelo method, |ava 464
comparison operators 464
COMPAS algorithm 309
compilation/compilers 90-7, 499, 500
definition 90

overview of process 93
compile-time polymorphism 481-4
compiled programming languages 93, 96
justir-ime compilation comparison 94
components 3, 4, 5, 86

composite key, databases 170
compaosition 425, 50610
compression 28-31
computational thinking 316-35, 607-8
abstraction 323, 326-8, 330, 331

611

Index

computational thinking (Continued)
algorithmic design 323, 328-9,
330, 331
data analysis 330
database design 331
decomposition 323, 324-5, 330,
331
machine leaming 330
network security 331
pattern recognition 323, 325-6,
330, 331
problem solving 330
problem specification 317-23
software development 330
study skills 610
concatenate 339
concalenalted key, databases 170
conceptual schemas 1734
concurrency control, databases 230
confirmation bias 227
congestion, networks 151
consent, Al systems 307

constraints, problem specification 318
content security policies (CSPs) 157
context switching, scheduling 77
control algorithms 86, 87
control bus 5, 20

control systems 86, B/-9
control unit (CU) 4
controllers 86
corvolutional neural networks (CNNs) 240,
242, 300-3
conceplts and terms 301
image classification 303
input data process 303
process 301
cookies 116-17
cores (processing units) 5,6, 7,8,9,10,23-4
Count function, SQL 207
count occurrences 394-5

CPU see central processing unit
creational design pattern 522
cross-platform development 96
cross-site scripting (X55) 156
crows foot style, entity relationship
diagrams 176
cryptocurrencies 136
cryptography 159-60, 160-1, 162
(C5Ps see content security policies
CU see control unit
cubic algorithms 377
curse of dimensionality 259-62
customer feedback systems 320-2
customer service
chatbots 321, 322
data mining 228
cyberattacks
countermeasures against 157-8
employees’ role 158
vulnerabilities to 156
see also network security; security

cyberbullying 310, 311

markeling 224, 228
regression 225
sequential pattern discovery 226-8
data packets 110, 111-12
data partitioning, databases 231
data preprocessing 251-63
data cleaning 251-6
feature selection 256-8
normalization 255-6
standardization 256

data processing
logic gates 52
machine leaming 247, 248
data representation 38-46
binary and decimal integer
conversions 39-42
binary and hexadecimal integer
conversions 456
binary integers 38-9
hexadecimal and decimal integer
conversions 43-5

hexadecimal integers 42-3
terminology 39
data retrieval 51
data segmentation 149-51
data signal processors (DSPs) 5
data storage 4/-51, 67, 233
data structures 350-61
arrays and lists 351-8

612

rows 205
scalability challenges 214

domain name system (DNS) server 127-8
DORA (discovery, offer, request and

acknowledgment) process 129
dot notation 442, 51/-21

one-dimensional structures 442-6

see also database.
. distributed

stacks 358-9

static and dynamic structures 3501
two-dimensional structures 44/-50
data/lime dala types 178
data transmission 144-53
dala segmentation 149-51
IP addressing 144-7
packet switching 149-51
static and dynamic routing across
LANs 152-3
types
of media for 14/-9
data lypes 337, 338, 491
see also abstract data types
data units, byte and bit equivalents 50
data visualization 261

schemas 171, 173-5

databases; relational databases;

components of 218
data cleaning 219
data mining 220, 223-8

SQL (structured query language)
DBSCAN see density-based spatial
dustering of applications with noise
DCU see data control language
DDL see data definition language
DDoS see distributed denial of service
deadlocks 83, 362
debugging 344-8, 464
breakpoint debugging 346
print statements 34/
step-by-step code execution 348
trace tables 344-5
decapsulation 149, 150
decimal 39, 338
equivalents
and conversions 39-42,
43, 44-5
decision making support 52, 214, 222-3
dedision trees 269-71, 273-5, 278, 304

historical data 219

decode phase, fetch-decode—execute

online analytical processing 220-3
as subject-oriented 218-19

decompaosition 323, 330, 331

data warehouses 217-23, 500

as time-variant 219

database design 1/3-90
computational thinking 331
data types, relational databases 177-9
denormalization process 189-90
entity relationship diagrams 173-7
normalization 181-8
schemas 1/3-5

calculations ondata 206-9

data quality impact 252-3
duplicate data 254

dala integrity 211-14
data updates using 5QL 204-6
dalabase development using SGL
193-5
database languages 191-4
queries in SQL 195-204

fraud detection 226, 228

rollback 213

documents, digital 162

DVCS see distributed version control system
DVD drives 26
DVES see dynamic voltage and
frequency scaling
dynamic data structure 350-1, 442-6
dynamic host configuration protocol (DHCP)

deandata 252

data control language (DCU) 192
data definition language (DDL) 191-2
data integrity 71, 211-14
data management 21/-19
data manipulation language (DML) 192
data mining 220, 223-8
association rule discovery 225-6
bias 227
classification 224
clustering 224-5

NoSQL databases 215
performance overhead 214
platform as a service databases 215-16
primary keys 169, 170, 180
queries 210
recovery of data 213
relationships 170-1, 175-6
repeating groups 182

transparency 231-2
types of 229
distributed denial of service (DDoS) 156, 157
distributed systems 105-6
distributed version control system (DVCS) 567
DL see deep learning
DML see data manipulation language

last in, first out 358-9

data deaning 219, 251-6

data consistency 210, 211, 213, 230

normalization 163, 181-8

server coordinator 234

duplicate data, removal of 254

database programming 191-214
aggregate functions in SQL 206-9

data compression 28-31

foreign keys 169, 180
in-memory databases 216-17
indexes 204-5
library database 18/7-8
medical records databases 16/
modality 170
multiuseraccess to 213

views 209-10
virtual tables 209-10

data bus 5, 20

outliers 254, 256

flat file databases 167, 168-9

validation rules 231

firstin, first out 359-60

database languages 1914

missing data 255

entities 167, 169, 175, 210

atomic commit protocol 234
concurrency control 230
data consistency 230
data partitioning 231
fault tolerance 232
fragmentation 229
global query processing 232
replication 229, 232-3
security 231

security 231
social media 167
spatial databases 216
tables 1/0, 180, 193-4, 195

data analysis 330

irrelevant data 254

e-commerce database 185-8

double loop 519, 521
doubly linked lists 558-63
downsampling 29
drill-down function 222
D5Ps see data signal processors
duck typing 491-2

unnormal form 182, 183

initial data 252

durability 212

transactions 211-14

databases 166-/72
anomalies 168, 180, 181

atornicity 182, 211
calculations ondata 206-9

cardinality 170
cloud-based databases 215-16
compaosite key 170
concatenated key 170
dala consistency 210, 211, 213

dala integrity 211-14
data storage 21517
denormalization 189-90

oycle 17,23
deep leamning (DL} 238, 240, 241, 242,
245,247,248, 304
deletion
binary search trees 569
linked lists 554, 558, 563
sets 578
denormalization, databases 189-90

density-based spatial clustering of
applications with noise (DBSCAN) 280
dependent (response) variables 265
dequeve method 359, 360, 551

design pattemns, object-oriented
programming 521-41
device management /3, 82
DHCP see dynamic host configuration
protocol
dice function 222

dict, Python 579
difference checks 574, 575, 578

digital certificates 157, 159-60, 161-2
digital circuit symbols 63
digital infrastructure 104-8
digital signatures 161
dimensionality reduction 258-63
discrete categorical outcomes 268-75
disinformation 309
disk input/output operations, interrupts and
polling BO
Distinct command, 5QL 196
distributed databases 228-34
ACID transactions 2334
advantages/disadvantages 233

117-18,128-9
dynamic IP addresses 118, 146

dynamic polymorphism 484-91
dynamic routing 152-3
static routing comparison 153
dynamic voltage and frequency scaling
(DVFS) 11
e-commerce database 185-8

Eclipse
IDE, Java 431
edge computing 106-7, 247, 248
edge devices 248, 249
educational environment

doud computing 104
machine learning 246
network segmentation 137
proxy servers 131
school databases 209
swilches 113
wireless access points 113
efficiency, scheduling 77
email 130, 157
embedded methods, feature selection 258

embedded multimedia cards ([eMMCs) 26
embedded systerns 80
emerging technologies, ethical issues 310-13
employee training, security testing 158-9
encapsulation 149, 150, 420, 435-72

abstract data types 550
advantages of 436
one-dimensional structures 442-6
repetition statements with objects
454-5
selection statements with objects
450-4
sorting with objects 46472
two-dimensional data structures
447-50
variable modifiers 436, 437, 438,

441
encryption 70, 75, 103, 159-60, 163, 231
engueue method 359, 360, 551

entities, databases 167, 169, 1701, 175,
180, 210
entity relationship diagrams (ERDs) 173-4
Barker style 176
Chen notation style 176
construction of 177
crows foot style 176
items within 1756
enums (enumerated data type) 179

Index

epsilon-greedy stategy 287
ERDs see entity relationship diagrams
error detection 51, 94, 95, 254

error handling, programming 342-4
Errors
deadlocks 83, 362
exception errors 342
incorrect inputs 362
infinite loops 362
logic ermors 342
program errors 342
Ethemet 110, 112,113
ethical considerations 307-13
binary search trees 579
emerging technologies 310-13
machine learning 307-10
online communication 309-10
ETL see extract, transform and load process
events 12, 79

exception handling 3424
execute phase, letch-decode-execute

architecture 67
central processing unit comparison
8-12
design philosophy 8
graphics rendering 5, 7
high throughput 7, 8
instruction set architecture 9
memory access 10
parallel processing 6
power efficiency 10-11
processing power 9-10
scientific computing 8
simulations
and modelling 8
video editing 8
video random access memory 7
Group By command, 5QL 199
group data, dustering lechniques 279-82
group permissions 70
guessing game 36/-9
GUI see graphical user interface

infrastructure asa service (laaS) 34, 35-6
inheritance (in coding) 420, 473-80
injava 475-8
in Python 478-80
inherited relationship, classes 425
input-process-output (IPO) model 84-5
input spedfications 319-20
insertion
binary search trees 569

halfadder &1
half subtractor 61

exploration versus exploitation trade-off
2867, 288
exponential complexity 377
extends keyword, Java 494-6
external assessment (Papers 1and 2) 600-10
extract, transform and load (ETL) process 219

dala structure 350

sets 578
instance variables 418

data types 337, 338, 491
difference check 574
dot notation 517-19
dynamic 10 lists 442-4
dynamic 2D lists 4479
dynamic polymorphism 485-8
encapsulation 438-9
exception handling 342-3
extends keyword 494-6
factory design pattern 529-32

instantiation 420, 434

Fibonacci in 397

instruction register (IR) 4
instruction set architecture (ISA) 9
integers 4/, 338
binary 38-9
binary search trees 570-1
binary to decimal conversion 39-41
binary to hexadecimal conversion

file append 408-9
file overwrite 408
file reading 409-10
file writing 40/7-9

linked lists 554, 558, 563

456

cycle 17,23
execution, translation process 92,93

count occurrences 394

forloop 370, 452-3, 454

guessing game 36/7-8
HashMap 5789
if statements 451-2, 477

inheritance (in coding) 475-8
instantiation of an object 434

harassment, online 310

dedmal to binary conversion 41-2
decimal to hexadecimal conversion
44-5

hard disk drives (HDDs) 25, 26, 51

hexadecimal 42-3

hash functions 163
hash tables 5/6-7, 578, 580
hashes 71

hexadecimal to binary conversion 46
hexadecimal to decimal conversion

library 375
library class code 426-8

intersection, sets 574

linear search 381-2, 4556

Fl score, machine leaming models 2/6-7
factorial algorithms 377

HashMap, Java 578-9
hate speech 310
Having command, 5QL 200

internal assessment (IA), computational
solution 582-99

linked lists 554-6, 559-61, 564-6
lists 352-6
method headers 441
minimurm value 395

internet 104, 115, 131, 205

move method 485, 486-8

factorial numbers 404

HDDs see hard disk drives

internet layer, TCP/IP model 119, 121-2

factory design pattern 527-35

heat management, CPUs 11
heterogeneous databases 229

internet message access protocol (IMAP)
130
internet protocol (IF) 144
internet service providers (ISPs) 112
Internet of Things (loT) 96
interpreted programming languages 91-2,

multiple classes 511-14, 516
observer design pattern 537-8
parameters 373
print statements 347
quicksort 402
random library 374
recursion in 405

fairness, scheduling 77, 82-3
fast adder 63

hashing 576

hexadecimal number system 39, 42-3

fault tolerance, databases 232

equivalents and conversions 43, 44-6

FCFS see first-come, first-served

hierarchical clustering 280
high-performance computing centres (HPC)

feature selection 256-8
feedback, control systems 84
fetch-decode—execute cycle 16-19, 23

Fibonaca sequence 396-7
fibre-optic cables 14/, 148
field-programmable gate arrays (FPGAs) 249
HFO see first in, first out data structure

file processing 40/-15
file reading 409-10, 411
file writing 40/-9, 412
file servers 129-30
file systems 70, 71, 73, 82
filter methods, feature selection 257

filtering
network security 157
queries 195
finally block, error handling 343, 344
firewalls 70, 71, 75,109, 114, 154-5
first-come, firstserved (FCFS) 76, 77,78
first in, first out (FIFO) data structure 359-60
first normal form (1NF), databases 183, 184
flash drives 27
flat file databases 167, 1689

floppy disks 25
flowcharts 328, 331, 332-3
for loops 369-71, 452-3, 454
forecasting 223
foreign keys 169, 180, 220
forward propagation, artificial neural
networks 293, 295, 297

FPGAs see field-programmable gate arays
fragmentation, databases 229
fraud detection 226, 228
From command, 5QL 197
front function 359, 360
full adder 63

functions, programming 371-5
GAs see genetic algonthms
gateways 108, 114
gender bias 364
genetic algorithms (GAs) 288-91
genelic sequencing 8, 572
Git [distributed version control system) 567
global query processing 232
graphical user interface (GUI) 74
graphics processing unit (GPU) 5, 6-12,

248, 749

434
intercept, linear regression 265, 266, 267

95,96

250

home environment
hardware firewalls 109
network segmentation 137
routers 112

security systems B8
wireless access points 113
homogeneous databases 229
host address 138

HPC see high-performance computing centres
HR see human resources
HTTP see hypertext transfer protocol
HTTPS see hypertext transfer protocol secure
human resources (HR) 228
hybrid networks 126-7
hyperparameter tuning 27/5-8
hypertext transfer protocol (HTTP) 115-17,
131-2
digital certificates 161
response codes 116
slate management 117
hypertext transfer protocol secure (HTTPS) 117
hypervisor /5
1/0 (input/output) 67
IA see internal assessment
laa5 see infrastructure as a service
idempotent law 64
identity certificates 159-60
IDS see intrusion detection systems
if statements 363, 451-4, 477, 517
images
data storage in binary form 48
spatial hierarchies, machine learning
300-3
IMAP see internet message access protocol
in-memory databases 216-17
independent (predictor) variables 265
indexes/indexing
indatabases 204-5
hash tables for 580
inductive reasoning 396

Runner class 444

interpreters 90-7
interrupt handling 78-81

selection sort 389-90, 391-2

Scanner class 410-11

intersection, sets 574, 575, 578

selection statements 364, 450-3

intrusion detection systems (IDS) 157
intrusion prevention systems (IPS) 158
involution law 64
lol see Internet of Things
IP see intemet protocol
IPaddresses /5, 103, 117, 127-8, 144/
concealment of 131
dynamic IP addresses 118, 146
internet protocol 144
IP masquerading 155
IPv4 and IPvE addressing 144, 146

sets 573, 574
singleton design pattern 524-6
sorting 464
static 10 lists 442

static polymorphism 482-4
step-by-step code execution 348
strings 339-40
subset checks 574
summing 393
toString method 431, 4767, 484, 485
trace tables 345

network address translation 146-7

two-dimensional lists 354-6

private/public IP addresses 1456,
147

union, sets 574

routers 110, 111-12

smartphones 129
static IP addresses 118, 146

subnetting 13/-40
IPO see inpul-process—output model
IPS see intrusion prevention systems
IR see instruction register
imgation control systems 88
15A see instruction set architecture

islnstance function, Python 479-80
15Ps see internet service providers
itern-based collaborative filtering 271,
272-3

varable modifiers 437
varables 491
while loop 3667
JavaScript 96
Join command, 5GL 200-1
|PEG 30, 31,50
just-in-time {JIT) compilation 94
K-means clustering 279
K-Nearest Neighbours (K-NN) 268-9,
271-3,304

Karnaugh maps (K-maps) 58-61
kemel size and stride, image classification 303
keyboard, interrupts and polling 79
keys, databases 180

Java
abstract dasses 493-7
aggregation 501-4
Array 442
Armaylist 350, 352, 355, 442-4,
447-9,477-8
averaging 393

LANSs see local area networks
large dala sets
association rule leaming 282-5
binary searches 385
lastin, first out (LIFO) data structure 358-9
latency 8,13, 15,79, 155

binary search 383-4, 388-9, 456-60

leased lines, wide area networks 102

breakpoint debugging 346
bubble sort 38/-8, 464-9

left child property 568
lexical analysis 92-93
libraries 374, 375
library class code 426-30
library database 187-8
licence plate recognition systems 106

industrial environment

BufferedReader 409-10

gateways 108
modems 110
infinite loops 362
information literacy 609

classes 419, 431, 432
comments 450
comparelo method 464
composition 506-9

LIFO see last in, first out data structure

Index

Like command, SQL 201-2
linear regression 264-8, 294-5, 304

independent/dependent vanable
relationship 265
slope and intercept in regression
equation 265-7
linear search algorithm 381-2, 455-6, 460

linear time complexity 377
linked lists 552-3, 552, 554-67
aircular linked lists 5637

doubly linked lists 55863
in operating systems 553
singly linked lists 554-7
Linux, system log /2
lists 350, 351-8

deep learning 238, 240, 241, 242,

245,247,248, 304
development and testing 247, 248
dimensionality reduction 258-63
discrete categorical outcomes 268-75
and disinformation/misinformation 309

357, 447-50
for variables 418
livelock 83

edge computing 247, 248
edge devices 248, 249
ethical implications 30/-10
evaluation of dlassification
models 275-7
Fl score of models 276-7

load factor, hash tables 577

feature selection 256-8

local area networks (LANS) 101, 151, 152-3
log linear 377
logarithmic time 377
logging 71-2, 74,155, 407
logic circuits, truth tables 54-61
logic diagrams 57-8, 61-5
Boolean algebra 63-5
combining gates to perform complex
logical operations 63
gate symbols 62
logic gate connection and interaction

field-programmable gate armays 249
genetic algorithms 288-91
graphics processing unit 248, 249
hardware requirements 24/-50
high-performance computing
centres 250
house sale prices model 259-62
hyperparameter tuning 275-8
K-Nearest Neighbours 268-9,
271-3, 304
large dala sels, association rule
leaming 282-5

one-dimensional lists 351-4, 442-6
two-dimensional lists 351, 354-6,

inacircuit 61

processing of inputs to produce
outputs 62-3
logic errors 342
logic gates 51-5
AND gate 51, 52, 53
arithmetic operations 53
data processing 52
decision making 52
memory storage 53
MNAND gate 54
MNOR gate 54
NOT gate 53
ORgate 52,53
for a security systemn 52
symbols 53-4
XMNOR gate 54
XORgate 54
logical expressions, simplification of 57-8
logical schemas 173, 174
login, remote 161
logistic regression 304
looping structures 36671
double loop 519, 521

errors 362
for loops 369-71, 452-3, 454
guessing game 36/7-9
while loops 366-9
see alsorepetition statements
loss function 303
lossless compression 28, 29, 31

lossy compression 28-9, 31
loyalty cards 217, 239
MAC address table (forwarding table) 112,
151
MAC filtering 159
MAC (media access control) address 110,
129,159
machine code/instructions 90, 91

machine leaming 7, 236-315
accountability 310
accuracy of models 275
Al servers 248
algorithm performance 304-5
algorithm types 237-8
application-specific integrated
circuits 249
artificial neural networks 292-300
association rule leaming 282-5
bias 310
dlassification techniques 268-75
doud-based platforms 249
dustering techniques 279-82
computational thinking 330

614

continuous outcomes, prediction of
264-8
convolutional neural networks 300-3
dala preprocessing 251-63
dala processing 247, 248
data quality impact 252-3
decision trees 269-71, 273-5, 278,
304

medical records databases 167
memory 12-15, 20-1, 24-7, 67, 70, 82, 261
memory access 10,

17

memory address 16
memory address register (MAR) 4
memaory cards 27
memory controller 14, 20
memary data register (MDOR) 4
memory management /2-3, 82
memaory storage, logic gates 53
memory usage, data structure 351
mesh topologies 125
method headers 441
method overriding, object-oriented
programming 480-92
MFA see multi-factor authentication
Microsoft Office 365 33

Microsoft Outlook 135
Microsoft Teams 32
minimum value 208, 395-6
misinformation 309

subnetting 13740
virtual local area networks 140-1

network stack 67
network topologies 124-7
networked attached storage (NAS)
devices 27

networking /5, 360
dient—server model 134-5
peer-to-peer model 135-6
networks 100-65

architecture 124-43
characteristics of 101-3
dloud computing 104-5
congestion reduction 151
data transmission 144-53
devices 108-14
digital infrastructure 104-8
distributed systems 105-6
edge computing 106-7
firewalls 109, 154-5
internet 104

MitM see man-in-the-middle attacks
MLP see multi-layer perceptron
mobile networks 107
modality, entities 170

local area networks 101, 151

modems 109-10, 114

security 154-64
segmentation 136-43

modifiers, variables 436, 437, 438, 441, 475
modularity, abstract data types 550
modularization 371-5

Moodle (learming management system) 33
mouse /9, BO-1

mobile networks 107
personal area networks 102-3
protocols 108, 11518, 156

servers 12/-33

topologies 124-7
virtual private networks 103
wide area networks 102

move method
inJava 485, 486-8
in Python 488-91

see also network....
neural nebworks 238, 240, 241, 304

linear regression 264-8, 304
logistic regression 304
market basket analysis 239
medical imaging diagnostics 240
model selection and comparison
304-5

multi-core architecture 22, 23

convolutional neural networks
nibble (unit of data) 39
NICs see network interface cards
MNLF see natural language processing
nodes

model training 247, 248

multilevel queue scheduling 76, 77, 78

multi-ayer network modelling
292-300
natural language processing 240-1, 246

multiple dasses, coding for 511-21
multitasking 5, 81-2

large-scale deployment 247, 248

multi-core processors 5, 22-4
multi-factor authentication (MFA) 158
multi-ayer networks 292-300
multi-ayer perceptron (MLP) 300
multicasting 115

MySQL, data types 177-9

neural networks 304

overfitting of models 2/7-8
precision of models 276
privacy concems 310

NAND flash memaory 25
MNAMND gate 54
NAS see networked attached storage
devices
natural language processing (NLP) 2401, 246
network address translation (NAT) 146-7, 155

random forest 304

network communications, interrupts and

recall of models 276

polling 80
network devices 108-14, 114, 121
network interface cards (NICs) 110, 114,
121,159

object detection and classification
242-3
online communication 309-10

reinforcement leamning 238, 243,

2858
robotics navigation 243-4
security 308
sentiment analysis 244-5
societal impact 313
spatial hierarchies in images 300-3

network protocols 108, 115-18,131-2

marrin-the-middle (MitM) attacks 156
management reporting 222
MAR see memory address register
market basket analysis 239
market segmentation 281
marketing 222, 224,228, 282
maximum value 208, 395-6

MDR see memory dalta register
mean shift clustering 281
measurement bias 227
media access control (MAC) address 110, 129
medical diagnostics 240, 274-5

MNOT gate 53
NPC see non-playing character
numerical data types 178, 179

object-orented programming (OOF) 416-547
abstraction 492-500

multi-factor authentication 158

advantages/disadvantages 421
aggregation 501-5
classes 41/, 418-19, 420, 422-5
design of 431-3
code reusability 473-80
compaosition 506-10
design patterns 521-41
encapsulation 420, 435-72
factory design pattern 527-35
inheritance (in coding) 420, 473-80
library class code 426-30
method overriding 480-92
multiple classes, coding for 511-21
observer design pattern 535-40

network address translation 155

one-dimensional data structures

common vulnerabilities 156

malware 1585, 156, 157

Mot command, SQL 204

network security 154-64, 331

242,244
hyperparameter tuning 2/75-8
support vector machines 304
tensor processing units 249
training data 308-9

mail servers 130

294, 295, 299-300
binary search trees 568
distributed systems 105
singly linked lists 554
non-playing character (NPC) 325, 417
norrstatic variables 425-30
non-volatile memory 12
NOR gate 54
normalization
dala preprocessing 255-6
databases 169, 181-8
NoSQL databases 215

network routing 568
blacklists 154, 159

underfitting of models 278
unsupervised leaming 238, 239
clustering techniques 2/9-82
varniability in algorithm performance 305
workflow 251
see also artificial intelligence

artificial neural networks 292, 293,

network interface layer 119, 121, 122

supervised leamning 238, 240, 241,

transfer learning 238, 240, 241, 245

see also artificial neural networks;

content security policies 157
digital certificates 157, 159-62
distributed denial of service 156, 157

employee training 158-9
encryption 157, 159-60, 163
firewalls 70, 71, 75,109,114, 154-5
inputvalidation 157
intrusion detection systems 157
intrusion prevention systems 158
malware 155, 156, 157

password policies 157
phishing attacks 156, 158
public key certificates 159-60
security testing 158-9
software updates 157
virtual private networks 158
wireless security measures 159
see also security
network segmentation 13643
dassless inter-domain routing
notation 141-3
methodsof 137/-43

security 137

442-6
polymorphism 420-1, 480-92
repetition statements with objects
454-5
searching with objects 455-63
selection statements with objects
450-4
for a single class 417-72
singleton design pattern 523-7
sorting with objects 464-72
static and non-static variables and
methods 425-30

tools 420-1

two-dimensional data structures
447-50
UML class diagrams 423-5, 426, 431,

437,438, 506
objects 417, 420, 422
bubble sort 464-72
compaosition 506-10
data types 337
detection and classification 242-3
duck typing 491-2
instantiation of 434
observer design pattern 535-40, 536
one-dimensional (10) lists 351-4, 442-6
online analytical processing (OLAP) 220-3
online communication, machine learming
309-10
OOF see object-oriented programming
opcodes (operation codes) 4, 17
open addressing 577
operating systerns (O5) 66-83
abstraction 68

access control and permissions /0
accounting /4
antivirus software 71
command-ine tools 75

CPU scheduling 70
data integrity checks 71
deadlock 83
device management /3, B2
file systems /1, 73,82
functions of 68-75
graphical user interface 74
hashes 71

interrupts and polling /8-81
linked lists 553
logging /1-2
memory management /2-3
memory protection 70
multitasking 81-2
networking 75
patch management 71
performance monitoring 72
process isolation /0
process management 67, 68-9
resource allocation 81, 82

resource contention 83
resource monitoring/limits 82
resources managed by 67-8
rollback features /1
scheduling /73, 76-8
security /0, 71, 75
systern integrity 69
systemn resources 67
task management /2
task scheduling 82-3
update management /1
user and group permissions /0
virtualization 74-5
optical drives 267
Or command, SQOL 203

OR gate 52,53
Order By command, S0 198-9
05 see operating systems
outliers, management of 254, 256

peer-to-peer (P2P) model 135
perceplrons 292, 293, 294, 295, 299-300

performance-critical applications 96
personal area networks (PANs) 102-3
personalized marketing 282
penvasive
Al 312
phishing attacks 156, 158
physical schemas 173, 175
pipelining 21-4
pixels 48, 50
plagiarism vii
platform as a service (Paas) 33-4, 35, 36
databases 215-16
playlists 360, 381, 501-5, 569
polling 78-81,79
polymorphism, in classes 420-1
polymorphism (in coding) 480-92
dynamic polymorphism 484-91
static polymorphism 481-4
pop method, stacks 358, 359
portability, software 94,95
power efficiency 10-11
pre-emption, scheduling 77, 83
pricing strategies 282
primary keys 169, 170, 180
primary memory 12-15
primitive data types 337
print statements 347
printer queues 360
priority scheduling 76, 77, 78
privacy, Al systems 308, 310
private
IP addresses 145-6, 145, 147
private modifiers, variables 436, 437, 438,

441, 475
private-key cryptography 162
problem spedification 317-23
problem statement 31/-18
process 68-9, 84
process isolation 70
process management 67, 68-9, 222, 553

process scheduling see scheduling
processing power 9-10
processing speed 15
program counter (PC) 4
programming 336415
accessing 517
algorithms 376406
arrays 351-8
averaging 3934
Big O notation 376-80
binary search 382-5, 398-400
bubble sort 385, 386-8
code sequence 362
count occurrences 394-5
data structures 350-61

data lypes 337, 338
deadlocks 362
debugging techniques 344-8
dynamic data structure 350-1
exception handling 342-4
file-processing operations 407-15

variables 337-8
see also database programming;
object-oriented programming
programming languages 90-7,
90
applicability 95
compiled programming languages
93,94,96
interpreted programming languages
91-2,95,96
programs 68, 342
protected modifiers, variables 436, 437,

441,475
protocols
dynamic routing protocols 153
encrypted protocols 157
networks 108, 115-18, 156
proxy servers 131

racial bias 364
randormraccess memory (RAM) 13, 14,
16, 216
random forests 304
random library 374
read-only memory (ROM) 13, 14
reaHime systerms 80
recall (sensitivity), machine learning
models 276

push method, stacks 358, 359

recovery of data 213
recurrent neural networks (RNNs) 241
recursion 396406
binary search 398-400
quicksort 400-3

Python
abstract dasses 497-9
aggregation 504-5
averaging 394

regression, data mining 225
reinforcement learning (RL) 238, 243,
2858

publicIP addresses 145, 146, 147

public
key certificates 159-60
public-key cryptography 160, 162
public modifiers, variables 436, 437, 441, 475

binary search 384-5, 399-400,

460-3
bubble sort 388, 469-72
classes 419, 433

comments 450
composition 509-10
count occurrences 395

data structure 350
dala types 337, 338, 491
dict 579
difference checks 575
dotnotation 519-21
duck typing 491-2
dynamic 1D lists 445-6
dynamic polymorphism 488-91
encapsulation 439-40
exception handling 343, 344
factory design pattem 532-5
Fibonacdi in 397
file reading and writing 411-12
for loop 370, 371
guessing game 368-9
if staterments 4534
inheritance (in coding) 4/8-80
instantiation of an object 434

registers 4, 5,12, 13, 20-1

relational databases 169-72, 210
benefits and limitations 171

data duplication problem 180
data typesused in 1/7-9
table construction 180
relationships, entities 1/0-1, 175-6

rendering 5, 7
repealing groups, databases 182
repetition 366—71
for loops 369-71, 454
while loops 3669
replication, databases 229, 232-3
resource allocation 81, 82
resource contention 83

resource management /0
resource monitoring/limits 82
response codes, HTTP 116
retail environment

databases 167
wireless access points 113
RGB colour model 48

right child property 568
risk mitigation, Al systems 313
RL see reinforcement learning
RLE see run-ength encoding

intersection, sets 575

RNNs see recurrent neural networks

isinstance function 4/9-80
library 375
library class code 428-30

robotic vacuum cleaners 285
robotics navigation 2434
rollup function 222
rollback 71, 213
ROM see read-only memaory

linear search 382, 460

linked lists 557, 561-3, 566-7
lists 350, 352, 353, 357
method headers 441

flowcharts 328, 331, 332-3
functions 371-5
incorrect inputs 362
infinite loops 362

minimum value 395
move method 488-91
multiple classes 514-16
observer design pattern 539-40
paramelers 373
quicksort 403
random library 374

first in, first out data structure 359-60

quantization 48-9
quantum computing 311
quantum, scheduling 77
queries, in SQL see SQL (structured query
language), queries
queuves 359-60, 551
quicksort 400-3

round robin, scheduling 76, 77, 78

route planning 289-91
routers/routing 110-12, 114, 151
algorithms 127
dynamic routing 152-3
static routing 152, 153
subnetting 140
routing table (data file) 151, 152

output, control systems 84
output specifications 3201
overfitting 227, 260, 277-8
overwriting, file code 408

last in, first out data structure 358-9

recursion in 405

libraries 374, 375

selection sort 390, 392

runner class 440, 444

linear search 381-2
lists 350, 351-8
looping structures 36671
maximurm,/minimum value 395-6
modules 371-5

selection statements 365, 4534

F2P see peer-lo-peer model
Paas5 see platform as a service
packets 70, 75, 110
data segmentation 149-51

runtime polymorphism 484-91
Rust, translation steps 93

routers 111-12

PANS see personal area networks
parallel processing 5,6, 7,10, 23

parameters 372-3, 441
parsers 90
parsing, stacks 359
passwords 157
patch management, software 71,157
pattern recognition
artificial neural networks 296-8
computational thinking 323, 325-6,
330,331
PC see program counter
peek method, stacks 358, 359

notation 63

parameters 372-3
queues 359-60
recursion 396406
repetition 366-71
scalability of algorithms 376-80
search for data 380-5
selection sort 385, 388-92
selection statements 363-6

sequence of code 362
sorting 385
slatic data structure 3501
strings 337, 338, 339-40
summing 393

sets 573, 575
singleton design pattern 5267
sorting 464
static polymorphism 484
strings 337, 340
subset checks 575
summing 393
trace tables 345
translation steps 92
tuples 357
two-dimensional lists 357
union, sets 575
variable modifiers 437

variables 338
whileloop 367
quadratic algorithms 377
Quality of Service (QoS) rules 109

rows, in databases 205

run-length encoding (RLE) 28, 30, 31

Saal see software as a service
sales reporting 222
sampling 48, 49
sandboxing 68
Savepoint command, S0L 213
Scanner class, Java 41011

scheduling 70, 73, 76-8, 82-3
first-come, first-served 76, 77,78

linked lists 553
multilevel queve scheduling 76,
77,78
priority scheduling 76, 77, 78
round robin 76, 77, 78
schemas, databases 171, 173-5, 210
scheme 117

scientific computing 8

615

Index

search/searching
456-63
binary search trees 569

sort/sorting
bubble sort 385, 386-8, 46472
definition 385
selection sort 385, 388-92

linear search 381-2, 455-6, 460

sound waves 48, 49

binary search 382-5, 398-400,

linked lists 554, 558, 564
second normal form (2NF), databases
183, 184
secondary memory storage 24-7
secure socket layer (SSL) certificate 157
security
Al systems 308
applicationevel security 155
data security 231
dala transmission 148
databases 171
in distributed systems 106
edge computing 107
employee training 1589
file systems 70
internal threats 155

interrupts and polling 79
machine leaming 308
mail servers 130
mobile networks 107

network segmentation 137
operating systems 67, /0, 71,
73,75
sequential pattern discovery 228
web interactions 117
see also network security
security systemn, logic gates for 52
security testing 158-9
segmentation 82
data segmentation 149-51
network segmentation 136-43
Select command, SCGL 196

selection bias 227
selection sort 385, 38892

spam email 130, 157
spatial databases 216
SQL (structured query language)
adding and modifying records ina
database 205-6
aggregate functions 206-9
Average 206-7
Count 207
Maximum value 208

Minimum value 208
Sum 209
dala language types 191-4
database development 193-5
altera table 194
create a database 193
create a table 1934

delete a lable 194
modify data in a able 195
malicious SQL statements 156
queries 195-204, 210
And command 202
Between command 198
Distinct command 196

filtering 195
From command 197
Group By command 199
Having command 200
Join command 200-1
Like command 201-2
Mot command 204
Or command 203

Order By command 198-9
pattern matching 195
Select command 196

selection statements 3636

Where command 197

semantic analysis 92, 93

transaction control language
Commit command 213

semantics 90
sensors 86
sentiment analysis 244-5
separate chaining 577
sequential pattern discovery 226-8
servers 127-33

Rollback command 213

Savepoint command 213
Start Transaction command 213
update operations 204-6
virtual tables in databases 209-10

distributed databases 234

55Ds see solid state drives

domain name system server 12/-8
dynamic host configuration protocol
server 128-9

S5H (Secure Shell) 161
551 see secure socket layer certificate
stacks 358-9

mail servers 130
proxy servers 131

standard library 90
standardization, data preprocessing 256
star topologies 124-5, 126

web servers 131-2

Start Transaction command, SQL 213

file servers 129-30

sets 572-6
implementation of 578
mechanics of 577-8
set operations 573, 578
signatures, digital 161
signed integers 47
SIMD instructions 9, 10
simulations 8

single-core processors 5, 22
singleton design pattem 523-7
singly linked lists 554-7
Skype 32,136
5L see supervised leaming
slice function 222
slice, scheduling 77
slope, linear regression 265-6, 267
smartphones 129, 324, 480

social media 167, 223,227, 311, 576
society, and Al systerns 308, 313
software
digital signatures 161
firewalls 109
network security 156, 157
patch management /1, 157
portability 95
software engineering 96, 330, 522, 550,

580
software as a service (SaaS) 31-3, 35, 36
solid state drives (SSDs) 25-6

SurveyMonkey 32
switches 112-13, 114, 151

symmetric cryptography 159-60, 160-1
syntax analysis 92,93
synthetic data 266
system bus 20
system integrity 69
system logs 71-2, 74, 407

task management 67, /2, 553

task scheduling see scheduling
1CL see transaction control language:
TCP see transmission control protocol
TCPF/IP model /5, 118-23
network device mapping to layers
114
role of layers 119
telecommunications, modems 110

temporal locality 14
tensor processing units (TPUs) 249
thermostats 87
third normal form (3NF), databases 184,
185-8
Thompson sampling 287
thrashing 83
threads, process 69
time penod data 221
TL see transfer learning
topologies see network topologies
toString method, Java 431, 476-7, 484, 485

TPUs see tensor processing units

transactions, databases 211-14

transducers 86
transfer learning (TL) 238, 240, 241, 245
transform coding 30, 31
transformers, deep leaming 241
transistors 51
translation, interpreters
and compilers 90,
92
bytecode interpreters 95
compiled programming languages
93,94, 96
interpreted programming languages
91-2,95, 96
just-in-time compilation 94
uses of 96

static routing 152,153

transparency

subnet masks 118, 137-138, 141, 142,143
subnetting 13/7-40
subset checks 574, 575

Sum function, SQL 209
summing 393
superclasses 4/3, 474
move method 488-9
toString method 485
variables and methods 4/5-6, 4/8

supenvised leaming (SL) 238, 240, 241,
242,244
classification techniques 268-75
hyperparameter tuning 2758
support vector machines (SVM) 304

unified memory architecture 10, 11
union, sets 5/4, 575, 578

universal modelling language (UML) 423
unnormal form (UNF), databases 182, 183
unsigned integers 4/
unsupervised learning (UL) 238, 239
clustering techniques 279-82
update management/operations /1, 204-6
upper confidence bound (UCB) 287
USB flash drives 27
user-based collaborative filtering 271-2
user datagram protocol (UDP) 115
user interface (Ul) 67
user mode (user space) 70
user permissions /0
validation rules, databases 231

variables 337-8, 418, 491
casting 441
modifiers 436, 437, 438, 441, 475
static and non-static variables 425-30

transmission control protocal (TCP) 115
transmission control protocol /intemet
protocol (TCP/IP) madel 114, 118-23

variables and methods 475, 47/6-9

Unicode 47, 50

instance variables 418

static polymorphism 481-4

move method 486-91

for a superclass 474
underfitting, machine leaming models 278
undo functions 359

factorial numbers 404
surn of all natural numbers 405
traffic monitoring, firewalls 155
traffic signal control systems 88, 106
training data 224, 238, 307, 308-9
transaction control language (TCL) 192,
212,213

static data structure 3501, 442
static IP addresses 118, 146

factory design pattern 529, 531, 533

singleton class 524
subclass use with an abstract class

trace tables 344-5

translation time 94,95

abstract classes 493, 494-6, 498-9

if staternents 517

493

tables, databases 170, 180, 193-4, 195

starvation (indefinite blocking) 77, 82, 83

static variables 425-30
step-by-step code execution 348
strings 4/-8, 337, 338, 33940
data types 178, 1/9
reversing 359
structured query language see SQL
study skills 608-10
subclasses 473

UL see unsupervised leaming
UML class diagrams 423-5, 426
composition relationships 506
design of classes 431
encapsulated class 437, 438

Al systerns 308, 313
distnbuted databases 231-2

subclasses 475, 4769
superclasses 4/5-6, 478

video, binary encoding of 49-50
video editing 8
videogames 7, 93, 325, 548, 549

video random access memory (VRAM) 7
views [virtual tables) 209-10
virtual local area networks (VLANs) 140-1
virtual machines (VMs) 34, 74, 75
virtual memory 14, 72, 73, 82

virtual private networks (VPNs) 103, 158,
162

virtual reality (VR) 312
virtual tables, databases 209-10
virtualization 34, /4-5
VLANSs see virtual local area networks
VMs see virtual machines

vocabulary skills 609
Voice over Internet Protocol (VolP) 108
volatile memory 12
VPNs see virtual private networks
VR see virtual reality
VRAM see video random access memoaory
WANs see wide area networks
WAPs see wireless access points
washing machines 8/-8

transport layer, TCP/IP model 119, 120,

web servers 131-2

122-123
travelling salesperson problem (T5F) 289-91
genetic algorithm for 291
traversal, linked lists 554, 558, 564
truth tables 53-4, 54-61
Boolean expressions with inputs and
outputs 56-7
derived from logic diagrams 5/7-8
determining outputs from inputs fora
problem description 54-6
simplifying output expressions with
Boolean algebra and K-maps 58-61
try staternent, error handling 342-3
5P see travelling salesperson problem
tuples, Python 357
twisted pair cables 147,148
two-dimensional (20) lists 351, 354-6, 357,
447-50
two’s complement, signed integers 4/

website navigation 227
Where command, SQL 197
while loops 366-9
whitelists 157, 159
wide area networks (WANs) 102
Windows, Task Manager 553
wireless access points WAPs) 113,114

UCB see upper confidence bound
UDFP see user datagram protocol
Ul see user interface

wireless network mesh 113

wireless technology 147, 148, 159
worldwide web (WWW) 104, 115,117
wrapper methods, feature selection 257-8
write signal 20
writeback phase 23
XNOR gate 54
XOR gate 54
X55 see cross-site scripting
zero-day exploits 156
Zoom 32

Oxford Resources for IB
Diploma Programme

2025 EDITION

COMPUTER
SCIENCE
COURSE COMPANION
Written by expert and experienced practitioners, and developed in cooperation
with the IB, this DP Computer Science course book provides:
e«

A comprehensive and accurate match to the latest IB DP Computer Science
specification, delivering in-depth coverage of all content for both SL and HL

o

Fully accessible code in both Python and Java, and advice for learners new
to coding

«

Engaging real world examples, activities and questions, to apply
computational thinking and programming skills

e

Thorough preparation for IB assessment, with dedicated sections for the
internal and external assessments, plus exam-style practice questions at the
end of each topic

e

Complete alignment with the IB philosophy, with ATL skills and Theory of
Knowledge support woven throughout.

To enhance your teaching and leaming experience, use this course book
alongside your Kerboodle course. Kerboodle is a digital learning platform that
works alongside your print textbooks to create a supportive leaming environment
and to enable success in DP and beyond.

20

evamON

>

.
-

‘l!'

COMPUTER
SCIENCE

QHFORD

9781382063975

UNIVERSITY PRESS

WWW.oup.com

email
tel

i
=
/ib
schools.enquiries.uk@oup.com
+44 (0)1536 452620

I

C

|


B4 End-of-topic questions. ... ... 581

Answers: www.oxfordsecondary.com/ib-compsci-support

Introduction
The Diploma Programme (DP) computer science course is designed for students in the 16 to 19 age group. The
curriculum seeks to examine key concepts in computer science: computer fundamentals, networks, databases and
machine learning, and then apply practical skills to support the computational thinking process to solve problems. As
with all the components of the DP, this course fosters the IB learner profile attributes (see page vi) in the members of
the school community.

Syllabus structure
Topics are organized into two separate themes:
*

Theme A: Concepts of computer science

*

Theme B: Computational thinking and problem-solving

These themes represent the connection between abstract ideas of how computing system operate (Theme A) and
their application using the practical skills of computer science to solve problems through the process of computational
thinking (Theme B).
Theme A: Concepts of computer science

Theme B: Computational thinking and
problem-solving

