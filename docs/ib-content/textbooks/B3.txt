B3 Object-oriented programming (OOP)

(®Tok
Are some types of
knowledge less open
to interpretation
than others?
The structured nature
of OQP, with its
defined classes and
behaviours, might
suggest it is less open
to interpretation
than more flexible
paradigms like
procedural
programming.

B The advantages and disadvantages of using OOP in various
programming scenarios
There are numerous advantages to using OOP in your programming, including:
Increased modularity: Designing programming code around data and the functions that
manipulate it can make it easier to manage large code bases. Objects can be created and
modified independently of each other.

Code reusability: A class, once written, can be imported into other projects and reused
many times.
Encapsulation: Hiding the internal mechanisms through which a class manages its
internal data means that programmers only interact with the class through its well-defined
interfaces, such as publicly exposed functions, and don’t attempt to access the internal data
directly. Programmers trust the class to know how to update its own internal data. This

helps prevent unintended consequences resulting from managing data directly.
Scale: By allowing increased modularity and reusability, OOP allows projects to scale in
size yet remain maintainable.
Collaboration: Increased modularity also increases the ease for delegating ditferent parts of
the project to different team members, allowing more people to work on the same project
with ease.
It is worth acknowledging that OOP is not a perfect solution to all programming problems.
There are some potential drawbacks to be aware of, including:
Learning curve: OOP-related concepts, such as classes, objects and inheritance, can be
difficult to understand for beginner programmers.
Increased complexity: Small problems where a procedural approach would suffice can
become unnecessarily complex to implement in a purely OOP approach. This complexity
can also make projects more challenging to debug and maintain.

(;Common
mistake

Overuse: OOP is good at solving certain types of problems, but it is not a one-sizefits-all solution. Attempting to force everything to be viewed as an object of a class can
result in deep inheritance hierarchies, leading to code that can be difficult to understand

Not thinking in
objects: OOP requires
a mental shift in
how to approach
your programming

and maintain.

problems compared

modularity. That comes at a cost in terms oforganizing code into constructs that are more

to procedural
programming. It is
very easy to fall back
into old habits. Try
to practise abstract
thinking and simplify
complex real-world
itemns into classes. It
can be hard to figure
out what should be
an object, a class or a

method at times, and
it will take practice to

get right.

Overhead: OOP will typically introduce additional overhead in time and space
requirements compared to using paradigms with less abstraction.
Lack of optimization: The focus of OOP is on providing abstractions to improve
efficient for the CPU. In performance-critical applications, lower-level paradigms may be
more suitable.
Object-centric design limitations: OOP’s focus on objects can sometimes lead to
design limitations when dealing with certain problem domains. Some problems may
be better modelled using alternative paradigms, such as functional programming or
procedural programming.
So, while an important and valuable tool for any programmer, OOP is not a magic solution to
all programming needs.
T

A

T

TR

T

@ Linking question
.
.
. Is OOP necessary for all programming or just in the modelling of complex situations? (B2)
T
T PP

B3.1 Fundamentals of OOP for a single class

Bank accounts
To begin, study an example of how code that uses OOP may look. The following code is
based on a scenario of Bank Accounts. The process of creating variables (known within OOP

as “objects”), and then performing simple tasks with them, could be enacted through the
following code.

Python
amy = BankAccount ("Amy")
brian = BankAccount ("Brian")
clare = BankAccount ("Clare")
# Do some transactions
amy.deposit (100)

brian.deposit
(200)
clare.deposit
(150)
amy .withdraw
(75)

brian.deposit
(75)
brian.transfer
(250, clare)
# Print account info
print (amy)

print (brian)
print (clare)

Java
class Main {
public static void main(String[]

args)

{

BankAccount amy = new BankAccount ("Amy");
BankAccount brian = new BankAccount ("Brian");
BankAccount clare = new BankAccount ("Clare");

// Do some transactions

H
H
HH
HH
HH

amy.deposit
(100) ;
brian.deposit
(200) ;
clare.deposit
(150) ;
amy.withdraw(75)
;
brian.deposit
(75);
brian.transfer
(250, clare);

// Print account info
System.out.println{amy);

System.out .println(brian) ;
System.out.println(clare);

B3 Object-oriented programming (OOP)

Notice that, without having to know anything about how these objects manage their internal
variables, you can understand the expected behaviour and reasonably estimate the output,
which may resemble the following:

Account “Amy" has balance $25
Account “Brian” has balance $25
Account “Clare” has balance $400

This is OOP at work. It allows you to create data types and write functions that are attached to,
and have access to, the information stored within.

B3.1.2 Designing classes, their
methods and behaviour
Before writing code, it is important to introduce the idea of the

UML Class diagram. “UML"

(Unified Modelling Language) is the umbrella term for a series of standardized diagrams used
within Computer Science. These have been established to provide consistency in the design of

computing projects. One diagram within UML, the Class diagram, is used [or articulating the
design of an OOP Class.

A UML Class diagram looks like a table in three rows.
B Row 1: The Class name is specified in the top row for identification purposes.
B Row 2: The variables within each instance are listed in the second row, along with their

data type.
B Row 3: The methods associated with the Class are listed in the third row, including their

(;Top tip!

parameter signatures and return data type.

Use your UML

Compare the following tables to clarify. The left example provides a generic outline of

diagrams. UML

the Class diagram, whereas the example on the right could be an implementation of the

diagrams are your
blueprints. Sketch out
your Classes and their

relationships before
writing code. This may
seem unnecessary
at the start, but it

is a useful habit to
form early that will
pay dividends when
you are devising
increasingly large and
complex projects. As

BankAccount Class.
Classname

BankAccount

+ field: type

— name: string

+ field: type

—balance: float

+ field: type

+ BankAccount(name)

+ method(type): type

+ deposit(float): void

+ methoditype): type

+ withdrawf(float): void

+ methoditype): type

+ transfer(float, BankAccount): void

M Template and example of a UML Class diagram

Within UML Class diagrams, a final important element to note is with respect to visibility.

you do, start with

Notice that each element is preceded by a plus or minus sign. This indicates whether the

the basic classes
that form the core
of your project and
then expand as

element should be set to public (plus sign) or private (minus sign). This will be discussed

needed. Don't try

to add everything
at once as you will
overcomplicate it.

further as part of B3.1.5 in the topic of encapsulation.
UML Class diagrams can also be used to depict relationships when classes are dependent on
one another. This is discussed further in B3.2.4.
You are expected to be able to create UML Class diagrams for classes trom code, and construct
code for a Class from its
this chapter.

B3.1 Fundamentals of OOP for a single class

UML. There are practice exercises for you to complete at the end of

B3.1.4 Coding classes and instantiating objects
B Creating the class
Instantiation is the process of creating a specific instance of a class, which is called an “object”.
There are two key tasks pertormed as part of the instantiation process: the allocation of

# Instantiation:

the line of code that
declares a new object
variable based on the
template code provided
by a class, which then

memory for the new object, and the execution of the constructor method.
The constructor is a special method whose role is to initialize a new object, with a specific

focus on any instance variables within the object. In Java, the constructor is identified by a
method having the same name as the class. In Python, the constructor is identified by the

executes the constructor

to initialize the object.

name __init__ (). The constructor doesn't have a return type (technically, it is returning

4 Constructor:
a special method
within a class that is
automatically executed
during instantiation;
its main task is to
initialize any instance
variables required before
an instance of the
object can be used by
other code.

the initialized object).

In Java, the this keyword is used to refer to the current object instance of the class. Tt
can be used to prefix any instance variable or method. It is particularly useful as a way of

differentiating between instance variables and local variables that may have the same name.
The this keyword is optional unless ambiguity exists, such as needing to differentiate
between an instance variable and a parameter variable.
In Python, the self keyword performs the task of referring to the current object instance
of the class. The self keyword is mandatory to prefix an instance variable or method.
Additionally, self must be listed as the first parameter for all methods belonging to the class.
When calling these methods in your code, you do not need to pass anything for that value;
Python will do it for you.
To illustrate the syntax of constructing classes in Java and Python, the following will serve
initially to construct the BankAccount example.

(;Tup tip!
VWhen naming your classes, it is standard practice to use a singular noun that represents the entity
the template represents. The methods (or functions) within that class should then be named as

verbs, indicating the action they will perform on the objects of the class.
In addition, the naming convention dictates the following for upper- and lower-casing of names:
® Class names: Capitalize all words (e.g. MyClass, BankAccount)
B Object instances: Camel case in Java (e.g. myObject) and snake case in Python
(e.g. my_object)
B Method names: Camel case in Java (e.g. calculateTotal) and snake case in Python
(e.g. calculate_total)

B Instance variables: Camel case in Java and snake case in Python.
o

S

is

i Python
:
:

class BankAccount:
def

init_ (self,

name):

1

self .name = name # Create an instance variable "name"

:

# and set

:

self.balance = 0.0 # Set instance variable "balance" toc 0.0.

:
:
:
:
L

it

to value parameter variable "name".

def deposit(self,

amount):

self
. balance = self.balance + amount
def withdraw(self,

amount):

self
. balance = self.balance

- amount

1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
-

B3 Object-oriented programming (OOP)

amount,

L|

def transfer(self,

recipient):

self.withdraw(amount)

recipient.deposit (amount)
def _str

(self)
:

return f"Account {self.name} has balance ${self.balance}"
B

T T T

T LT T

T T

T

T LT T

PP PP

TS

Java
public class BankAccount {
private String name;

// Create an instance variable

private double balance;

// Create an instance variable

public BankAccount (String name)
this.name = name

{

// Set instance

'name'

to value of parameter

'name'’

this.balance = 0.0;

}
public wvoid deposit (double amount)
balance

{

balance + amount;

1
public wvoid withdraw(double amount)
balance

{

balance - amount;

}
public wvoid transfer (double amount, BankAccount recipient)

{

this.withdraw(amount);

recipient.deposit (amount) ;

}
publiec String toString()
return "Account

}

"

{

= this.name +

" has balance $"

+ this.balance;

}

B Creating an object
Creating an array is the process of declaring and instantiating an object variable based on the
class type. It is at this point that you pass any parameters required by the constructor.
The following example creates an instance of an object using the identifier name acc, of the
type BankAccount. You can treat acc just like any other variable from that point onward.

e T 3 penspes sy

g ......................................................................................................... f

i Python

1

! # Python

.

! public class Main |

: acc = BankAccount ("Neo")

:

E

:

:

§

BankAccount acc = new BankAccount ("Neo") ;

E

[
————

T

System.out.println(acc);

:

print (acc)

Java

B3.1 Fundamentals of OOP for a single class

:

public static void main(String[]

:
args)

({

i

B Creating an array of objects
When initializing an array of objects, it is important to note that each individual object still
requires its constructor function to be executed. This may require iterating over the entire

array to explicitly execute the constructor on each element. Some examples based on the
BankAccount scenario follow.

(;Top tip!
Because arrays contain multiple objects, their names should always be a plural of the object

contained within. In this case, it could be bankaccounts (Java's camelCase) or bank_accounts
(Python's snake_case).

Python
# Python - example 1
accounts =

[

BankAccount ("Amy"),
BankAccount ("Brian"),
BankAccount ("Clare")

1
# Python - example 2
accounts =

[]

for i in range(0,

3):

name = input ("Name for new bank account:")
accounts.append( BankAccount( name

)

)

// Java - example using static array
BankAccount []

accounts = new BankAccount [3];

accounts [0]

new BankAccount ("Amy")} ;

accounts [1]

new BankAccount ("Brian") ;

accounts [2]

new BankAccount ("Clare");

// Java - example

String[]

iterating over static array

names = {"Amy",

"Brian",

"Clare"};

BankAccount
[] accounts = new BankAccounts[3];
for

(int i=0;

i<accounts.length;

accounts[i]

i++)

{

= new BankAccount( names[i]

);

}
// Java - example using ArrayList
// Remember to import java.util.ArrayList
Arraylist<BankAccount> accounts = new

Arraylist<BankAccounts
() ;
accounts.add
(new BankAccount ("Amy"));
accounts.add
(new BankAccount ("Brian"));
accounts.add
(new BankAccount ("Clare")) ;

B3 Object-oriented programming (OOP)

B3.1.5 Encapsulation and

information hiding in OOP
Encapsulation is the idea that programming code outside of the class should not have direct

# Encapsulation:
bundles data and

access to the data within the class. You can visualize the data as being protected by a capsule

the methods that

wrapped around it! The only way to permeate the capsule is through the methods the

manipulate that data
together into a single
:
object. It serves to hide
the implementation

class allows.
By controlling access, encapsulation ensures that variables are only used in the manner in

details of the object

also means that you can write code that uses encapsulated classes without needing to know or

from outside code.

care how the class manages its internal state.

which they were intended, helping protect your code from invalid, error-inducing values. It

# Access modifiers:

Successful encapsulation of your classes is fundamental to facilitating modularity in object-

the mechanisms
provided by the
programming language

oriented programming.

to control visibility of

@ Linking question

i

ssssssas

methods and variables
within an object.

L R

LR T
N R LI ETY

;

How can the principles of encapsulation and information hiding (B2.5) be applied to secure
network communication? (A3)

B Access modifiers
Encapsulation is achieved through using access modifiers. The structure of access modifiers is

different between Java and Python.
In Java, the access modifier is specified by supplying the relevant keyword in front of the
variable or method definition. There are four access modifiers to know:
B Private: Indicates it should only be accessible by the current object.
B Protected: Indicates that it may be accessed by the current object, and any objects that
inherit it (more on that in B3.2.1).

Public: Indicates it may be accessible to any code within your program.
Default: When no modifier is provided, it allows access for any object within the same Java
package (as denoted by the package statement at the top of your Java file); Python does not
have an equivalent of this.
In Python, access modifiers work slightly differently. They are specified through a naming
convention for your variables and methods. They can be bypassed. In this sense, they are
more guidelines than rules. That said, for the purposes of your course, you should avoid
bypassing them.
® Public: The default behaviour is thart variables and methods are treated as public.

B Internal use: The single underscore prefix (e.g. variable) is used to indicate it is
only for internal use within the class. While this is purely a convention, and the Python

interpreter does not enforce it, most Python editors strongly hint at not using these
variables by hiding them or making them less visible.
® Name mangled: The double underscore prefix (e.g.

variable) is used to instruct the

Python interpreter to rename the variable or method at runtime. The name is mangled to
include the class name, which makes it harder (but not impossible) to access from outside

the class. For example, variable ina class named MyClass would be mangled to
_MyClass__variable.

B3.1 Fundamentals of OOP for a single class

This might seem like it makes a variable private, but Python doesn’t have truly private
variables. Name mangling was created to avoid naming conflicts, rather than to enforce strict
access control. The mangled name can still be accessed from outside the class; it just requires
knowledge of the name-mangling pattern Python uses.
For the purposes of your course, you can treat either the single or double underscore prefix as

denoting private, but ensure you are aware of the technical subtleties involved.
B Accessors and mutators
By setting your variables to private, the inevitable consequence is you will need to create a

number of public methods through which code outside your class can interact with those
variables, query their value or request they be updated.
# Accessor: a public
method that allows
external code to
“access” the value of a
private instance variable

Methods that perform these tasks are formally known as accessors and mutators. They are
also often referred to as getters and setters.
For instance, if a Person class has variables for name and age, then there may be accessor

methods getName () and getAge (), as well as mutator methods setName () and setAge ().

within an object; also

Crucially, the example above serves to reinforce the important role that encapsulation can play

known as “getter
method” as it "gets”

in protecting your data. You may not want it to be so easy to update a person’s name in your
application, and the person’s age may be calculated behind the scenes using the current date

the value.

and a stored date of birth, rather than just being stored as an integer that will soon drift to

# Mutator: a public
method that allows
external code to update
or mutate the value of a
private instance variable
within an object; also
known as “setter
method” as it "sets”
the value.

being out of date.
Requiring accessor and mutator methods, rather than giving external code free access to your
variables, allows separation of responsibilities and keeps the class in control of what happens
to its data.

(.-Top tip!
For beginner programmers, the following is recommended good practice:
B Set variables to private where possible. Create accessor and mutator methods for any
attribute you want external code to have access to.
B Methods (or functions) should be public if you want external code to have access to them. If
the method is an internal helper function, set it to private.
Study the updated code for the Bank Account scenario in Section B3.1 to see inclusion of
access modifiers.

Research skills and thinking skills: Code analysis
Operation sabotage! Take a piece of OOP programming code and insert some deliberate
errors into it that break the principle of encapsulation. Swap with a classmate, and
refactor the code you are given to ensure proper use of encapsulation again. Discuss and
compare changes with your classmate afterwards. Did you both spot all the errors and
apply appropriate corrections?
4 Static: methods and
variables that belong
to the class, not the

individual objects. Only
one copy is created
that is shared with all
instances in common.

B3.1.3 Static and non-static
variables and methods
The term static is used to represent variables and methods that are associated with the class
itself rather than any individual object instances.
B3 Object-oriented programming (OOP)

Static variables and methods don't require an instance to be created for them to exist. They
are created by the interpreter / compiler at runtime when the class is defined. This is why
the main function in Java is defined as static, as it needs to exist and be executed before any
objects have been created by the code itself.
Because statics do not depend on an object having been instantiated, it does mean that no

static method may access instance variables within an object. It also means that any time an
instantiated object makes use of a static variable or method, the objects are all accessing the

same shared variable or method instead of their own instance of it. Consequently, should an
object change the value of a static variable, that change will be visible to all other objects. You
can think of a static variable as a global variable that is shared in common with all the objects
of thar class. Static variables come in useful when somerhing needs to be shared across all
objects within a class, or when the particular variable does not depend on an instance existing.
The term “non-static”, therefore, refers to the normal instance variables you have been

defining within objects up until this point. Each object creates its own unique instance of
these variables so, when used by one object, it does not affect the value stored in the matching
variable of another object.
‘When referring to static variables and methods in code, it is best practice to prefix it

with the class name, for example ClassName . variableName (see the examples in
BankAccount below).

Using a static variable to track ID values
One common scenario for using a static variable is to ensure each object of a class has a unique
1D number. An example might be product numbers for a supermarket application.

E Python

E

: class Product:

:

:

next product id = 0 # define a static wvariable

:

1

def

]

:
:
:

i

init

(self,

name):

self.name = name
self.product
id = Product.next product_ id

:
:

Product.next product id += 1

:

def _ str(self):

:

!

return "Product

"+str(self.product
id)+": "+self.name

:

: if name == "_main
":

:

:

[

:

1

products =

Product ("Bread"},

1

'

Product ("Milk"),

i

:

Product ("Apples"),

:

Product ("Icecream")

:

:
1

1
:
:

]

1

for i in range (0,

len(products)):

print (products[i])

B3.1 Fundamentals of OOP for a single class

[
:
:

! class Product |
private static int nextProductID
// wvariable

0;

// define a static

private String name;
private int productid;
:

Product (String name)
this.name = name;

this.productID

Product .nextProductID;

Product .next Product ID++;

}
public String toString()
return "Product "+Integer.toString(this.productID)+":
"+this.name;

}
class Main {
public static void main(String[]

args)

{

Product
[] products = new Product[4];

products [0]

= new Prcduct ("Bread");

products[1] = new Product ("Milk");
products[2]

= new Product ("Apples");

products [3]

= new Product ("Icecream");

for

(int i=0;

i<products.length;

i++)

{

]

};

—

System.out.println( products[i]

H

Using a static variable to track number of items in array (Java only)
In Java, another common usage of static variables is to keep track of the number of items
populated within an array. Given arrays are fixed in size, the static variable can be used to
ensure you place the next item at the next empty location. This is less of an issue in Python
since static arrays are not really a thing, and the list construct is dynamic in size.

Alternative approaches to this would be:
B having an if statement testing for null inside a loop
B using an ArrayList, since it is dynamically resizable.

B3 Object-oriented programming (OOP)

Here is an example:

class Thing {
private string name;
Thing (String name)

{

this.name = name;

public String toString()

{

return this.name;

}
class CollectionOfThings {
private static int nextThing = 0; // static variable
private Thing[]

things;

CollectionOfThings
() {
things = new Thing[100];
// null Things

// Create an array of 100

CollectionOfThings.nextThing = 0;

(;Top tip!
Remember that static
means one shared
item for the class, not
individual instances.
Only use static
for things that are
common to all objects
(like a company name),
and use normal, nonstatic for properties
spedific to an instance
(like an employee

}
public void add(Thing t)

{

things|[Collecticon.nextThing]

= t;

CollectionOfThings.nextThing++;

}
public wvoid remove (Thing t)

{

boolean found = false;
for

(int i=0;

i<CollectionOfThings.nextThing-1;

if (things[i].equals(t))

{

i++)

{

found = true;

}
if

number). Experiment

(found)

({

things[i]

with writing code
snippets to see the
effect of changing
members from static

= things[i+1];

}
if

to non-static, and

(found)

{

CollectionOfThings.nextThing--;

vice versa

}
@ Linking
question

public void printAll()
for

In what ways can
QOFP (B1) be applied
to database (A3)

development?

B3.1 Fundamentals of OOP for a single class

(int i=0;

i<CollectionOfThings.nextThing;

System.out.println(things[i])

;

i++)

{

B3.1 End-of-section examples

Social skills: Paired programming
Paired programming is a research-based approach to help develop confidence in
beginner programmers. Work in pairs to design and implement your programming
projects, with one student writing the code while the other reviews it and suggests
improvements, switching roles periodically. Consider the analogy of having both a driver
and a navigator at the computer keyboard.

Hl Bank accounts
See below for the full code for the Bank Accounts scenario, updated to illustrate initialization
of an array, use of access modifiers and static with non-static variables and methods.
Notice two static variables and one static method have been implemented:
B

interest rate: Asall bank accounts will have the same interest rate, it makes sense
for this to be static. That way, it only needs updating once, and all bank accounts will
automatically apply the change.

B next account number: By checking and incrementing this value every time an object
is created, it can ensure that no two bank accounts have the same account number.
®

find(): Provides functionality to search an array of BankAccounts to find one of the

requested name (supplied through the parameters).
"

Python
class BankAccount:
interest rate = 5.00 # Static variable
next account number = 1001 # Static variable
def

init

(self,

name):

self. name = name
self. balance = 0
# Use the class name as a prefix to access the static variables

self. account number = BankAccount.next
account number
BankAccount
.next account number += 1
def deposit(self, amount):
self. balance += amount
def withdraw(self, amount):
if self. balance < amount:
return False

self. balance -= amount
return True
def transfer({self,

amount,

recipient):

if self.withdraw(amount):

recipient.deposit (amount)
return True
else:

return False

1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
:
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1

4

B3 Object-oriented programming (OOP)

r

-

1
def apply interest (self):
1
]
self. balance += self. balance * (BankAccount.interest
rate / 100)
1
1
def get balance(self):
1
1
return self. balance
1
1
def get name(self):
1
1
return self. name
1
def
str
(self):
1
1
return
f'"Account
{self. account number}: {self. name} has balance
1
] S{self. balance}"
1
1
@staticmethod
1
1
def find(accounts, name):
1
1
for acc in accounts:
1
if acc.get_name() == name:
1
1
return acc
1
1
return
None
# No matching account found
1
1 # Example usage:
1
1 if
name
== "
main
":
'
:

# Tnitialize a list with 3 accounts

:

accounts =

1

[BankAccount ("Amy"),

1
1
1
1
[
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1

:

BankAccount ("Brian"),

BankAccount ("Clare")]

# Perform some transactions

:
1

1
1

accounts [0] .deposit (500)

1
1

:

accounts [1] .deposit (500)

:

:

accounts [2] .deposit (500)

:

:

accounts
[0] .transfer (150, accounts[2])

:

:

# Apply interest to all account balances

:

:

for acc in accounts:

:

1
1

acc.apply interest
()
-

1

# Perform transaction using a static method to search the list

1

amy = BankAccount.find(accounts,

:

if amy:

1

:

"Amy")

1
1

1

1
f
:

amy .deposit (42)

:

:

# Print balances using the str methed

:

:

for acc in accounts:

:

1
1

print (acc)

1
1

-

a

public class BankAccount {
private static double interestRate = 5.00;
private static int nextAccountNumber

//

1001;

static variable
// static wvariable

private String name;
private double balance;

H

H
H

H

b

B3.1 Fundamentals of OOP for a single class

H

H

H

H

H

private int accountNumber;

public BankAccount (String name)

{

this.name = name;
this.balance = 0;
// Use the class name as a prefix to access the static variables
this.accountNumber = BankAccount.nextAccountNumber;
BankAccount
. nextAccountNumber++;

}
public void deposit(double amount)

{

balance += amount;

}
public boolean withdraw(double amount)
if

(balance < amount)

{

{

return false;

}
balance

-= amount;

return true;

}
public boolean transfer (double amount,

if

(withdraw(amount))

BankAccount recipient)

{

{

recipient.deposit (amount) ;
return

true;

} else {
return false;

}
public void applyInterest()

{

// balance is instance variable,
balance += balance *

interestRate is static wvariable

(BankAccount.interestRate/100);

}
public double getBalance()

{

H

// Since balance is private,

this public function will allow external

// code to check the balance
return balance;

}
public String getName
() {
// Since name is private,

this public function will allow external code

// to get the name
return name;

}
public String toString()
return "Account

{

"+accountNumber+'":

"4+name+" has balance $"+balance;

}
public static BankAccount find(BankAccount[]

for

(BankAccount acc
if

: accounts)

accounts,

String name)

{

{

(acc.getName (}.equals (name)})

{

return acc;

B3 Object-oriented programming (OOP)

}
return null;

// No matching account found;

}
public static void main(String[]

args)

{

// Initislize an array with 3 accounts
BankAccount
[] accounts = new BankAccount [10];

accounts[0]

= new BankAccount ("Amy") ;

accounts[1]

new BankAccount ("Brian");

accounts[2]

= new BankAccount ("Clare") ;

// Perform some transactions using array index
accounts[0] .deposit (500) ;
accounts[1l] .deposit (500) ;

accounts[2] .deposit (500) ;
accounts
[0] .transfer (150, accountsl[2]);

// Bpply interest to all account balances
for (int i=0;

i<3;

i++)

{

accounts
[i] .applyInterest () ;

}
// Perform transaction using a static function to search the array
BankAccount amy = BankAccount.find(accounts,

if

"Amy");

(amy !'= null)
amy.deposit
(42) ;

}
// Print balances using the toString()
for (int i=0; i<3; i++) {

function

System.out.println(accounts[i]) ;

B Students and grades
Here is another complete example, this time also showing the use of objects as instance variables
within other objects. In this case, each Student object contains an array of Grade objects. Study
the example and identify the use of access moditiers, static and non-static variables.
Student

Assessment

— gradeBoundaries : int[]

— assessmentMame : String

— grades : charl]

—score : double

- studentName : String
— assessments : ArrayListcAssessment>

+ Assessment(String, double)
O

— currentGrade : char

+ Student( String )
+ addAssessment( Assessment) : void
+ getAverageScore() : double

+ toString : String
M UML diagram of Student and Assessment Classes

B3.1 Fundamentals of OOP for a single class

+ getScore() : double

+ toString() : String

e e

Python
class Assessment:
assessment name,

score):

def get score(self):
return self. score
def _ str (self):

return f£'"{self. assessment name}:

{self. score}%"

class Student:
_grade boundaries =

[80,

65,

50,

_grades =

["A","B","C","D","E"]

def

(self,

init

35,

20]

student name):

self.student
name = student name
self. assessments =

[]

self.current grade = "N"
def add assessment (self,

# Default to N before any grades are added

assessment):

self. assessments.append(assessment)

R M M

# Calculate new average

average = self. get average score()

M M

# Update current grade
self.current grade =

R R R

for i in range (0,

"N" # Start with the default

len(Student.
grade boundaries)):

if average »= Student.
grade boundaries[i]:

self.current_grade = Student. grades[i]
break
def

get average score(self):
if not self. assessments:

R M

R M e M

(self,

self. assessment
name - assessment name

R R

return 0

total = 0
for assessment in self. assessments:

e

total += assessment.get_score()
return total / len(self. assessments)

e
e e

init

self. score = score

M

R M M

N A M M M M R M M R R M e

A M A A M R mm A

def

def

str

(self):

return f"sStudent {self.student name} has grade {self.current grade}"

e e

if name == "_main_
":
student = Student ("Doris")
student .add assessment (Assessment ("Test 1",

75))

student .add_ assessment (Assessment ("Homework",

student.add
assessment (Assessment ("Exam", 65))
o

print (student)

85))

1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
£l

B3 Object-oriented programming (OOP)

H

Java

H

import java.util.ArrayList;

class Assessment {
private String assessmentName;
private double score; // Score as a percentage
public Assessment (String assessmentName, double score)

{

this.assessmentName = assessmentName;
this.score = score;

}
public double getScore()

{

return score;

}
public String toString()

{

return assessmentName + ":

" + score;

}
class Student {
private static final int[] gradeBoundaries = { 80,
// Represents A, B, C, D, E
private static final char[]

grades =

{

'a',

'B',

65,

'C',

50,

35,

20 };

'D',

'E'

};

private String studentName;

HH

private ArrayList<Assessment> assessments;

H
HH

private char currentGrade;

H
H

public Student (String studentName)

{

this.studentName = studentName;

this.assessments = new ArrayListes();
this.currentGrade =

'N';

// Default to N before any grades are added

}
public void addAssessment (Assessment assessment)

{

assessments.add (assessment) ;

// Calculate new average
double average = getAverageScore();
// Update current grade
currentGrade =

'N'; // Start with the default

for (int i = 0;

i < Student.gradeBoundaries.length; i++)

if

(average »= Student.gradeBoundaries[i])

{

{

currentGrade = Student.gradesl|[i];
break;

H
H

}

H
:H

}

H

private double getAverageScore()
if

(assessments.isEmpty())
return 0;

}
double sum = 0;

B3.1 Fundamentals of OOP for a single class

{

{

H

for
H
>

(Assessment assessment

: assessments)

{

sum += assessment.getScore();

H

:
]

return sum / assessments.size();
@0verride

public String toString()
return "Student " + studentName + " has grade " + currentGrade;

}
public class Main {
public static void main(String[]

args)

{

Student student = new Student ("Doris");
student .addAssessment (new Assessment ("Test 1",

75));

student
. addAssessment {(new Assessment ("Homework",
student .addAssessment (new Assessment ("Exam",

85));

65));

System.out .println({student) ;

Self-management skills and thinking skills: Extend one of these sample projects
Using one of the sample projects provided as a starting point, add methods and variables
to provide supplemental functionality to the project. Create a checklist of skills you want
to add to the project, perhaps including the following suggestions:
B Reading and writing data to files so data is not lost between program execution.
m Adding a console user interface to provide interactivity and the capacity to use the
program to perform different tasks.
B Using a combination of static arrays and dynamic lists, as well as static and non-static
OOP methods and variables.

2

Which of the following is NOT an advantage of using OOP?
a

Reusability of code

b

Easy to debug

¢

Improved performance in all scenarios

d

Encapsulation of data

What does abstraction in OOP help with?
a

Removing all bugs from an application

b

Hiding complex implementations behind simpler interfaces

¢

Decreasing the use of memory

-8

1

Making code public to all classes

B3 Object-oriented programming (OOP)

3

4

5

6

7

8

9

In UML Class diagrams, there is a three-row box used to represent a Class. What does the
second row contain?
a

Class name

b

Methods

c

Properties

d

Statics

Which of the following is true about methods in a Class diagram?
a

They are depicted with a minus sign (=) for private methods

b

They cannot accept parameters

c

They must be static

d

They are opticnal

Which statement is true about static methods in Java?

a

They can be called on instances of a Class

b

They are called on the Class itself, not the instance

c

They can directly access and modify instance variables

d

They must return a value

What is a non-static variable also known as?

a

Class variable

b

Local variable

c

Global variable

d

Instance variable

What is the purpose of a constructor in a Class?
a

To declare variables

b

To initialize an object

c

To clean up resources

d

To return data

Which of the following declarations correctly creates an array of objects in Java?

a

ClassName[]

b

ClassName arrayNamel]

c

ClassName arrayName = new ClassName[5];

d

ClassName[]

arrayName = new ClassName[5];
new ClassName(5);

arrayName = new ClassName();

Which of the following best describes encapsulation?
a

Storing data in public fields

b

Combining data and methods that operate on the data into a single unit or Class

c

Dividing code into various functions

d

Making all methods static

10 What are access modifiers used in OOP for?
a

To define how variables can be modified

b

To name methods and variables

c

To indicate static methods only

d

To control the visibility of Class members

11 Describe one disadvantage of using OOP.
12 Explain how encapsulation can benefit a software project.
13 Explain why a static method cannot access non-static fields or methods.
14 Explain the role of the new keyword in object creation.

15 Describe an example of how private access modifiers contribute to information hiding.

B3.1 Fundamentals of OOP for a single class

1

Library system
Create a simple library system where each book can be either available or borrowed. Implement methods to manage the
state of each book and track the total count of books in the library.

Java
class Book {
private static int bookCount = 0;

srrsssessssans

i

private String title;
private boolean isBorrowed;
public Book(String title)

{

this.title = title;
this.isBorrowed = false;

:

;

bookCount++;

;

:

public void borrow()
if (l!isBorrowed)

{
{

:
:

L
P T T P P PR Crresnasres fasessassrssrRtissse

isBorrowed = true;

System.out.println({title + " has been borrowed.");

} else {
System.out .println(title + "

is already borrowed.");

}
public void returnBook()

{

// Implement logic to mark the book as not borrowed

}
public static int getBookCount()

{

return bookCount;

}
public String toString()

{

return title +

+

"

-

"

(isBorrowed ?

"Borrowed"

:

"Available");

}
public class Library {
public static void main(String[]
Book[]

;

args)

{

books = new Book[5];

books [0]

= new Book ("Java Fundamentals");

-

books[1]

= new Book("The Art of Computer Programming")
;

i

// Add more books and implement borrowing logic

a

Complete the returnBook method.

b

Instantiate more books and simulate borrowing and returning books.

¢

Print the status of all books and the total book count.

:

B3 Object-oriented programming (OOP)

2

Simple inventory system
Create a basic inventory management system for a store. Each product has an ID, name, price and quantity. Implement
functionality to add products, update inventory quantity and list all products.

¢ Java
i class Product {
private static int nextProductId = 100;
private int productId;

private String name;
private double price;
private int gquantity;
public Product (String name,

double price,

int quantity)

this.productId = nextProductId++;
this.name = name;

this.price = price;
this.quantity = quantity;

}
public void updateQuantity(int amount)

{

// Implement logic to update product guantity

}
@0verride

public String toString()
return "Product{" +

{

"productId=" + productId +
", name='" + name +

'\''

+

", price=" + price +
",

quantity=" + quantity +

mhr

)
class Inventory {
private Product[]

products;

private int size;

public Inventory(int capacity)

{

products = new Product [capacity];
size = 0;

}
public boolean addProduct (Product product)

if

(size < products.length)
products [size]
size++;
return

{

= product;

true;

}
return false;

B3.1 Fundamentals of OOP for a single class

{

{

public void listProducts()
for

(Product product
if

{

: products)

(product != null)

{

{

System.out.println(product) ;

}
public class Main {
public static void main(Stringl[]

args)

{

Inventory inventory = new Inventory(100);
inventory.addProduct (new Product ("Laptop",
§

999.99,

inventory.addProduct
(new Product ("Smartphone",

10));

499.99,

20));

// Update quantities and list inventory

:

}
}
a

Implement the updateQuantity method in the Product class to adjust the stock of a product.

b Test adding products, updating quantities and listing all products to ensure the inventory displays correctly.

B3 Object-oriented programming (OOP)

Fundamentals of OOP
for multiple classes (HL)
SYLLABUS CONTENT

> B3.2.5 Explain commonly used design patterns in OOP

B3.2.1 Inheritance and code reusability
(®TokK
How does the way that we organize or classify knowledge affect what we know?
The classification of knowledge into objects, classes and inheritance in OOP affects how problems
are approached and solved.

# Inheritance: where
a class takes a copy
of an existing class as
the starting point for
all its internal methods

Drawing from biology, inheritance is a concept that aims to ease code reuse in complex
projects. It does this by allowing construction of a class that derives (inherits) existing
functionality and properties from another, existing class. Once derived, you need only apply

and variables. These
can then be overridden

whatever custom modifications are required. The derived class is known as a “child class” or
“subclass”, whereas the origin class is known as the “parent class” or “superclass”.

and extended upon
to provide
o additional i
functionality, as required.

Consider writing an QOP application for a coffee shop. The business might have a loyalty

scheme requiring the storing of customer details in the system. It would likely also need to
store employee informarion to be able to pay them. While customers and employees would
.

Person dass

have very different functions within the program, there

* Name

would be some commonalities as well, such as name

* Phone

« Email
- * Address

.

.

and contact details. Inheritance allows the programmer
to put these commonalities into a parent class called
Person, while putting the specialist functionality into
the Customer and Employee classes. The common code
contained within Person does not need to be reproduced;

.

Customer class

Employee class .

it is automatically available for any subclass that derives

* Name

* Name

from it

* Phone

* Phone

* Email

* Email

In this scenario, the Person class would contain the

« Membership

« salary

programming code responsible for any person’s name,

* Bank account
* Supervisor

phone number, email and address. The Customer class

* Address

number
* Loyalty points
‘
* Sign-up date

* Address

.

B Inheritance

B3.2 Fundamentals of OOP for multiple classes (HL)

I
o
Z
=<
EE

By the end of this chapter, you should be able to:
» B3.2.1 Explain and apply the concept of inheritance in OOP to promote code reusability
» B3.2.2 Construct code to model polymorphism and its various forms, such as
method overriding
» B3.2.3 Explain the concept of abstraction in QOP
» B3.2.4 Explain the role of composition and aggregation in class relationships

.
)

.

,

inherits these basic properties and functions from Perscn
]

‘

and then extends upon them by adding a membership
number, the points the customer has accrued and their

@

ATNO TH

sign-up date. The Employee class likewise inherits the
basic properties and functions of Person and extends
Person

them by adding salary and bank-account details, along

.

isa

with information about an individual employee’s

isa

.

supervisor.
Emplayee

Customer
M Inheritance using UML

Drawn using UML, this inheritance relationship is denoted
via an “is-a” arrow pointing from the derived class to the
parent class.

The following code blocks illustrate how to create these three classes in code. Note

particularly that:
B in Python:
[0 the invoking of the inheritance relationship occurs through the use of parenthesis
in the class definition, e.g. class Customer (Person) creates a class Customer,
inheriting from Person
O the constructor of the superclass must still be called; this must be the first line in the
subclass constructor, achieved through super () . init ()

B inJava:
0 the invoking of the inheritance relationship occurs through the use of the extends

keyword in the class definition, e.g. class Customer extends Person createsa
class Customer, inheriting from Person
O the constructor of the superclass must still be called; this must be the first line in the
subclass constructor, achieved through super ()
O the protected access modifier will allow the subclasses to directly access the instance
variables that have been defined within the superclass.

Python
class Person:
def

init_(self, name, phone,

email, address):

self.name = name
self .phone = phone
self.email

email

self.address = address
def

str

(self):

return "Perscn:
class Customer (Person):
def

init

(self,

"+self.name
# The parenthesis indicates Customer inherits Person
name,

phone,

email,

address,

membership,

points,

signup):

# Call the constructor of the parent class
super ().

init (name,

phone,

email,

address)

# Define other instance variables specific to this child class
self membership = membership
self.points = points
self.signup = signup
def _ str (self):
return "Customer:

"+self _name+" has

"+str(self.points)+" points."

B3 Object-oriented programming (OOP)

g

e

g

S

e ey e

5 e e e

e

e

e s

g

g, e ey

S

e

L]

: class Employee (Person): # The parenthesis indicates Employee inherits Person

:

s
=

:

:

O

E

def

init

(self, name, phone,

email,

address,

salary,

bankaccount,

supervisor):

:

# Call the constructor of the parent class

:

:

super ().

:

init (name,

phone,

email,

address)

1

# Define other instance variables specific to this child class

1

:

self.salary = salary

:

:

self .bankaccount = bankaccount

:

1
1
1
]
]
1

self.supervisor = supervisor

1
1
1
1
1
1

def str

(self):

return "Employee:

"+self.name+" earns $"+str(self.salary)

L

-

(i;Toptnﬂ
When first learning how to use dates and times in Java, you will discover a multitude of different
options. New approaches have evolved as the language has matured, while the old approaches had
to be retained for the language to be backwards-compatible for older projects. Since Java 8, the
java.time package is the recommended best practice approach for managing dates and times.

i Java
import java.time.LocalDate;

class Person {
// By using protected instead of private,
// by classes that inherit Person.

these variables will be accessible

Refer to the section on access modifiers

// for more.

protected String name;

:

protected String phone;
protected String email;
protected String address;
Person(String name,

String phone,

String email,

String address)

{

this.name = name;

this.phone = phone;
this.email = email;
this.address = address;

}
public String toString()
return "Person:

{

"+this.name;

}
class Customer extends Person {

// The

"extends"

keyword indicates inheritance

private long membership;
private long points;
private LocalDate signup;

:
!
E

Customer (String name, String phone, String email,
membership, long points, LocalDate signup) {

String address,

long

// Call the constructor of the parent class

B3.2 Fundamentals of OOP for multiple classes (HL)

@

AINO TH

super (name,

phone,

email,

address);

// Initialize other instance variables

this.membership = membership;
this.points

points;

this.signup = signup;

}
@0verride

public String toString()
return "Customer:

{

"+super.name+" has "+Long.toString(this.points)+" points";

)
class Employee extends Person { // The "extends" keyword indicates inheritance
private long salary;
private String bankaccount;

private Person supervisor;
Employee (String name, String phone, String email, String address,
salary, String bankaccount, Person supervisor) {

long

// €all the constructor of the parent class
super (name,

phone,

email,

address);

// Initialize other instance variables
this.salary = salary;

i

this.bankaccount = bankaccount;

this.supervisor = supervisor;

}
@0verride
public String toString()
return "Employee:

{

"+super.name+" earns $"+Long.toString(this.salary);

}
T

T T T T Ty T

L LT LT T T

T T T T T T TT T T T T

PRI EETTT LTI TP TT P TP TP T T

(;Common mistake
Overusing inheritance can lead to tightly coupled code that is difficult to modify. Use inheritance
sparingly — only when classes share a logical and robust “is-a” relationship. If two classes do not
share enough functionality, consider alternatives such as composition.

o
(n
Zé}
NS

Research skills and thinking skills: Organize a class debate around the value of
inheritance. Does inheritance in object-oriented programming lead to better designed
and more efficient code, or does it overly restrict and limit flexibility?

B3 Object-oriented programming (OOP)

B3.2.2 Polymorphism and method overriding
# Polymorphism:
meaning “many forms”,
it allows objects
to exhibit different
behaviours based on
their specific class
implementation while
still adhering to a shared
interface or contract.

Polymorphism refers to how related objects can perform the same rask or interaction in a
different way. “Polymorphism” is another term that Computer Science has taken from biology; it
refers to something that can take many forms (poly means many and morph means change form).

Overriding occurs when a child class creates a property or method of the same name as the
parent class, thereby overriding it.
You can see an example of polymorphism occurring in the example above. The Python
str () functions and the Java toString () functions are overridden in the child classes
of Customer and Employee. Creating main code of what follows will demonstrate that it is,
infact, the

str () and toString () functions of the child classes that execute, rather

than those in the parent classes.
If str () /toString() was notdefined in the subclass, then the version that exists in
the superclass is what would be execured.

L

1
1 Python
1
1 from datetime import datetime
1
1 if
name
== "
main
":
1
1
p = Person("Jordan McFly",
:

"555 1234",

"jordan@example.com",

"1885 Brown

Estate")

:

c = Customer("Skyler Serenity",

1

Agimov Plaza",

1

e = Employee("Avery Shephard",

i

Pine Mall", 75000, "123-456-888", p)

-

print (p)

:

print (c)

1

1
1

1,

0,

"555 2345",

"skyler@example.com",

"1701

datetime.now())
"555 3456",

"avery@example.com",

"1955 Lone

print (e)

L

e

el

e

- - R el
e
e e
I

Java
import java.time.LocalDate;

class Main {
public static void main(String[]

args)

{

Person p = new Person("Jordan McFly",

"555 1234",

"jordan@example.com",

"1885 Brown Estate");
Customer c = new Customer ("Skyler Serenity",

example.com",

"1701 Asimov Plaza",

1,

0,

"555 2345",

Employee e = new Employee ("Avery Shephard",

"555 3456",

"avery@example.com",

75000,

"1955 Lone Pine Mall",

System. out.println(p);
System. out.println(c);

—

System. out.println(e);

B3.2 Fundamentals of OOP for multiple classes (HL)

"skyler®

LocalDate.now());
"123-456-888",

p);

z
o
=

I

=<

ATNO TH

These should render the following output, demonstrating the different versions of the
toString () function are executing.
Person: Jordan McFly

Customer: Skyler Serenity has 0 points
Employee: Avery Shephard earns $75000

o

B Example uses
Two examples that illustrate the benefit of inheritance

\
Password:

combined with polymorphic overriding are:

Date selector: File selector:

[Emter possword | [admmivyy

] [choose e

Email:

] o fite chosen

M Inheritance in graphical user interfaces

B

Consider the variety in input boxes available for

graphical user interfaces. The core functionality
of a text input box can be written once, and then
inheritance can be used to use that functionality as

4

Cy

the basis for more specialized input types, such as

PasswordInput, DateInput, FileInput or Emaillnput, where
N

"

some of the original code is overridden to provide the
new, specialized experience.

/

\

B Asecond example is in the area of game design. A
°

game that possesses multiple bots to play against

/

could have one generic bot with a random move

\_/

strategy. Specialized bots could then inherit this
basic code and override the strategy function, or the
abilities function.

M Inheritance in game design

B Overriding default methods
4 Overriding:
the process of
providing a different
implementation of a
method in a subclass,
which replaces the
original implementation
inherited from the
superclass.

Earlier in this section, you overrode the teString () /

str () functions in Java and

Python respectively. These are automatically called whenever the context calls for a string
value from the object, such as being used by a print () method.

There are other default method names that are handy to know about so you can override their
behaviour when appropriate. Some of these are:
B inJava:
0 equals(Object obj): checks whether another object passed to it is “equal to” the
current instance; the default implementation checks for reference equality (i.e. whether

they point to the same object in memory) — overriding this method allows you to
compare the contents of two objects for logical equality

O hashCode (): returns an integer hash code value for the object, which is used by hashbased collections like HashMap and HashSet; when you override equals (), you

must also override hashCode () to maintain the general contract for the hashCode ()
method, which states that equal objects must have equal hash codes — see Section B4.1.6
for an explanation of what this means
B in Python:

0O _ eq_

(self, other):called when the equality operator == is used to compare

two objects; overriding it allows for custom comparison logic

B3 Object-oriented programming (OOP)

0 _hash (self):returns an integer hash value for the object, and is used in
hashable collections such as sets and dictionaries; if you override _eq

, you should

also override __hash__, ensuring that objects that are considered equal have the same
hash value — see Section B4.1.6 for an explanarion of what this means
0O

1t

(self,

other),

1le (self,

other), gt_(self,

other),

__ge_ (self, other):used for comparison operators <, <=, > and >= respectively;

they are used by the sorted () function and other areas where there is a concept of an
ordering of objects
0O _ getitem

(self, key),

delitem (self,

setitem (self, key, value),

key): called to retrieve, set or delete an item using the indexing

syntax obj [key]
0O

iter (self)and next (self):used to make an objectiterable (usable in

a FOR loop, for example); iter should return an iterator object, which is typically
the object itself, and __next
_ should return the next item or raise Stoplteration to
end the iteration.
Refer to the Java and Python documentation for examples of implementing each of the
methods above, as relevant.

B3.2.3 Abstraction and abstract classes
One common way of making use of inheritance and polymorphism is through the use of
abstract classes. Abstract classes can be thought of as generic templates without any executable
code of their own. They are classes that cannot be instantiated. They are designed to be
extended by other classes.

You use abstract classes when you know that all your subclasses should have certain methods
or fields, but the implementation of these methods is inherently specific to each subclass, such

that it doesn’t make logical sense to provide a default implementation.
While it doesn't provide any functionality, the abstract class provides standardization and

consistency in the implementation of subclasses; the benefit being that anyone using your class
hierarchy will know that certain methods are always available, and any new derived classes
need to adhere to the defined contract.

As an example, consider an application that needs objects to manage the properties of various
2D geometric shapes, such as a possible computer game. It makes sense to require that all
classes that implement a 2D shape have a function that returns its surface area, and another
that returns its perimeter. An abstract class of Shape can be defined thar stipulates these
requirements, as the following example demonstrates.
Notice that, because Python and Java can rely upon the contract associated with Shape, there

is no problem creating code that executes getPerimenter () and getArea () onan array
containing a mix of Rectangle and Circle objects.

B3.2 Fundamentals of OOP for multiple classes (HL)

o
£

2

@

AINO TH

Java
abstract class Shape{
public abstract double getArea();
public abstract double getPerimeter();

}
class Rectangle extends Shape {
protected double width;

;

protected double height;

f

Rectangle (double width, double height)
this.width = width;

{

H

this.height = height;

}
@override

// Specify we are overriding the abstract method

public double getArea()

{

return this.width * this.height;

}
@0verride // Specify we are overriding the abstract method

public double getPerimeter
() {

)

(this.width + this.height);

pu—

return 2 *

class Circle extends Shape {
protected double radius;

Circle(double radius)

{

this.radius = radius;

}
@0Override

public double getArea()

{

return Math.PI*this.radius*this.radius;

}

:

@0Override

public double getPerimeter()

{

}
E

o

return 2*Math.PI*this.radius;

class Main {
public static void main(String[]

args)

{

Shape
[] shapes = new Shape[4];

shapes[0]

= new Rectangle(10.0,

4.0);

shapes[1l]

= new Rectangle(36.0,

7.0);

shapes [2]

= new Circle(42.0);

shapes[3]

= new Circle(10.0);

for (int i=0;

i<shapes.length;

i++)

{

System.out.println( shapes[i] .getArea()

);

System.out.println({ shapesl[i] .getPerimeter()

);

)
BT T T T

T

T

T T L LT T LT T

T T T T TRTTT
T T

B3 Object-oriented programming (OOP)

Python

o
Z

==

from abc import ABC,

abstractmethod

import math

-

# Shape: Abstract class in Python,

inherits from ABC

(Abstract Base Class)

class Shape (ABC) :
@abstractmethod
def get_area(self):

pass
@abstractmethod
def get perimeter (self):

pass
# Rectangle class,

inherits from Shape

class Rectangle (Shape) :

def

init

(self, width,

height):

self.width = width

self.height = height
def get_area(self):
return self.width * self.height
def get perimeter (self):

return 2 *
# Circle class,

(self.width + self.height)

inherits from Shape

class Circle(Shape):

def

init

(self,

radius):

self.radius = radius
def get_area(self):

return math.pi * self.radius ** 2
def get perimeter(self):
return 2 * math.pi * self.radius
# Main section

if name == "_main_
":
shapes =

[

Rectangle (10.0,

4.0),

Rectangle (36.0,

7.0},

Circle(42.0),
Circle(10.0)
for i in range(len(shapes)):

print (shapes[i]
.get area())
print (shapes[i] .get_perimeter())
B

L

L

T

L

T

T

|

(.-Common mistake
Confusing the role of abstract classes
It is common to misunderstand the purpose of abstraction, and to use it where a simple base class
with inheritance might suffice. Use abstract classes when you have a base class that should not be
instantiated itself, but has comman code to share with the subclasses that are instantiated. Make
sure any subclass implements all the abstract methods from the abstract superclass.

B3.2 Fundamentals of OOP for multiple classes (HL)

@

ATNO TH

B3.2.4 Composition and aggregation
Because a class is analogous to a data type, and an object is analogous to a variable, you can
quickly end up with programs where an object contains many other objects of different classes
as variables within it, and this process can repeat itself into multiple layers of depth. When
this occurs, these different objects are said to be related to each other and dependent on
each other.
There are different ways of defining these dependent relationships. Inheritance, for example, is
a type of dependent relationship where the child class requires the parent class to exist as its
original source of properties and methods.
There are two other means of defining dependent relationships that we will look at now:
composition and aggregation.

H Composition
4 Composition: where
objects are composed of
other objects, forming
a "has-a" style of
relationship. The objects
that comprise the
internal objects cannot
exist independently of
the containing object.
# Aggregation: where
one object "has”
another object as part of
it, but the two objects
can exist independently
of each other.

Composition is where one object is composed of one or more objects, and the composed
objects cannot exist without the containing object. This creates a strong “one is part of the
other” relationship, where the lifetime of the composed objects is managed by the container.
This can even be referred to as a “death relationship”, meaning if the whole is destroyed, its
parts are destroyed as well.
Some examples of composition relationships include:

B Car and Engine: A Car object is composed of an Engine object. The engine is an integral
part of the car. Outside of the car, it does not serve the purpose it was designed for. If the
car is destroyed, the engine is as well.
B House and Room: A House object is composed of multiple Room objects. Rooms are part of
a house: if the house is demolished, the rooms also cease to exist as functional units.

® Computer and Components: A Computer object is composed of CPU, Motherboard,
Memory, and so on. These components are parts of a computer and do not function
independently if separated.
B Human and Organs: A Human object is composed of a Heart, a Brain and Lungs. These

organs are essential parts of a human body, and they do not function outside the body.

Bl Aggregation
Aggregation is where one object contains one or more objects, but the contained objects can

exist independently without the “container”. Should the containing object cease to exist, the
previously contained objects may still exist in their own right. In this way, the lifecycle of the

contained objects is not managed by the containing object.
Some examples of aggregation relationships include:
B University and Student: A University contains many Student objects. 1f the university was
to close (or once a student completes their studies), the student continues to exist even

when no longer attached to the university.
® Library and Books: A Library contains many Book objects. The library has books, but the
books can exist outside of the library as well.
m Shopping Cart and Products: A Shopping Cart object contains multiple Product objects.

The shopping cart has products, but products are not dependent on the shopping cart for
their existence.

B3 Object-oriented programming (OOP)

(.-Common
mistake
Confusing
composition and
aggregation

It is very easy and
common to get
confused as to which
is which. The key
difference is the
lifecycle dependency
between objects. Use
composition when
objects are part of a

®

Computer System and Peripheral Devices: A Computer System object can have references
to Keyboard, Monitor, Mouse, and so on. The computer system has these peripheral
devices, but these devices can be used with other computer systems.

m

Airline and Airplanes: An Airline has a fleet of Airplane objects. The airline owns
airplanes, but airplanes can be sold or transferred to other airlines and continue to operate.

Sometimes the distinction between composition and aggregation can seem arbitrary and open
for debate. Consider, for instance, the example of Car and Engine. In some contexts, such as at
amechanic’s garage, it could be argued the engine can be configured to function outside of the
car for testing purposes. This subtlety is where your understanding of the context of the

problem at hand is important: what might be correct for one question or scenario may be
different for another. (Note that, even in the mechanic’s shop, you could argue an Engine lacks

autonomy or control over its own lifecycle; it is the containing object — the mechanic’s garage

whole-of-lifecycle, and

— that has that role in that edge case.)

aggregation when the
contained object can
exist independently.

B Relationships in UML
Composition and aggregation relationships can be depicted in UML diagrams using a
diamond-pointed arrow that is filled for composition, and hollow for aggregation.
Car

‘—Composition —_—

Engine

University

K
>—— Aggregation ———————

Student

M UML styling of composition and aggregation

Example
Consider the following scenario, where a Person object has an Address object as an
instance variable.
Person

Address

+ name: string

+ number: int

+ home: Address

+ street: string

+ email: string

has a

+ phone: string

+ locality: string
+ postcode: string
+ state: string

M UML Person has an Address (aggregation)

Is this an example of composition or aggregation? Take a moment to consider before reading on.
The appropriate guiding question is: Can each exist independently of the other? While

ambiguity exists here and a case could be made either way, the situation would most likely
favour that of aggregation. The Person object, as the owning class, doesn’t have control over

the lifecycle of the Address. If a Person moves house, or is deleted from the application,
that Address may continue to exist. In this scenario, an Address may, in fact, be used

by multiple Person objects at once, so one Person ceasing to use it wouldn't have much
bearing on it at all.

B3.2 Fundamentals of OOP for multiple classes (HL)

AINO TH

Social skills and thinking skills: Brainstorm relationships
Draw UML diagrams based on various real-world scenarios using composition and
aggregation, splitting the class into halves: one side being composition, the other
aggregation. Each side has to explain their rationale for why the scenario is an example
of their relationship. Whichever team comes up with the most scenarios wins.

B3.2.5 Design patterns in OOP
(.-TOK
What are the implications of having, or not having, knowledge?
In OOP, knowledge of design patterns, best practices and anti-patterns significantly impacts the
quality and maintainability of software.
Design patterns are common approaches to solving problems that are seen time and time again
in software design. They are best practices formulated by experienced object-oriented software

developers. Design patterns are useful because they provide tested, proven development
paradigms, thereby improving code readability, reusability and reliability.
Some of the most commonly used design patterns that are relevant for beginners in objectoriented programming are the singleton pattern, the factory pattern and the observer pattern.
B

L L L T

T T T T T

sesssans

@ Linking question
How can design patterns in QOOP facilitate the architecture of scalable and maintainable
machine learning models? (A4)

Ml Singleton pattern
# Singleton pattern:
a class that is designed
only ever to have ane
instance instantiated
throughout the lifecycle
of the program.
# Factory pattern:
a design pattern that
provides an alternative
interface for creating
objects in contrast to
normal constructorbased instantiation.

When using a singleton pattern, there will only ever be one instance of the class. That one
instance will be made available globally throughout the project. It is often used for resource

management, such as maintaining an open connection to a database or network location, or
for sertings management. In these scenarios, there is no need for more than one instance to do

the job.

B Factory pattern
The factory pattern is used for providing a factory that can be used for creating a range of

similar objects that will adhere to a common interface.
A graphical user interface toolkit might use a factory method to create windows, buttons or
other Ul elements. For instance, a button factory can return buttons of ditferent styles using
a Primary, Secondary or Alert colour scheme, or perhaps completely different looks, such as
classic vs modern.

B3 Object-oriented programming (OOP)

Hl Observer pattern
4 Observer pattern:
provides a one-to-many
link between objects
to notify objects of
changes in state via
a subscription-style
service.

z
o
=

I

The observer pattern is used to maintain a list of dependent objects that have subscribed to
it so that they receive notifications when an event occurs. The observer pattern allows the

=<

observing object to communicate changes to other objects that are interested in those changes.
This pattern is widely used in implementing distributed event handling systems such as in web
pages, where you might add event listeners to handle user input (clicks, keyboard events, and
S0 on).

M Interface
Before looking at how to apply each pattern, it is worth noting Java examples that demonstrate
the use of an interface. The interface is not in your syllabus, but a quick introduction is merited
as it is the right tool for the job to demonstrate these patterns.
An interface is a construct that defines a set of methods that implementing classes must
provide, without specitying how these methods should be implemented. It allows different
classes to interact with each other through a common set of behaviours, ensuring consistency
and interoperability. Interfaces are similar to, but not quite the same as, abstract classes. They
differ in the following ways:
B Interfaces do not store state (no instance variables). They simply define methods that need

to be implemented.
B A class can implement multiple interfaces, whereas using normal inheritance is limited to
only one parent class.
B Interfaces do not have constructors as they are not concerned with the logic of
implementation (no variables, remember). They are just focused on providing a list of
methods that require implementation.
An example might be an interface called School. This interface defines methods
attendClass (), doHomework (), takeExam (). Different students might implement

these methods differently, but they must implement all of them in one form or another.

Java
/* The interface designs a contract specifying methods that must be provided by
/* those classes that implement it. */
interface School

{

void attendClass();

void doHomework () ;
void takeExam();

}
class StudentA implements School {

public void attendClass()

{

System.out.println ("Student A attends class online via Zoom.");

}
public void doHomework()

{

System.out.println("Student A does homework in the early morning with a
quiet background.");

:

LT
LT LT T T T
T L T LT T T T T T
T TT

B3.2 Fundamentals of OOP for multiple classes (HL)

@

AINO TH

public void takeExam({)

{

System.out.println("Student A prefers taking exams in a quiet
classroom.
") ;

)

}

class StudentB implements School {

public void attendClass() {
System.out.println("Student B attends class in person at the school.");

i

}
public void doHomework()

{

System.out.println("Student B does homework late at night with music
playing.");

}
public void takeExam() {
System.out.println("Student B takes exams online with cpen book
resources.");

}
public class Main {
public static woid main(String[]

args)

{

Studenth student”A = new StudenthA();
StudentB studentB = new StudentB();
studenth .attendClass
() ;
() ;
studenth. doHomework
studentAh. takeExam()
;
studentB .attendClass
() ;
studentB .doHomework
() ;
studentB. takeExam/();

)
B
TP PP PP TP PP

B Application of design patterns
Singleton example
The following code is an example ofa singleton pattern that can be used to provide access to
application settings that have been stored into a settings.json file. The example content of such
a file follows:

{
"databaseUrl":

"postgresqgl://user:passwordehost:port/database",

"timecut": 10

}
Note: Java users, if you plan to implement this, you will need to add the org. json library.
Your IDE should allow you to easily add dependencies to other libraries.

B3 Object-oriented programming (OOP)

-

Python
import json
class ConfigManager:
_instance = None
def

new_ (cls):

if cls. instance is None:
cls. _instance = super (ConfigManager,

cls).
new (cls)

cls. instance.load settings{()
return cls._instance
def loadsettings(self):
try:

with open("settings.json",

"r")

as f:

self.settings = json.load(f)
except FileNotFoundError:
print ("Error:

1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1

:

The settings file was not found.")

self.settings = {}

:

;

except json.JSONDecodeError:

:

print ("Error: JSON decode error in settings file.")

:

self.settings = {}

!

def get_setting(self, key):

1
1
1

return self.settings.get
(key)
if name == "_ main_
":

:

config manager = ConfigManager()

# Initialize the singleton

:

database
url = config manager.get_ setting("databaseUrl")

:

timeout = configmanager.get_setting("timecut")

:

print (f"Database URL: {database url}")
print (£"Timeout: {timeout}")

:
1
1

-

import org.json.JSONObject;
import org.json.JSONTokener;
import java.io.FileInputStream;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
public class ConfigManager {
private static ConfigManager instance;
private Map<String,

Objects> settings;

// Private constructor to prevent instantiation
private ConfigManager()

{

loadSettings () ;

:

// Public method to get the instance
Srrrasrrrsasrrrasnrrinnteny D

RR
T R P T TP T T P PP TP T TP

B3.2 Fundamentals of OOP for multiple classes (HL)

@

L

==

O

E

-

AINO TH

public static synchronized ConfigManager getInstance()
if

(instance == null)

{

{

instance = new CcnfigManager();

}
return instance;

// Load settings from file
private void loadSettings()

{

try (FileInputStream inputStream = new FileInputStream("settings.json"))

{

i

JSONTokener tokener = new JSONTokener (inputStream) ;

JSONObject jsonObject = new JSONObject (tokener);
settings = toMap(jsonObject);

} catch (IOException e)
e.printStackTrace
() ;

settings = new HashMap<>(); // Fallback to an empty map

}
// Helper method to convert JSONObject to Map
private Map<String, Object> toMap(JSONObject jsonObject)
Map<String,

{

Objects> map = new HashMap<>();

jsonObject
.keys () .forEachRemaining (key -> map.put (key,

jsonObject.get

(key)));
return map;

}
// Get a setting value by key
public Object getSetting(String key)

{

return settings.get (key);

}
public class Application {
public static void main(String[]

args)

|{

ConfigManager configManager = ConfigManager.getInstance();
// the Singleton
String databaseUrl =

(String)

// Initialize

configManager.getSetting("databaseUrl");

Integer timeout = (Integer) configManager.getSetting("timeout");
System.out.println("Database URL:

System.out .println("Timeout:

" + databaseUrl)
;

" + timeout);

B3 Object-oriented programming (OOP)

Factory example

:
]
]
1
]
]
]
1
1
]
]
]
]
]
]
]
1
1
1
1

1
1
1
[
1
1
1
1
1
1
1
1
[
[
1
1
1
1
1
[
1
[
1
1
1
1
1
[
1
[
1
1
1
1
1
[
1
1
1
1

Python
class Dog:
def speak(self):
return "Woof!"
class Cat:
def speak(self):
return "Meow!"

class AnimalFactory:
@staticmethod
def get_animal (animal_ type) :

if animal type == "dog":
return Dog
()

elif animal type == "cat":
return Cat ()
return None

# Usage
if name == " main
":
factory = AnimalFactory
()

dog = factory.get
animal ("dog")
cat = factory.get_animal ("cat')

B

print (dog.speak())

# Output:

Woof!

print (cat.speak())

# Output:

Meow!

L T T

LT T T

L L L LT T

Java
// Factory pattern example - Produce dogs and cats

interface Animal {
String speak();

}
class Dog implements Animal {
public String speak()

{

return "Woof!";

}
class Cat implements Animal {
public String speak()
return "Meow!";

}

{

:

T L L LT LT TN

T
T T
T P PP PP P PR P PR TP

]
]
]
]
]
1
1
1
1
1
]
]
]
1
1
1
1
I
]
1

Frrssssssessissssssssinnares T
TR T

B3.2 Fundamentals of OOP for multiple classes (HL)

=
o
=
ze

The following code is an example of the factory pattern.

@

-

ATNO TH

class AnimalFactory {
public static Animal getAnimal (String animalType)
;

if

("deg".equalsIgnoreCase (animalType))

{

|

E

return new Dog();
} else if

:

("cat'.equalsIgnoreCase (animalType))

{

return new Cat();
i

return null;

i

// or throw an exception

H

public class Main {
public static void main(String[]

args)

{

E

Animal dog = AnimalFactory.getAnimal
("dog") ;
Animal cat

AnimalFactory.getAnimal
("cat") ;

System.out.println(dog.speak()]);

// Output: Woof!

System.out.println(cat.speak());

// Output: Meow!

:

Observer example
Finally, here is an example of the observer pattern at work:
L]

Python
class NotificationService:

def

init

(self):

self. cbservers =
def attach(self,

[]

observer):

self. observers.append (cbserver)
def detach(self,

observer):

self. observers.remove (cbserver)
def notify(self, message):
for observer in self. observers:
observer.update (message)
class Observer:
def update(self,

message):

print (f'Received: {message}")
# Usage

notifier = NotificationService()
cbserver
a = Observer()
cbserver
b = Observer()
notifier.attach(observer
a)

notifier.attach(observer
b)
notifier.notify("Hello World!")

# Output:

Received: Hello World!

from both

1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
|
1
1
1
1
1
1
1
1
1
1
1
1
|
1
1
1
1
1
|
1
1
1
1

a

B3 Object-oriented programming (OOP)

L

Java

==

// Observer pattern example - notification service

[}

interface Observer {

-

E

void update (String message)
;
class NotificationService {
private List<Observers observers = new ArrayListes();

public void attach(Observer observer)

{

observers.add (observer) ;

1
public void detach(Observer observer)

{

observers.remove (observer) ;

}
public void notifyObservers (String message)
for (Observer observer : observers)

{

{

observer.update (message) ;

}
class ConcreteCbserver implements Observer {
public void update (String message)

{
" + message);

——

System.out.println("Received:

}
// Usage

public class Main {
public static void main(String[] args)

{

NotificationService notifier = new NotificationServicel();

:

i

Observer observerA = new ConcreteObserver();

;

i

Observer observerB = new ConcreteObserver
() ;

i

notifier.attach (ocbserverd) ;
notifier.attach (observerB) ;
notifier.notifyObservers("Hello World!");

// Output:

Received:

Hello

——

// World! from both

1

In UML diagrams, which symbol is used to represent inheritance between two classes?
a

A dashed line with an arrow

b

Asolid line with a hollow arrow

¢

Asolid line with a filled arrow

d

A dashed line without any arrows

B3.2 Fundamentals of OOP for multiple classes (HL)

@

ATNO TH

What keyword is used in Java to inherit a class?
a

Implements

b

Extends

¢

Inherits

d

Superclass

Which principle of OOP is primarily used to enhance code flexibility and maintainability
through interfaces?
a

Encapsulation

b

Inheritance

¢

Polymorphism

d

Abstraction

What is required for method overriding to occur in object-oriented programming?
a

The method must have the same name and different parameters in the subclass

b

The method must have the same name and parameter list in the subclass, and be marked
with final

¢

The method must have the same name and parameter list in the subclass

d

The method must have a different name but the same parameters in the subclass

Which statement is true about abstract classes?
a

Abstract classes can be instantiated

b

Abstract classes cannot have any method implementations

¢

Abstract classes can contain both abstract and implemented methods

d

All methods in an abstract class must be abstract

What is the purpose of declaring a class as abstract?
a

To force a class to provide implementations of all its methods

b

To prevent the class from being instantiated directly

¢

To ensure that the class can only contain static methods

d

To make the class available only to other classes in the same package

Which of the following best describes aggregation?
a

A strong “has-a” relationship where the lifetime of the contained objects depends on the
lifetime of the container

b

A weak "has-a" relationship where the contained objects can exist independently of
the container

¢

An "is-a" relationship between two entities

d

None of the above

Which scenario is an example of composition?
a

A library owns books

b

A university has students

¢

An apartment building includes apartments

d

A shopping cart contains products

Which design pattern ensures that a class has only one instance and provides a global point

of access to it?
a

Factory pattern

b

Singleton pattern

¢

Observer pattern

d

Builder pattern

B3 Object-oriented programming (OOP)

10 In the observer design pattern, what is the role of the "Subject”?
a

To notify all observers about any changes

b

To keep track of all dependencies

¢

To update the state of various subjects

d

To request updates from observers

o
Z

==

-

11 Describe why inheritance is considered a powerful feature of OOP.

12 Discuss how polymorphism enhances software maintainability.
13 Discuss two benefits that abstract classes provide over using normal inheritance.
14 Outline an example, not based on any given in this book, that illustrates the difference

between composition and aggregation.
15 Describe the factory design pattern and give an example of its use.

Some exercises require you to download files for processing or performing calculations. Those files can be downloaded from:
https://github.com/paulbaumgarten/hodder-ibdp-computerscience
1

Extend bank accounts

Implement the bank account example provided at the end of Section B3.1, and debug any transcription errors to ensure it
behaves as expected before continuing.
O Download the following files from the B3 folder in the Github repository:

ooooo

*

names.txt

* bank-transactions.txt
Use the file reading techniques from B2.5 to read each file into an array of strings (one string per line of the file).
Create an array of bank accounts, one for each person in your array, from the names.txt file.
Process the list of transactions in bank-transactions.txt.
Apply interest calculations on all accounts.
Print all accounts’ final balances.

Do you get the correct final balances for your account holders, as shown below?
Account 1001: Eustolia has balance $5571.3

Account 1014: Hilma has balance $258.3

Account 1002: Nathan has balance $9515.1

Account 1015: Irving has balance $76.65

Account 1003: Milissa has balance $61.95

Account 1016: Carie has balance $2654.4

Account 1004: Willie has balance $1912.05

Account 1017: Nicky has balance $297.15

Account 1005: Hoyt has balance $4697.7

Account 1018: Adele has balance $3287.55

Account 1006: Alexandria has balance $2461.2

Account 1019: Carlene has balance $882.0

Account 1007: Clelia has balance $3311.7

Account 1020: Hermina has balance $2.1

Account 1008: Alpha has balance $1942.5

Account 1021: Ayana has balance $586.95

Account 1009: Delbert has balance $4670.4

Account 1022: Frederica has balance $261.45

Account 1010: Boyd has balance $547.05

Account 1023: Arianna has balance $541.8

Account 1011: Milton has balance $2331.0

Account 1024: Zandra has balance $725.55

Account 1012: Vivan has balance $1275.75

Account 1025: Vina has balance $2553.6

Account 1013; Constance has balance $2983.05

B3.2 Fundamentals of OOP for multiple classes (HL)

@

ATNO TH

2

Flight reservation system
You are constructing a ticket reservation system for a budget airline. This airline doesn't have seating classes (no first class
or business class — everyone sits in economy), and doesn't accept seat reservations. The only thing the airline is interested in
is ensuring enough seats are available on each flight for the tickets it sells.
You are taking over from another programmer who started designing your classes for you. The following is the UML
they created.
Flight

Ticket

— flightNumber: String

— name : String

— capacity: int

0_ + Ticket( name)

— tickets: Ticket[]

+ getName() : String

— ticketsSold

+ toString() : String

+ Flight( flighthumber, capacity)
+ addTicket( Ticket ) : Boolean
+ removeTicket( Ticket) : Boolean

+ getSeatsAvailable() : int
+ printPassengerList() : void
B UML Flight and Ticket

Create the Ticket class and Flight class in code, to adhere to the following rules:
[0 The capacity variable in the Flight constructor indicates the number of seats available on a given flight. Use this
variable to determine the size of your tickets array.
O Implement addTicket() and removeTicket() to add or remove a ticket from the tickets array. ticketsSold
should increment whenever a new ticket is added, and decrement whenever a ticket is removed. Refer to the

CollectionOfThings example in Section B3.1.3 for hints on how to implement this.
[0 getSeatsAvailable() should just be the result of capacity minus ticketsSold.
[0 printPassengerList() should print a list of all the names of tickets for a given flight.
The following code is example main code for testing the result, and an indication of what the output should resemble.

Python
if _name == "

main

":

cx619 = Flight("CX 619",
aa6914

= Flight("AA

280)

6914",

ek89 = Flight ("EK 89",

354)

# Cathay - HKG-SIN

266)

# American

cx619.addTicket
(Ticket ("Taylor Ripley"))
cx619.addTicket (jordan)

cx619.addTicket
(Ticket ("Casey Nec"))
aa6914.addTicket
(Ticket ("Cameron Quaid"))

aa6914.addTicket
(Ticket ("Phoenix Andor"))
cx6l9.printPassengerList
()

print (cx619.getSeatsAvailable())
cx619.printPassengerList ()

JFK-LHR

# Emirates - DBX-GVA

jordan = Ticket ("Jordan Deckard")

cx619.removeTicket (jordan)

-

1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
-

B3 Object-oriented programming (OOP)

o
=

7

class Main {
public static void main(String[]

args)

-

{

Flight cx619 = new Flight("CxX 619",

280);

:
§

Flight =aa6914 = new Flight ("AA 6914",
// Bmerican - JFK-LHR

3

Flight ek89 = new Flight ("EK 89",

// Cathay - HKG-SIN

266);

354);

// Emirates - DBX-GVA

Ticket jordan = Ticket ("Jordan Deckard");
cx619.addTicket
(new Ticket("Taylor Riplev")}});
cx619.addTicket (jordan) ;

cx619.addTicket
(new Ticket ("Casey Neo"));
aa6914.addTicket
(new Ticket ("Cameron Quaid"));
aa6914.addTicket
(new Ticket ("Phoenix Andor"))
;
cx619.printPassengerList
() ;
System.out.println(cx6l9.getSeatsAvailable(})
;
cx619.removeTicket (jordan) ;

i

cx619.printPassengerList
() ;
——

System.out.println(cx6l9.getSeatsAvailable());

Anticipated output:
Flight CX 619 has passengers:
Taylor Ripley

Jordan Deckard
Casey Neo
277

Flight CX 619 has passengers:
Taylor Ripley
Casey Neo

278
3

School enrolments and grade book
Implement the students and grades example as provided in the end of Section B3.1, and debug any transcription errors to
ensure it behaves as expected before continuing.
Extend the scenario to include a new class called “Course” that contains an array of students who are enrolled in it.
[0 Course should contain an addstudent() and removeStudent
() method.
1

Course should have the following additional functions:

*
*

printClassList() generates a list of all student names (in name sort order)
getClassaAverage() returns the average of all student scores.

B3.2 Fundamentals of OOP for multiple classes (HL)

@

AINO TH

4

Library system
Create a system to manage book loans for a library.
Book

Patron

—isbn : String

—name : String

—title : String

% — books : Book|]

—author : String

— booksOnLoan : int

— publisher : String

+ Patron( String )

— publicationDate : String

+ borrowBook( Book ) : Boolean

+ Book( String, String, String, String, String )

+ returnBook( Book) : Boolean

+ getISBN() : String

+ getBooksOnLoan() : int

+ getTitle() : String

+ printBooksOnLoan() : void

+ getAuthor() : String
+ getPublisher() : String
+ getPublicationDate() : String
B UML Book and Patron

[ Create a Book class and Patron class, as per the UML diagram.
0 Download the following files from the B3 folder in the Github repository:
* names.txt
*
books.txt or books.csv
* library-transactions.txt
[0 Use the file reading technigues from Section B2.5 to read each file into an array of strings.
[ Create an array of patrons, one for each name in your array from the names.txt file, and create an array of books based
on the data in books.txt.
[J Process the list of transactions in library-transactions.txt, subject to the following:
* Fach patron can only have a maximum of three books on loan at a time.
* If a patron attempts to borrow a fourth book, it should be denied.
* A book can be borrowed more than once at a time (imagine there are unlimited copies of each book).
At the end, print a summary of each patron’s current books. The final list starts with:

Person Eustolia has these books:
m
=
=

9780141030142 Memory Keeper's Daughter,The
9780099387916 Birdsong
9780006498407 Angela’s Ashes:A Memoir of a Childhood

Person Nathan has these books:

m 9780099419785 To Kill a Mockingbird
m
m

9781904994497 Guinness World Records 2010
9780140237504 Catcher in the Rye The

Person Milissa has these books:
= 9780701181840 Nigella Express
m 9780099450252 Curious Incident of the Dog in the Night-time,
The
Person Willie has these books:
m 9780563384304 Delia's How to Cook:(Bk.1)
® 9780590112895 Subtle Knife The:His Dark Materials
B 9780747581109 Harry Potter and the Half-Blood Prince

How many times did someone attempt to borrow a book over their limit? You should get 1125.
How many books are on loan at the end of the sequence? You should get 51.

B3 Object-oriented programming (OOP)

5

Social-media platform (HL)

z
o
=
e

Use the following UML as the basis for creating an OOP application for a social-media platform.
User

Post

=<

— username : String

— comments : Comment]]

— displayName : String

— likeCount: int

- profilePic : String

+ Post()

— posts : Post]

-

-

— comment : String

@ —author: User

th

-

Comment

d settel

*+getiers and s

rs.

+ Comment( 5tring, User)

+ User( String, String, String )

+ newComment( String, User)

+ newTextMessage( ... )

+ newlike() : void

+ getters and setters

+ newPictureMessage( ... )
+ newVideoMessage( ... )
+ getPostCount() : int

Extends

+ getPost( int) : Post

Extends

Extends

/

+ newComment{ int, String, User)

+ newLike(int )

TextMessage

PictureMessage

VideoMessage

— message : String

— pictureURL : String

- youtubelLink : String

+ TextMessage( String )

+ PictureMessage( String )

+ VideoMessage( String )

+ getters and setters

+ getters and setters

+ getters and setters

B UML social-media platform

For a Java implementation, you may assume the maximum number of posts per user is ten, and the maximum number of

comments per post is ten.
Your final program should be able to:
O create a new user
O allow a user to create a post, via their user object’s .newTextMessage|(), .newPictureMessage() or
.newvVideoMessage() function
O allow a comment to be added to any post via the user object’s .newComment () function, where the integer value
represents the index of the relevant item in the posts array, and the String, User parameters are then passed to the
posts[i].newComment (String, User) function.

The user object’s .newLike() works similarly, using the integer as the index of the post, to then call the .newLike()
on the relevant item in the posts array.
The following code is test code for your main function:
e

iR
e eT
e
e
Ty S R
e e

ol

e

o

E Python

o

o

: import random

"Gandalf the Grey",

"frodo.png")

:

samwise = User("samwise",

"Samwise Gamgee",

:

aragorn = User("aragorn",

"Aragorn",

:

# Create posts

"gandalf.png")

"samwise.png")

"aragorn.png")

1

frodo.new
text message("Just finished my gquest to destroy the One Ring.

:

What an adventure!

:
:
:

frodo.new _picture message("Pic of me after the quest! #MountDcocom #Mordor")
aragorn.new_text
message ("Reunited with my love, Arwen. Forever grateful
for her love and support. @ #Elessar #LoveAndDestiny")

o

o

e

o

R RN M

#MissionAccomplished #RingBearer")

R R RN MM MR MR RN M M

N NN MR NN RN NN M NN NN N NN NN NN RN NN NN N NN NN NN RN NN NN MM N N NN NN NN N N NN N RN Mm RN W A

B3.2 Fundamentals of OOP for multiple classes (HL)

e

"Frodo Baggins",

e

gandalf = User("gandalf",

e e

frodo = User("frodo",

:

B o

:

e

o

1 if name == "_ main
":

@

AINO TH

gandalf .new videomessage("Just having some fun with my staff and
showing off a little wizardry on the dance floor!

g+ #GandalfTheDancer

#WizardGrooves")
# Create comments

frodo.new_comment
(0, "Mr. Frodo!
hobbit I know.

I'm so proud of you! You're the bravest

#TrueFriendship #HobbitHerces",

samwise)

frodo.new_comment
(0, "Frodo, you have my gratitude and respect. Your
sacrifice has saved Middle-earth. #KingOfGondor #HeroicDeeds", aragorn)
frodo.new_comment
(0, "Well done,
and determination.

#WizardPride",

Frodo!

You've shown incredible strength

The world is safer because of you.

#RingDestroyer

gandalf)

frodo.new_comment
(1, "Who's that great locking bloke next to you?",
samwise)
frodo.new_comment
(1, "Amazing!",

aragorn)

aragorn.new_comment
(0, "Aragorn, may your love with Arwen be as enduring
as the light of the Silmarils. #LoveAndHope #FellowshipForever", frodo)
aragorn.new comment
(0, "Aragorn,
always.

you have found true love.

#Shzeldmaiden #HappilyEverAfter",

gandalf .new_comment (0,

"Love it!

gandalf
.new comment (0, "rofl",

Cherish it

gandalf)

#WizardsCanDance",

frodo)

samwise)

# Create likes
frodo.new_like
(1)

frodo.new_like
(1)
aragorn.new_like
(0)
r = random.randint (1001,

2000)

for i in range(r):

T

T

T LT T T T

T

T LT T

T LT T T

Ty

"gandalf.png");

aray

T

ErsssssesssrIrsEsssEsEEataNEate s aa R

Ll
T T

gandalf.new like(0)

Java
import java.util.Random;

class Main {
public static void main(String[]

args)

User frodo = new User("frodo",

{

"Frodo Baggins",

"frodo.png");

User gandalf = new User("gandalf",

"Gandalf the Grey",

User samwise = new User("samwise",

"Samwise Gamgee",

User aragorn = new User("aragorn",

"Aragorn",

"samwise.png");

"aragorn.png");

// Create posts

frodo.newTextMessage
("Just finished my quest to destroy the One Ring.
What an adventure! #MissionAccomplished #RingBearer");
frodo.newPictureMessage
("Pic of me after the quest!

#MountDoom

#Mordor")
;

aragorn.newTextMessage ("Reunited with my love, Arwen. Forever grateful
for her love and support. @ #Elessar #LoveAndDestiny");
gandalf .newVideoMessage
("Just having some fun with my staff
and showing off a little wizardry on the dance floor!

g+

#GandalfTheDancer #WizardGrooves");
B

T

T

L L LT T T TP T T PP PP

H
H
HH
:H
HH

HH
HH
H
PP B

B3 Object-oriented programming (OOP)

=x

// Create comments
frodo.newComment
(0, "Mr. Frodo!
bravest hobbit I know.

I'm sc proud of you!

#TrueFriendship #HobbitHeroes",

frodo.newComment
(0, "Frodo,

]

You're the

=
=<

samwise);

yvou have my gratitude and respect.

Your

sacrifice has saved Middle-earth. #KingOfGondor #HeroicDeeds", aragorn);
frodo.newComment
(0, "Well done,

Frodo!

You've shown incredible

strength and determination. The world is safer because of you.
#RingDestroyer #WizardPride",

gandalf);

frodo.newComment
(1, "Who's that great looking bloke next to you?",
samwise)
;
frodo.newComment
(1, "Amazing!",

aragorn);

aragorn.newComment
(0, "Aragorn, may your love with Arwen
be as enduring as the light of the Silmarils. #LoveAndHope
#FellowshipForever",

frodo);

aragorn.newComment
(0, "Aragorn,

you have found true love.

Cherish it

always. #Shieldmaiden #HappilyEverAfter", gandalf);
gandalf .newComment (0,

"Love it!

gandalf.newComment
(0, "rofl",

#WizardsCanDance",

frodo);

samwise);

// Create likes
frodo.newLike
(1) ;
frodo.newLike
(1) ;

aragorn.newLike
(0) ;
Random random = new Random()
;
int randomNumber = random.nextInt (1001)

for

(int i=0;

i<randomNumber;

i++)

+ 1000;

{

gandalf .newLike (0) ;

1

Customer loyalty system
A chain of stores has launched a new customer loyalty program, where each dollar customers spend accrues loyalty paints
that can be exchanged for discounts on future purchases. An object-oriented program has been created to manage the
loyalty program.

The following classes exist in the system:
[0 Customer: Represents customer information, including a list of all their purchase history items
O Transaction: Represents the purchase of a single item by a customer.
The UML diagram for the Customer class is provided below:

B3.2 Fundamentals of OOP for multiple classes (HL)

@

—int

id

— String

name

—long

balance

— Transaction(]

history

—long

historyltemCount

+ Customer (int id, String name)

addTransaction(Transaction item)

+ void

spendPoints(String description, int points)

+ Boolean

getTransactionBylD(int id)

+ Transaction

getTransactionByDesc (String description)

+ Transaction

getBalance()

+ long

getName()

(Up to 10,000 items)

+ 5tring
B UML Customer class

a State the relationship between Customer and Transaction.
b Construct a simplified UML diagram showing the relationships between Customer and Transaction.
¢ OQutline the significance of the minus sign in front of long balance in the UML diagram.
d Construct the code for the constructor of Customer.
A Transaction object has two properties: a string containing a description of the item purchased and a long integer
containing the cost/ value of the item in dollars (you can assume cents are not used). The following code forms the
basis of the Transaction class:

[]
2]
2]
[3]

Python
class Transaction:
def

init

(self, description, points):

self . description = description
self .points = points
# Getters and setters for description and points

i Java
public class Transaction {
private String description;
private int points;
public Transaction(String description; int points)

{

this.description = description;
this.points = points;
// Getters and setters for description and points

}

BT
T T

AINO TH

Customer

Additionally, the following code describes the functionality of the addItem(Transaction item) function inthe
Customer class:

B3 Object-oriented programming (OOP)

r

1
1
1
1
1
:

L

==

Python

[}

E

def add item(item):

history[ self.history
item count ]

:

self . history
item count += 1

1
1

self .balance += item.get points()

-

= item

-

Java
i

public void addItem(Transaction item)

é

history[ historyItemCount++ ]

:

balance += item.getPoints();

{

= item;

}
e
f

h
i

j

k

Describe the purpose of the historyItemCount property.
Construct the code for the getTransactionByDesc(String description) function using a linear search.
To improve the efficiency of searching for transactions within each customer object, it has been decided to create a
sort() function within Customer that will sort the transactions alphabetically by description. This algorithm will use a
selection sort for the task. Construct the code for the new sert () function to be added to the Customer class.
Now that the history array is sorted, construct new code for getTransactionByDesc(String description)
that will implement a binary search algorithm.
The spendPoints() function should first check whether the customer has enough points for the transaction and
return false if not. Assuming enough points exist, it should create a new Transaction object that is added to the
history, and deduct the points spent from the balance. Construct the code for the spendPoints() function.
The getBalance() function should iterate over all items in the history to calculate the correct balance, then
update the value stored in the balance property appropriately, and finally return that value. Construct the code for

2]
[4]

the getBalance() function.

(6]

Themain() of the program contains the following test code. State the output from this block of code.

[4]

(6]
[5]

[6]

i
i e i B
e 8 e s S eT e

Python
if name == "_main_":
t = new Transaction(250,

"Special deal")

# Create list of 10 None items to replicate an empty array
customers =

[ None for

in range(10)

customers [ 0]

= Customer
(0, "Ava")

customers [ 1]

Customer
(1, "Brian'")

customers [ [2]

Customer
(2, "Cherry")

customers [ 0] .add _item(50,

]

"Burger meal deal")

(100, "Birthday becnus"))
customers[ 0] .additem(Transacticn
customers [ 1] .add_item(200,

"Bluetooth earphones")

customers [ 1] .spend points (50,

"Discount feor shopping")

customers [ 2] .spend_points
(80, "Discount for shopping")
customers
[2] .add item(t)
print( customers[0] .get_balance ()

)

print( customers[l].get_balance()

)

print( customers[2] .get_balance()

)

print( customers[2].get_balance()

)

B3.2 Fundamentals of OOP for multiple classes (HL)

@

H

H

HH
H
H
HH
H

HH

HH

HH
HH

H
HH
H
HH
HH
H

HH
H

HH
HH
HH
HH
H

H
HH

H
HH

HH
HH
HH
HH

HH
HH

HH
HH
H

HHH
HH
HH
HH
HH
HH
H

HH
HH
HH
HH
H

HH
HH

HH
HH
H

HH
HH
HH
HH
H

HH
HH

5
5

s RN R LSRR Sss s ss R s aR i sR st batbatanss .
HH
HH
H

Transaction[]
Customer[]

args)

{

t = new Transaction (250,

"Special deal");

customers = new Customer[10];

customers[0]

= new Customer
(0,

"Ava");

customers[l]

= new Customer(l,

"Brian");

customers [2]

= new Customer
(2,

"Cherrvy");

E

customers
[0] .addItem (50, "Burger meal deal");
customers
[0] .addItem(new Transaction (100,

"Birthday bonus"));

customers
[1] .addItem (200, "Bluetooth earphones");
customers
[1] .spendPoints (50, "Discount for shopping");

e

customers
[2] .spendPoints (80, "Discount for shopping");
customers
[2] .addItem(t) ;
System.out.println (customers[0] .getBalance()) ;

EA
BN Ea e

AINO TH

public static void main(String[]

System.out.println(customers[l] .getBalance());
System.out.println (customers[2] .getBalance());

H

System.out.println(customers[3] .getBalance());

H
HH

}
T

T

T

T

R

T

T

P PP P PP

PP P PP

HH
HH
PP H

B

T

2

Animal shelter
An animal rescue shelter requires a computer system to manage the animals under its care and the adoption process.
When an animal is brought to the shelter, it is given an ID, and its species, age, health status and other relevant details are
recorded in the system. When an animal is adopted, its record is updated to reflect the change in status.
Animals are identified by a unique 1D, which is a combination of letters and numbers (e.g. C4T00123). This is used to track
their information in the system.
A programmer created the classes AnimalShelter and Animal to model the situation above.

Python

i

class AnimalShelter:
def

init

(self,

:
location,

capacity):

:

self.location = location
self.animals =

1

[ None for _ in range(capacity)

]

:

def get_location(self):

:

return self.location

:

def get capacity(self):

:

return len(animals)

:

def find animal (self,

id:str):

:

# Method to find an animal by an ID in the list and return the index
class Animal:

:

def _ init_ (self, id, species):

:

# Missing code to initialize _id, _species, _age, _is healthy

def set_age(self, age):
self. age = age
def set _health status(self,

1

:

!
is_healthy):

self.
is healthy = is healthy

:
:
:
4

B3 Object-oriented programming (OOP)

==

return self. id

:

E

def get species(self):

:

return self. species

:

def get health status(self):

:

return self.
is healthy

:

def get_age(self):

:

srsass srses SersasssssssErEssEasEERsERa SRRy T

return self. age

:

¢ Java

:

public class AnimalShelter
private Animal animals[];
private String location;
AnimalsShelter (String location,

int capacity)

{

this.location = leocation;
this.animals = new Animal [capacity];

}
String getLocation()

{

return location;

}
public int getCapacity()

{

return animals.length;

}
public int findAnimal (String id)

{

// Method to find an animal by ID in the array and return the index

}
public class Rnimal {
private String id;
e NSRS
E SRS R SRR SRR
SRSy

L

y

def get id(self):

private String species;

private int age;
private boclean isHealthy;
public Animal (String id,

String species)

{

// Missing code

:

public void setAge (int age)

{

this.age = age;

}
public void setHealthStatus(boolean isHealthy)

{

this.isHealthy = isHealthy;

}
public String getId()

{

return id;

}
T

T TT

L T T T T

B3.2 Fundamentals of OOP for multiple classes (HL)

LT T

T

L LT LT LT TTTTT P r

e

@

O

-

{

return species;

}
public boolean getHealthStatus()

{

return isHealthy;

}
public int getAge()

{

return age;

}
BT T

T LT LT LT T T

T T TT

T T T T T T T TP P TP

Python
class Dog(Animal):
super ().

init

id,

is_vaccinated):

(id,

[2]
(3]
[2]
[2]
[2]

(5]

e el

=0

QN oo

Explain the purpose of encapsulation in object-oriented programming and how it is applied in the classes above.
Construct the missing code for the constructor of the Animal class.
Explain the use of the keyword this in the setAge method of the Animal class.
Construct code to create an instance of the Animal class with the ID “C4T00123" and species “Cat”.
Construct code to set the age of the object created above to 3 years.
Construct the method addAnimal (Animal a) that will add an Animal to the first empty position of the array
animals[] in the AnimalShelter class and return the position at which it has added the animal. If the array is full
and the animal cannot be added, the method should return —1.
HL extension
Two subclasses, Dog and Cat, are created.

def _ init_ (self,

H
HH
HH
T
T

H
HH

H
HH

HH

H

.H

H

H

H

H

H

H

H

H

H

AINO TH

public String getSpecies()

"Dog")

self. is_vaccinated = is_vaccinated
def get vaccination status(self):
return self.
is vaccinated
class Cat(Animal)
:

def _ init_ (self,

id,

is_neutered):

super().
init (id, "Cat")
L

self._
is neutered = is_neutered
def get neutered status(self):

return self. is neutered

B
TP R

Java
public class Dog extends Animal {
private boolean isVaccinated;
public Dog(String id, boolean isVaccinated)
super(id,

|{

"Dog");

this.isVaccinated = isVaccinated;

B3 Object-oriented programming (OOP)

public boolean getVaccinationStatus()

==

{

|y

[}

return isVaccinated;

E

-

}
public class Cat extends Animal (
private boolean isNeutered;

public Cat(String id, boolean isNeutered)

super (id,

{

"Cat");

this.isNeutered = isNeutered;

public boolean getNeuteredStatus
()

{

return isNeutered;

g

Construct a UML diagram that shows the relationships between the AnimalShelter, Animal, Dog and Cat classes.
Include only the class names and relationships.
3]
The Animal class needs a method that returns a description of the animal, including its ID and species.
h Construct a method getDescription() inthe Animal class that returns a string describing the animal.
2]
The array animals[] in the AnimalShelter class is used to store instances of any kind of animal, including Dog and Cat.
i lustify why Animal is a suitable type for this array.
2]
The shelter has a program that recognizes the loyalty of volunteers by rewarding every tenth time someone donates time
to work at the shelter with a free pet-food voucher. The method to print this voucher has been implemented in the static
method Rewards.printPetFoodvoucher ().

(Note for clarity that the system is not keeping track of how many times each individual person volunteers; just the raw
count for every tenth person who shows up - so one individual may get the voucher the first time they volunteer, or
may attend for weeks without receiving a voucher!)
A getVolunteerCount () method has been added to the AnimalShelter class, which returns the current count of

volunteers.
j
Describe the necessary changes to the AnimalShelter class and any other methods to integrate the volunteer reward
program into the systemn.
[5]
The method removeAnimal() in the AnimalShelter class searches the array for an Animal object with a specified
ID and removes it by setting that index to null. The method returns a reference to the Animal object that has been
remaved. You may assume that an Animal with the ID exists in the array.
k

3

Construct the removeAnimal (String ID) method.

[5]

Streamify music service
An online music and multimedia platform, Streamify, provides users with access to millions of tracks, podcasts and videos.
To manage the vast collection, Streamify uses a computer system to keep track of the digital media, user preferences and
playlists.

Each track is identified by a unique identifier, and contains metadata including the title, artist, duration and genre. Users can
create their own playlists by adding tracks to a personalized list.
A programmer created the classes Medialibrary and Track to model this situation.

0

ython
lass MediaLibrary:
def

init (self, name,
self. name = name
self. tracks =

capacity):

[]

B3.2 Fundamentals of OOP for multiple classes (HL)

449

=
-

def get name (self):
return self. name

@

=
-

def get.size(self):
return len(self. tracks)
def find track(self, id):
# Method to locate a track in the list by its ID

# Not yet implemented
class Track:
def

init

(self,

id,

title,

artist,

duration,

genre):

self. id = id
self. title = title
self. artist = artist
self. duration = duration
self.

genre = genre

Java
public class Medialibrary {

private ArrayList<Tracks tracks;
private String name;
MedialLibrary (String name)

[

this.name = name;
this.tracks = new ArrayList<>();

}
String getName
()

{

return name;

}
public int getSize()

{

return tracks.size();

}
public int findTrack (String id)

[

// Method to locate a track in the array by its ID
// Not vyet implemented

}

R
—————

D T L Ll T LT
Ty

# Accessor methods for each attribute

public class Track {
private String id;
private String title;
private String artist;
private int duration; // in seconds
private String genre;

B3 Object-oriented programming (OOP)

public Track(String id, String title, String artist,
genre) {

!

:

i

7

int duration, String
:

this.id = id;
this.title = title;

this.duration = duration;

:

this.genre = genre;

}
// Accessor methods

[al

b
d

for each attribute

Qutline why the programmer may have decided to use a list instead of an array to store the tracks within the
MediaLibrary class.
Describe the relationship between the classes Track and MediaLibrary.
Discuss the importance of using the keyword this in the constructor of the Track class.
Construct code to create an instance of the Track class with the following details:

2]
[3]
[2]

ID: TRK12345

Title: Oceans
Artist: Dive Deep
Duration: 215 seconds
—
Genre: Ambient
2]
e Construct a method in the Medialibrary class that allows a user to add a Track to the library.
[2]
Streamify allows users to search for media based on genre or artist.
f Construct a method searchByGenre(String genre) in the Medialibrary class that returns an array of Track
objects that match the genre.
[4]
g Discuss the process of overriding methods of the Track class if it were to be extended by Podcast and Video classes. [4]
Two classes, Playlist and User, are now introduced.

E Python

i

: class Playlist:
1

def

:
:

:

init_ (self,

name):

1

self.name = name

:

:

self.track list = []

i

# Methods to add and remove tracks from the playlist

:

: class User:

.
:
:
:
oo

def

init

:

(self, username):

g

self .username = username

:

self .playlists =

:

[]

# Methods to create and manage playlists
e e

e M

=

-

this.artist = artist;

a

[}

M

R

M

M M

M

R

R

M M M R

B3.2 Fundamentals of OOP for multiple classes (HL)

M

M

M

M

M

R

M M

:
M

R

M M

R

R

M

R

M R R

e

R

M

e R

e e e

e e

-

@

AINO TH

Java
public class Playlist {
private String name;
private ArrayList<Tracks> trackList;
public Playlist (String name)

{

this.name = name;
this.trackList = new ArrayList<Tracks>();

}
// Methods to add and remove tracks from the playlist
public class User {

:

private String username;
private ArrayList<Playlist> playlists;
H

public User(String username)

{

this.username = username;
this.playlists = new ArrayList<Playlists();

}
// Methods to create and manage playlists

}
B

LT T

T

L LT T T

LT T LT T T T T PP P PP PP PP PP PP PP PP

h

Construct a UML diagram that shows the relationships between the MediaLibrary, Track, Playlist and User classes.
Include only the relationships without the attributes or methods of each class.
Streamify calculates the total duration of a playlist by summing the duration of each track in the playlist.
i Construct a method in the Playlist class that returns the total duration of the playlist.
i Explain why the Playlist class uses a list to store tracks instead of an array.
The User class can have multiple playlists, and the Playlist class contains multiple tracks.
ke Discuss why composition is used between the User and Playlist classes, and between the Playlist and Track classes.
To enhance user engagement, Streamify introduces a feature that rewards users with a free month of premium
subscription for every 100 tracks they add to their playlists.
The method rewarduser has been added to the User class, which checks the total number of tracks across all
playlists and rewards the user if they meet the criteria.
| Without writing code, describe any changes required to the addTrack method in the Playlist class and the User
class to make the new reward system waork.
The removeTrack method of the Playlist class allows users to remove a track from their playlist by specifying the
track’s unique ID.
m

Construct the remcveTrack() method for the Playlist class.

4]
[2]
2]
[2]

[5]

4]

B3 Object-oriented programming (OOP)

B4 Abstract data types
(ADTs) (HL)

Fundamentals of abstract

data types
Which ADTs are most appropriate
for different situations?

z
o]
2=
o

SYLLABUS CONTENT
YyYvVYYYY

By the end of this chapter, you should be able to:
B4.1.1 Explain the properties and purpose of abstract data types (ADTs) in programming
B4.1.2 Evaluate linked lists
B4.1.3 Construct and apply linked lists (singly, doubly and circular)
B4.1.4 Explain the structures and properties of binary search trees (BST)
B4.1.5 Construct and apply sets as an abstract data type (ADT)
B4.1.6 Explain the core principles of abstract data types (ADTs)

B4.1.1 Properties and purposes

of abstract data types
# Interface: a contract
that specifies a set
of methods a class
must implement,
without defining how
these methods are
implemented, serving as
a blueprint that promotes
maodularity, flexibility and
abstraction in software
development. This
structure allows different
classes to implement
the
same interface in diverse
ways, while ensuring they
provide the functionalities
declared by the interface.
# Modularity: a design
principle that involves
dividing a system into
distinct and manageable
sections or modules,
each with its own
spedific responsibilities,
which can be developed,
tested and maintained
independently, but
function cohesively
when combined.

Abstract data types (ADTs) are fundamental constructs in programming that provide a
theoretical framework for data manipulation through a clearly defined interface. ADTs embody
the concept of abstraction by hiding the complexity of their operations from the user. Users
interact with an ADT through a set of well-defined operations without needing to understand
the underlying implementation details. This separation of interface from implementation
allows programmers to focus on the “what” of the operations rather than the *how”, enhancing
readability and maintainability.
Furthermore, encapsulation is integral to ADTs, safeguarding the data’s integrity by restricting
direct access to the underlying data structure. The internal state of an ADT is accessed and
modified solely through its methods, preventing unauthorized or harmful modifications to the
data structure. This protective barrier ensures that the ADT operates reliably and as expected,
regardless of the external use-case scenarios.
ADTs are defined by their behaviour rather than their physical implementation, allowing them
to be applied universally across different programs and systems without modification. This

property makes ADTs highly reusable and adaptable to various applications, promoting code
reusability and reducing development time.
ADTs also exemplity the principle of modularity: the practice of decomposing complex
systems into discrete, manageable components. This modularity facilitates debugging and
testing, by isolating issues within discrete units without affecting the entire system. It also
enhances the system’s scalability and understandability, making ADTs invaluable for building

complex, robust applications.

(;Common mistake
It is easy to get confused about the difference between interface and implementation. The
interface is what operations are available, whereas the implementation is how these operations
are carried out.

B3 [0

3

B

'|

carry from a previous addition

Use Boolean algebra rules to simplify complex
logic diagrams and expressions
Boolean algebra simplifies complex logic diagrams and
expressions, which allows expressions to be standardized using
logical operators like AND, OR and NOT. This standardization
helps in analysing and simplifying the expressions systematically.

QC,
A Figure 49 Afastadder is a type of electronics adder. Note
that you will not be asked to decode a diagram as complex as
this one

Table 13 Mathematical notation
Operation | Description

Mathematical notation | Programming notation

Digital circuit
s;g':bolamm

AND

Logical conjunction

AAB

A&&B

AND gate

OR

Logical disjunction

AVB

AllB

OR gate

NOT

Logical negation

B

1B

NOT gate

NAND

NOT AND

AAB

(A && B)

NAND gate

NOR

NOT OR

AvVB

(Al B)

NOR gate

XOR

Exclusive OR

ADB

ANB

XOR gate

XNOR

Exclusive NOR (Equivalence) | (A® B)

I(A "~ B)

XNOR gate

Al Computer fundamentals

Boolean algebrarules

TOK

A Boolean algebra law is a principle or rule that defines the behaviour and
relationships of Boolean variables and operations. These laws are used to
manipulate and simplify Boolean expressions, ensuring consistency and
predictability in logical reasoning and digital circuit design. There are several
mathematical laws within Boolean algebra. These are three common laws.

Logic diagrams serve as powerful
tools in the visualization and
design of electronic circuits and
microprocessor layouts, bridging
the gap between abstract logical
processes and tangible physical
systems. Their use shapes the way
we approach the construction,
interpretation and troubleshooting
of complex hardware architectures.

1.

The commutative law applies to AND and OR operations. It means that the
order of variables does not affect the outcome. For example, for variables A
and B, (A AND B) gives the same result as (B AND A). (AORB) = (B ORA).

2.

The idempotent law simplifies expressions with repeated variables. It states
that when a variable is combined with itself, the result is the variable itself.

Forexample, (BAND B)=B.(1AND 1) =1.

To what extent does this influence
our understanding of logical
processes and the construction
of physical systems? What are the
advantages and disadvantages
of using logic diagrams in
this context?

3.

Theinvolution law simplifies double negation. It states that the negation
of the negation ofa variable returns the original variable. In other words, if
you negate a variable twice, you get the original variable back. For example,
NOT (NOT A)=A.NOT(NOT1)=1.

Worked example 26
Use truth tables to demonstrate the equivalence or difference of these logical expressions.

AANDB

B AND
A

How does this demonstrate the commutative law?

Solution
Construct a truth table for the logical expression
A

B

AANDB

0
0
1

0
1
0

0
0
0

1

1

1

AAND B.

Now construct a truth table for the logical expression B

AND A.
A

B

BANDA

0

0

0]

0

1

0

1

0

0

1

1

1

The truth tables show that the results of (A AND B)
and (B AND A) are identical for all possible values of
AandB.
The commutative law states that the order of the
variables does not affect the outcome for AND and
OR operations. The truth tables demonstrate the
commutative law, showing that A AND B is equivalent
to

BANDA.

Al.2 Datarepresentation and computer logic

Worked example 27

B

This expression is used in a digital circuit: (A A A) v B
Rewrite the logic expression as simply as possible.

Solutiop
(AAA) VB

B means NOT NOT B.

So, the expression can be written as:

(A AND A) OR NOT NOT B.
The idempotent law simplifies expressions with repeated
values. Using the idempotent law, A A A simplifies to A.

The involution law simplifies double negation. Using the
involution law, B simplifies to B.
So, the simplified expression is A v B, which can be
written as A OR B. This uses fewer logic gates and is easier
to implement.

Worked example 28
Use the variables A =1 and B = 0 to show that the commutative law applies to logical AND and OR operations.

Solution
The cormmutative law in Boolean algebra states that the
order in which the operations are performed does not
affect the outcome for the logical AND and logical OR

Now consider the commutative law for OR.
AvB=BVvA

operations.

So, if A=1and B =0, your equation would be:

Consider the commutative law for AND.

10R0O=1

AANB=BAA

OOR1=1

So, if A=1and B= 0, your equations would be:

TANDO=0
OAND1=0

Both expressions evaluate to True (1), demonstrating that

the outcome remains consistent regardless of the order.
So, the commutative law applies to both AND and OR
operations.

Both expressions evaluate to False (0), showing that the
order does not affect the result.

Practice questions
20. Define the term “binary number system”.

[2 marks]

21. Describe how integers are represented in the hexadecimal number system.

[3 marks]

22. State the hexadecimal equivalent of decimal 93. Show your working.

[2 marks]

23. Describe the process of converting a binary number
to a hexadecimal number.

[3 marks]

24. Explain the process of converting analogue audio signals into binary.

[3 marks]

25. Describe how logic gates are used in timing circuits such as clocks and timers.

[4 marks]

26. Describe the role of NAND and NOR gates in the implementation of safety systems.

[3 marks]

A\ CIl

Operating systems and control
systems
Syllabus understandings
A1.3.1 Describe the role of operating systems
A1.3.2 Describe the functions of an operating system
A1.3.3 Compare different approaches to scheduling
Al.3.4 Evaluate the use of polling and interrupt handling

THY

A1.3.5 Explain the role of the operating system in managing multitasking and
resource allocation
A1.3.6 Describe the use of the control system components
A1.3.7 Explain the use of control systems in a range of real-world applications

A1.3.1 Describe the role of operating
systems
An operating system (OS) serves as an interface connecting the user and
application to the hardware of a computer system. The role of an operating
system is to manage system resources—such as the CPU, memory, disk, network
and peripherals—and to provide services to the user and other applications, such
as file management, process management, security, and user interface.

User interface

System call responses/

TOK
To what extent does the
operating system's role in hiding
the complexity of hardware
management influence our
understanding of computing
systems? What are the
implications of this for users and
application developers?

Devices or direct commands

(keyboard or click)

callbacks

System calls interface

System calls/

System instructions/

ystinterrupts

device drivers

A Figure 50 A simplified diagram showing how an operating system serves as an intermediary
between applications and hardware

Al.3 Operating systems and control systems

Some examples of operating systems include Linux, Windows, Orbis (based on
BSD, for the PlayStation), macOS, Android, BSD, Unix, and iOS. Each operating

system has its own features, advantages, and disadvantages, depending on the
design philosophy, intended use, and user preference. Some operating systems
are highly specialized and only work on very specific types of hardware.
Remember: there is nota “best” operating system. There is only to what extent an
operating system is the best fit for a given purpose.

Operating systems abstract hardware complexities to

manage system resources
Operating systems manage system resources to ensure fairness, security and
efficiency with competing processes, multiple users, and many different types
of hardware.

Table 14 System resources that an operating system manages
System resource

How an OS manages the resource

CPU

Schedules and allocates CPU time among various processes and threads, implementing scheduling
algorithms to manage process execution, prioritize tasks and handle interrupt requests.

Memory

Manages physical and virtual memory, including allocation and deallocation of memory
to
processes, swapping between RAM and disk (paging), and protection of memory spaces to
prevent processes from interfering with each other.

Storage
g

Manages storage through file systems. It handles file creation, deletion, reading, writing,
permissions and organization, as well as disk space allocation and file system integrity.

1/O (input/output)
P
P

Manages data flow to and from /O devices such as keyboards, mice and network interfaces.
Manages interrupts from 1/0 devices; for example, when mouse movement is detected.

Network stack

Manages the network stack to facilitate data transmission over network interfaces, handling
protocols, network connections, and bandwidth allocation

User interface (UI)

Provides the frameworks and tools needed to build graphical and command-line interfaces,
translating user actions into system calls. While not technicallya resource, the Ul is critical for
interacting with a computer.

Security and access
controls

Enforces security policies, managing user authentication, authorization, encryption, and audit
logs. Among other areas of security, it controls access to files, applications, and system settings.

Process and task

Manages the lifecycle of processes and threads, including creation, execution, suspension and
termination, along with inter-process communication (IPC) and synchronization mechanisms.

management

Power management

Manages power resources to optimize battery life, including controlling power usage by hardware
components and implementing power-saving modes.

External devices and

Manages external devices connected via USB, Bluetooth, or other interfaces, ensuring

peripherals

compatibility and proper operation through device drivers. This is different from 1/O.

It is worth considering the chaos that would occur if individual applications or
users were allowed to allocate memory, schedule the CPU, and write to storage

without considering all the other running processes in a system. It would be
chaotic, insecure and inefficient.

Consider an orchestra. What would happen if all the musicians decided to play
any note they wanted, whenever they wanted, for as long as they wanted? In a
computer, an operating system performs a similar role to that of a conductorin
an orchestra. It manages all the resources while providing a secure and coherent
method or interface to utilize those resources.

A Figure 51 An orchestra needs a conductor

Al Computer fundamentals

Abstraction is one of the
fundamental concepts of
computational thinking, which
you will study in topic B1.

Abstraction can be defined as hiding intricate details beneath a simpler, more
manageable layer (or interface). An application does not need to directly manage
memory—the operating system handles that, ensuring the application has the
resources it needs (or fails gracefully if it does not).
When you are playing a video game, are you worried about allocating threads,
managing memory, and ensuring that your peripherals are generating interrupts?
Of course not! You just want to have fun playing a game.
Another example of abstraction is driving a car. You do not need a deep
understanding of internal combustion engines to drive. The pedals, steering
wheel and transmission control provide an interface between the driver and the
underlying mechanical processes.
When you simplify any complex system into an easy-to-use interface, you are
abstracting the complex system.

A Figure 52 You do not want to worry
about allocating threads when playing
video games

A1.3.2 Describe the functions of an

operating system
The previous section outlined the resources managed by an operating system.
This section looks specifically at what and how an operating system manages
those resources.

What is a process?
A process is an instance ofa program being executed.
A process is the execution ofa program: When you double-click an
application icon or run a command, the instructions within that program are
loaded into memory, and the operating system creates a process to manage
its execution. A program is a passive set of instructions. A process is the active,
dynamic execution of those instructions. You may have multiple processes
running from the same program.
A process is a unit of resource ownership: Each process is given its own
sandboxed area of resources by the operating system. This includes the
following.
Sandboxing Isolating a process
or application, restricting its access
to system resources beyond
what it strictly needs. This can
involve memory protection and
also includes limiting file system
access, controlling network

*

Memory: A private section of memory to store the program’s code, data, and
the stack (which keeps track of function calls and local variables).

*

(CPUtime: The process receives slices of time from the CPU to run its
instructions, with the operating system scheduling when each process gets
to run.

«

Open files/network connections: A process can open files, interact with the
network, and use other system resources.

communication, and so on.

The OS keeps track of which resources belong to which process.
A process is an entity managed by the OS: The operating system maintains
information about each process, including the following.
*

Process state: Whether it is running, waiting for resources, blocked on input
or output, or terminated.

Al.3 Operating systems and control systems

*

Process ID (PID): A unigue identifier assigned to the process.

*

Registers: The temporary storage locations within the CPU that hold the data
the process is currently working on.

*

Priority: How important the process is relative to others, influencing
scheduling decisions.

*

Resource usage: Statistics on memory, CPU time, files, and other resources

used by the process.
A process can have different process states: The process states are
as follows.
*

New: The process is being created and loaded into memory.

*

Ready: The process is ready to run and is waiting for its turn on the
CPU.

e
*

Created

Main memory

Running: The process is currently executing instructions on the CPU.
Blocked (or Waiting): The process cannot continue until an external
event occurs (for example, waiting for
a file to be read from disk,

waiting for network data, or waiting for user input).
e

Terminated: The process has finished its execution and is being
cleaned up by the operating system.
Swapped out
and waiting

By tracking the state of a process, the OS can do the following.
*

Schedule processes: Prioritize ready processes for CPU time.

*

Manage resources: Release resources held by blocked processes,
potentially allocating them to other processes.

*

Error handling: Identify and handle processes stuck in unusual states.

A Figure 53 Processor states

Within a process, you can have multiple threads of execution that share the same
memory space but can potentially execute in parallel on multi-core systems.
For example, a word processor could:
have one thread to handle rendering the document on the screen

*

have another thread to handle spell checking in the background

*

have a separate thread to manage user input.

Swapped out
and blocked

Page file / swap space

A process has threads: A thread (or thread of execution) is the smallest
sequence of programmed instructions that can be independently managed by a
scheduler.

*

™\

Operating systems maintain system integrity by
implementing the following policies and practices
System integrity refers to the state of a computer system when the system
performs its intended functions correctly and reliably, without unauthorized or
unintended alterations. It implies that the system’s hardware, software and data
maintain their expected and trustworthy state. System integrity includes concepts
such as correctness, completeness, data accuracy, protection from manipulation,

and resilience. You could never rely or trust a system if it did not have integrity.

Al Computer fundamentals

Background operations, or background processes, are computer processes
that execute without direct user interaction or a visible user interface. Background
operations perform tasks which support the applications you might be using or
the overall functioning of the system.
Process isolation enforces boundaries between running processes. This means
each process operates in its own dedicated virtual memory space, preventing
accidental or malicious interference with other processes orthe operating
system itself.
Memory protection means that processes have separate memory spaces,
preventing one process from interfering with another or with the OS.
User mode (or user space) and kemel mode separates operations which
require direct hardware access (kernel mode) from those that do not (user mode).
You do not want individual applications deciding where they should read or write
into memary.
Resource management is primarily concerned with allocating resources fairly
and efficiently among running processes, ensuring system responsiveness and
preventing conflicts.

Scheduling The process of
arranging, controlling, and
optimizing work and workloads to
achieve specific goals.

CPU scheduling assigns processes to ensure that critical system operations
receive the CPU time they need without unnecessarily hindering user
applications. You will learn more about scheduling in the next section. The basic
idea is that, in a system with 400 or 500 different processes, each gets a fair share
of resources including priority processes and interrupts.
Access control and permissions assign individual and group permissions to
every single file and directory in the computer.
User and group permissions implement user and group accounts with
specific permissions, controlling access to system resources and limiting what
background operations can do based on their required access level. For
example, a guest would not have read and write permissions in your private
document directory.
File system security manages access rights to files and directories, ensuring that
only authorized processes and users can read, modify, or execute specific files.
In the Linux operating system every file and directory has permissions for read,
write and execute permissions for owner, group, and other.
Most operating systems also support access control lists (ACLs), which can
provide more flexible control to system resources.

Packet A formatted unit of data
carried by a network. Itis a small
segment of a larger message
that is divided and transmitted
over a network, typically in
Internet Protocol (IP)-based
communications.

Security features generally can be contextualized within the CIA triad, keeping
resources confidential, with integrity, and available.
Encryption protects data integrity and confidentiality by encrypting sensitive
information stored on the system. For example, certain versions of Windows
offer BitLocker, which encrypts a disk, macOS offers FileVault, and Linux offers

dm-crypt/LUKS as options for encryption.
Firewalls monitor network traffic at the packet level to detect, block or allow
packets into the system.

Al.3 Operating systems and control systems

Antivirus software monitors files for malicious behaviour (changing an important
system file, for example) and signatures (does anything in this file match a known
virus pattern?).
Firewalls and antivirus software can benefit from integration with the operating
system. This integration allows them to efficiently access system resources,
monitor system activities at a low level, and provide better protection against
threats. However, the ultimate effectiveness of these security measures depends
on factors like the breadth of threat definitions, the frequency of updates, the
sophistication of detection algorithms, and the overall security architecture,
rather than solely on whether they are provided by the OS.

You will find more about the
function of firewalls in topic
B3 End-of-topic QUEeSTIONS. ... ...
e
e 542
B3 Object-oriented programming (OOP)

*

