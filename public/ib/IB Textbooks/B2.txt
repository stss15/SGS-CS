B2 Programming

Programming fundamentals
(part 1)
How can we apply programming to solve problems?

SYLLABUS CONTENT
By the end of this chapter, you should be able to:
» B2.1.1 Construct and trace programs using a range of global and local variables of various
data types
> B2.1.2 Construct programs that can extract and manipulate substrings

B2.1.1 Variables
# Variable: a
designated memory
location that stores a
value that can change
during the execution of
a program.
# Loop / iteration: a
repetition.

Converting an algorithm into code involves using variables to store and manipulate data,
loops to repeat instructions, and selection structures to make decisions on a path to follow to

complete a task. Important constructs to understand when developing a program are:
B data storage: the use of variables and constants
B operators: used to manipulate and compare data (mathematical and logical operators)
® selection/branching structures: used to construct decision statements
u

iteration: loops to repeat blocks of code: counter-based and conditional looping structures.

# Selection: a
conditional statement or

B Data storage — use of variables

decision statement, e.g.

Consider a sales representative receiving a fixed-base salary, supplemented by a bonus that is

IF, CASE statements.

# Data storage:
storage of data within
primary or secondary
memory.
# Operator: a character
that represents a
mathematical, arithmetic
or logical operation.

tied to monthly sales performance. This bonus fluctuates from month to month; hence it can
be characterized as variable over time. In fields like Mathematics and Computer Science, the
term “variable” is used to encapsulate such dynamic values.
A variable has an identifier (name) and a current value. Each variable can only hold one value
at a time. Before being used, a variable must be declared and initialized.
Variables
age=5

age=6

i

# Identifier: a lexical
token that names the
language’s entities.
# Declaration: a

X

il

.

», old value is overwritten
\

value

language construct

specifying the properties
of an identifier.
+ Initialization:
assigning an initial value
to a data structure.

identifier N
(variable name)
age

Variable declaration refers to specifying the data type of the variable, while initialization refers
to providing it with an inirial value.

B2 Programming

(;Top tip!
In Python, there is no need to declare the variables used. Therefore, for assessment purposes, they
4 Comment: a note
that explains some code,

which will be ignored at
compilation stage.

can be mentioned via a comment (a comment is used to provide explanations of code, or notes, to

the developer, but it is removed at lexical analysis stage — it is not necessary during the compilation
of the program, so it will be ignored).

Inquirer: Nurture your curiosity, developing skills for inquiry and research.
Research skills: Research the term “constant” and understand the difference between
constants and variables. Outline those differences and specify when each of them could
be used.

M Data types
# Data type: defines
the type of value
a variable or data

The data type tells you what type of value a variable will store and what kind of operations are

structure has, and what

a true / false value; or one single character? Every programming language has its own way of

allowed on that specific value.
1s the variable going to store a whole number or a decimal number; is it a piece of text or just

type of mathematical,
relational or logical
operations can be
applied without causing
an error.

String

4 String: a data type

quotation marks.

used to represent a

declaring variables.

String is used to store a sequence of characters, digits and / or symbols (a text). The text
is written in double quotation marks in Java, while Python can use single or double

sequence of characters,
digits and / or symbols.

-

# Assignment: to set,
reset or copy a value
into a variable.

'

: password ='Bcb@l23"'

:

I password ="Bob@l23"
1

1
1

# Integer: a data type
used to represent a

whole number.
# Float: a data type

In this example, the password is assigned (becomes) the value Bob@123.

The primitive data types considered for the curriculum are: int, double, char and Boolean.

used to represent a

Integer

decimal number.

Integer (int) is used to store whole numbers (positive or negative integers).

# Double: a data type
used to represent a
'S

Il

wm

1]

W
w

decimal number.

Decimal
The float and double data types are used to store decimal numbers (double precision). As

double has a higher precision than float, it is safer to use double in your exercises.

Python

B2.1 Programming fundamentals (part 1)

1

| Python

P

: Java
:

Pl Python

char at=

'@';

:

:

at =

'@’

Boolean
Boolean is used to store one of the two possible values: true or false. So, a Boolean variable
could be used to store such data as whether or not a product is still in stock; whether or not a
person is a male; whether or not a trip has been paid for, and so on.

SR
: Java

B

H

SRS
H
:

H

: boolean a = false;

:

1

1 Python
1
1
1

Boolean variables are often used to evaluate logic expressions. In code, conditions often need
to be added and, if the condition would evaluate to true, some statements would be executed;
otherwise, different statements would be executed.

Another example of the need for a Boolean variable would be to continue repeating a piece of
code as long as an expression evaluates to true or false, based on the requirements.
Consider the following variables:a = 7andb = 54.
((a<9)

and (b=>30)) evaluates to true: if both conditions evaluate to true, the result is

true. 7 is smaller than 9 and 54 is greater than 30 (both conditions are met).
((a=3)

or

(b<3))

evaluates to true: if either condition is true, the result is true. (The

-

Explain why variables are used in programming.

W

Define the term "variable”.

N

first condition is true; the second is false.)

State three data types used in programming.

bR

# Boolean: a data type
to represent one of the
two possible values: true
or false.

:

Suggest a way to declare a variable in the programming language you are currently studying.

oOom

used to represent one

single character, digit or
symbol.

Identify rules and conventions that you could follow when naming variables.

N

# Char: a data type

Char
Char is used to store a single character, digit or symbol.

Identify a situation where you need to change the data type of a variable during the
execution of a program.

8

Identify an example of a common error when using variables and explain how you would
fix it.

9

Explain how the choice of data type affects memory usage and performance in a program.

Explain why it is important to choose an appropriate data type for a variable.

B2 Programming

10 Evaluate the following Boolean expressionsifa = 8andb = 3:
a

E=(a<b)or (a=5)

b

E=!({a>=b)

¢

E=(a<8)and (b>3)

d

E=(a==8)

e

E=!(a==Db)or(a>b)

11 Identify the most appropriate data type to store:
a

your name

b

your age

¢

your phone number

d

whether an item is out of stock

e

the price of a flight ticket.

12 Identify three legal and three illegal identifier names in the programming language you study.

Construct code to output a joke on the screen.
2
3

Construct code to ask the user to enter their name, store it in a variable and display it on the
screen, together with a welcome message.
Copy the following expressions and display the value of E after each one of them. Check

sN &
[ R s N sR e

=8
=3
=
Il

]

whether your answers to review question 10 above are correct.

(a<b)
!

=

or

(a>5)

(a»=Db)
(a<8)

and

(b>3)

(a==8)
!

(a==b)

or

(a=b)

Use your answers to the programming exercises above to answer the following questions.
1 Did you follow variable naming conventions to solve questions 1 and 2?
2 Were the variable names meaningful and descriptive?

Self-management skills: Set goals that are challenging and realistic: Practise five coding
challenges of your choice per week. This will greatly improve your coding skills, and it
will increase your self-confidence.

B2.1 Programming fundamentals (part 1)

Communicators: Express yourself confidently and creatively in many ways. Collaborate
effectively with and listen carefully to the perspectives of other class members.
Communication skills: Use appropriate forms of writing for different purposes and
audiences. Explore and create a table to present to the class the different ranges
available for the data types you have studied.

B Assignments
Assignment refers to setting a value to a variable; this operartion is typically carried out using

the equals sign (=). The value on the right of the equals sign is assigned to the variable on the
left side of the equals sign; it can never be done the other way around.
count = 1
This statement assigns the value of 1 to the variable count. In other words, count is now 1.
But you will often see statements like this: count = count + 1. This statement means that
the variable count is incremented (or increased) by one, or its new value is one greater than

4 Increment: to
increase a value by
another value (usually

it was. Incrementing a variable by one is a special case, and you can also write it as count++.

by one).

Another example is when you decrease the variable by a value other than one, such as:

4 Decrement: to
decrease a value by
another value (usually
by one).

If ++ means the variable is incremented by one, decrementing a variable by one becomes
count--orcount = count - 1.

price

5000

price

price - 100

Here, the variable price becomes 100 lower than it was. So, it was initially 5000, and
after the second line of code is executed the new price is 4900. When assigning new values
to variables, the previous value is overwritten, so the variable occupies the same memory
location. Therefore, in this case, after the two lines of code are executed, the value of 5000 is

completely lost.
As such, a challenging question would be: how do you swap the contents of two variables?
Imagine that you have two variables, a and b, storing the values 5 and 7 in this exact order.
How could you swap their contents, and end up with a storing the value of 7 and b storing the
value of 57
One attempt to solve the problem might be the following:
a=>5
b =17
a=>
b =a

If you have been tempted to do this, what happens is that you end up with two variables
storing the same value; in this case, 7. On line 3, the variable a becomes 7, and on line 4, the
variable b becomes a, which means b becomes 7 as well.

B2 Programming

Therefore, to solve such a problem, you need to imagine that, instead of numbers, you are
dealing with liquids. Imagine that the variable a is a cup that is filled with water, and the
variable b is a cup filled with tea. What you want is to swap the contents of your cups: the water
to get into cup b and the tea into cup a. You cannot mix those contents, so what is the solution?

A third cup! The solution is to bring in a third cup, which will temporarily hold the content of
one of your cups. So, you pour the water into cup c. Cup a is now available to store the content

of cup b, which is the tea. After this step, you can pour the water from cup c into cup b. By doing
this, your contents are swapped successfully. The example below shows you how this works

with numbers:
a=2=5

b=17
temp = a

// 5 is saved into the temporary variable temp

a=>b

// 7 is stored into a

b = temp

// 5

(from temporary variable)

Initial state of the variables.

Step 1: content of a is copied
into temp.

B2.1 Programming fundamentals (part 1)

is stored into b

Step 2: content of the
variable b is copied into a.

The content of a is overwritten.
Step 3: content of the
variable temp is copied
into b.

Now the content
of the two variables
a and b is swapped.

Although this might seem an irrelevant challenge right now, this swapping method is part of
several sorting routines that you will study later.

B Operators
4 Arithmetic
operator: a character
that is used to perform
a calculation.
4 Boolean operator:
a character that
represents a specific
logical operation that is
used to produce a true
or false outcome.
# Relational operator:
an operator used to
compare values or
expressions.

Operators are used to perform calculations, comparisons and other logical operations.
Operators can be arithmetic operators, such as +, -, /, *, %; or Boolean operators, such as !,
&b )

|; or relational operators, such as <=, <, >, >=, ==, | =.

Operator in Java

Operator in Python

Meaning

+

+

addition

-

-

subtraction

B

*

multiplication

/

/

division

%

%

modulus (returns the remainder)

<

<

smaller than

<=

<=

smaller than or equals to

>

>

greater than

»=

»=

greater than or equals to

.

==

equals to

1=

[

not equals to

&8

and

and

I

or

or
B2 Programming

# Binary operator: an
operator that requires
two operands (values).
# Operand: a value
used in a mathematical
expression.

Arithmetic operators are used to perform calculations such as addition, multiplication,
subtraction, and so on. The arithmetic operators presented so far are binary operators,
meaning they require two operands (two values) to apply the calculation on. There are also
unary operators (that require only one operand), such as:

# Unary operator: an
operator that reguires
one single operand.
4 Integer division:
division in which
the fractional part is
discarded.
# Floating-point
division: division in
which the fractional part
is kept.

Unary operator

Meaning

-

negative numbers

++

incrementing the value by 1

-

decrementing the value by 1

While it is quite straightforward to understand when you would use the addition, subtraction

or multiplication operators, it might be a bit trickier to understand what the div and mod
operators are.

Div: division operator
In Java and Python, there are two types of division: integer division and floating-point division.
Both types use the same symbol (forward slash) in Java. However, when dividing two integer
values, the result will be an integer (integer division); when dividing two floating-point
number numbers or a decimal and an integer, the result will be a decimal number (floatingpoint division).

Java

H

int nol

7;

int no2

i

System.out.println(nol/no2);

H

In the example above, even if the result would be 3.5, the answer displayed would be 3, as the
two numbers are whole numbers (integers).
.......................................................................... e

double nol = 7.0;
double no2 = 2.0;

System.out.println(nol/no2) ;

However, in this example, as both variables store decimal numbers, the result displayed is a
decimal number as well (3.5).

Java
float nol = 7.0;
int no2 = 2;
System.out.println(nol/no2) ;

In the example above, the values stored are numbers of mixed data types, and the result will
be a decimal number: 3.5.

B2.1 Programming fundamentals (part 1)

H

In Python, as the type of variables is not specified, there are different operators to represent
the different types of divisions. Floating-point division is performed by the / (forward slash)
operator, so the result will be a decimal number. However, integer division uses the // (double

slash) operator. // will return the floor division (this means that, no matter the result, it

will always round it down — what happens is that the decimal part is truncated or, in simpler
words, it is ignored or deleted.
1
]
1
1
1
1
1
:

no2 = 2

1
1
a

(T
TTTTTTTTTm
: Python

Tms e

m

eh
!

:

nol = 7

:

:

#nol = 7.0

:

I

no2

1

I
1
I

=

2

1
1
1

However, this time the output will be 3, as the result is truncated, without taking into

consideration the data type of the variables.

Construct code in the language of your choice to solve the following problems.

(;Common
mistake
Algorithms written
to solve a problem
need to be specific
and accurate. Many
students lose marks for

1

Ask the user to enter three numbers. Qutput their average. For example, if the input is: 3, 4 and
5, the output is 4.

2

Ask the user to enter their name and age. Output a message that includes the name and the
age that the user will be in 10 years. For example, if the input is Bob, 15, the output should
be [Bob, in ten years you'll be 25 years old].

3

Ask the user to enter a three-digit number. Output the sum of all three digits. For example, if
the input is 125, the output should be 8.

Use your solutions to the programming exercises above to answer the following questions.
1 Did the correct mathematical operations occur for question 1?
2 How did you concatenate the name and the age to display the output for question 2?
3 Was the expected result displayed for question 3?

missing small details,

like forgetting to

Communication skills: Give and receive meaningful feedback — work in pairs to exchange

initialize a variable such
as a counter or a total.

solutions to the programming exercises and give each other feedback on what could

have been done to improve or optimize the proposed solutions.

B2 Programming

B2.1.2 String manipulation
In coding, there is often a need to manipulate text. You might want to display some special
characters, such as double quotations " ", single quotations ' ' or a backslash \.
As those characters are already used for a specific purpose in most programming languages,

displaying them might be challenging. At the same time, programmers might want to extract
parts of text belonging to a string, join them together, alter or delete them. Iow is all this possible?
Inchuding an escape character (backslash) supports typing special characters that are usually
used for specific purposes in the language. For example, single quotations are used for storing a
character in Java or even a string in Python; the same happens with double quotations. Therefore,
when wanting to include single or double quotations in the text, you must use the backslash:
Character

Java and Python

v
v
\

W

B Text blocks
In Java, multiple line strings can be written like this:

¢ Java
System.out.println("Write multiple\n"

i + "Lines like this");
Text on different lines is joined together via the + operator. \n represents the new line

character, denoting that the new line of text will be displayed on the next line.

P -

In Python, multiple line strings can be written by using triple double quotation marks:

Python
print (""" Write multiple
Lines like this
nn Il)

The programming language offers several built-in functions that can be used to

manipulate strings.
In the examples below, text is a variable that stores a piece of text, such as: “Computer
Science is fun!”

H Length
The length function returns the length (number of characters, spaces included) of the value
stored in the string text. In this situation, the value stored in x is 24.

E Python
1
L

B2.1 Programming fundamentals (part 1)

x = len(text)

|
1
1
:

e et 4

B Concatenation
# Concatenation:

joining strings together.

Concatenation refers to joining two or more string values together.
Both Java and Python allow several ways to achieve concatenation. One of them is with the +
operator, which will join the two strings together.

. Java

:

String partl = "Computer Science is fun";
String part2 = ",

isn't it?";

String text = partl + part2;
System.out.println(text) ;

r

1
1
1
1
]

"

1
1
1
1
1

partl = "Computer Science is fun"

:

part2

]
1
I
1

text = partl + part2

=

",

isn't

it?"

:

1
1
1
1

print (text)

=

a

Another function that can be used in Java to concatenate two strings is the function concat:

. Java
String partl = "Computer Science is fun";
String part2 = ",

isn't it?";

String text = partl.concat(part2);
System.out.println(text) ;

Note that concatenation is a technique that is applied to a series of string variables, rather than a
combination of strings and integers or decimals. If there is a need to concatenate a combination
of strings and integers, the + operator can be used in Java, or the integer or decimal value can
be converted to a string prior to the concatenation taking place. In Python, the interpolation
operator (%), the str function, str. format or £-strings can be used for this purpose.

String exam =

"Computer Science";

int grade = 9;
System.out.println("Your "+ exam +

"

exam score is

"

+ grade);

i Python: Use of interpolation operator

i

:

exam =

:

:

grade = 9

:

print ("%$s%s%s%s"

"Computer Science"

:
%

("Your

"

,

exam,

" exam score is

",

grade))

:

B2 Programming

Python: Use of str function
exam =

"Computer Science"

grade = 9
print ("Your " + exam + " exam score is " + str(grade))

1
1
1

Python: Use of str.format
exam =

"Computer Science"

1

1

grade = 9

1

print ("{}{}{}{}".format ("Your " , exam,

" exam score is ",

:

grade) )

:

Python: Use of f-strings

1
1
'
1

exam =

"Computer Science"

: grade = 9

1 print (£'{"Your "}{exam}{" exam score is "}{grade}')
1

(‘Top tip!
In Python, if you want to display the content of the two variables without saving it into another
variable, you can simply use the print function, which accepts several parameters separated by
a comma:
P1
1

| Python

'

: partl = "Computer Science is fun"

:

: part2 = ",

:

I

1

oo

isn't it?"

print (partl,
o

o

partz)

1

1
e

e R R

R

R

e R

R

e R R

R

e e R

e e

e e e

e

e

e e

- -

H Substring
substring is the function that is used to retrieve part of the string, for example if you want
to extract the first word or letter in a string, or the text between specific positions in the string,
Note thar the first position in a string is 0.
In Java, the function used tor this purpose is called substring:

Java
String text = "Computer Science is fun";
String part = text.substring(8);
System.out.println(part} ;

By providing one argument to the substring function, it indicates the starting index of the
text to be extracted. In this example, the output would be “Science is fun” as the variable part

will be assigned the value from the string, starting with position 8 until the end of the string.
B2.1 Programming fundamentals (part 1)

String text = "Computer Science is fun";
String part

text.substring(8,16) ;

System.out.println(part) ;
Tesesssssasranninnannns PErrT B

T T T LT T T

T T LT T T TP

PPN sessssans :

In the example above, the call of the substring function is passed two arguments. The first
one (8) indicates the starting index (position in string) and the second one (16) indicates the

ending index. The substring produced will be from starting index until the ending index —1.

Therefore, the text produced in this example will be “Science”. This is the case because “S”
is the letter at index 8 and “e” is the letter at index 15. The letter at index 16, which is a space
character, is not included.
In Python, the substring function is often referred to as slicing.
I

D

o

O

N

. N

D

. O T

R, 000

O

i O

S

g

o S, Wy O, O W0, N S N

o

i Python

i

:

text =

:

:

part = text[0:1]

:

:

print (part)

:

o

o o

"Computer Science is fun"

e

e e e e e e e e e e e e e R R e e e e e R e e e R e e e e e e R e e e e e e e e e

o

o

The code above extracts the first character of the text variable: “C".
L ettt -

Python
text = "Computer Science is fun"
part = text[:5]
print (part)

In this case, the part will include the first five characters from the text: “Compu”, as “C” is in
position 0 and “u” in position 4.

i Python

i

:

:

text =

"Computer Science is fun"

: part = text[-1]

:

: print (part)

:

L I
I
|

Because the index is —1, this piece of code will store the last character into the string part; in
this case, the letter “n”.

Python
text =

"Computer Science is fun"

part = text[-6:]
print (part)

In this example, the last six characters in the string will be assigned to the variable part: “is fun”.

B2 Programming

Python
text = "Computer Science is fun"
part

text [1:-4]

print (part)

Above, the extracted text will start at index 1 and will end at the last index —4. So, the value
stored in the variable part is “omputer Science is”.

B Replace
The replace method searches a string for a character or set of characters and replaces it or
them with another character or with other characters.

Java

i

String text =

"Computer Science is fun";

text = text.replace('e',

'@');

System.out.println(text) ;

In Java, the replace method will replace one single character, so the text now becomes
“Comput@r Sci@nc@ is fun”. To replace several characters, the replacefll method should
be used.

Java
String text = "Computer Science is fun";
text = text.replaceAll("is",

"will be");

System.out.println(text}) ;

In Python, the replace method is used for replacing both one single character and
more characters.
P

S

]

OO S

L

D

WO

O

O

O

S

| .

i Python

1
: text = "Computer Science is fun"
I text = text.replace("e",
]
1 print (text)
1

"@")

L

L]

[l

1

1
:
1
[
1
1
Ll

Python
text

"Computer Science is fun"

text

text.replace("is",

"will be")

print (text)

B Strip
Sometimes, when reading values from a text file or any permanent storage, you might want to
remove the trailing white spaces. This can be achieved by using the strip method.
B2.1 Programming fundamentals (part 1)

Some versions of Java accept t riminstead of strip for the same purpose:

: Java
! String text =

Computer Science is fun

!

"

:

text = text.trim();
System.out.println(text) ;

The leading and trailing spaces will be removed, therefore the new text that will be output is:
“Computer Science is fun !”

To achieve the same output in Python, you can use the st rip function:

text = "

Computer Science is fun

!

"

text = text.strip()

print (text)

(®Tok
How does knowledge in Computer Science develop?
Knowledge in Computer Science develops through a dynamic interplay of various Ways of Knowing
and Areas of Knowledge. Logical reasoning and empirical evidence form the backbone of technical
advancements, while intuition, creativity and ethical considerations shape the broader impact and
direction of the field. The interdisciplinary nature of Computer Science ensures that it continually
evolves, influenced by and influencing other domains of knowledge. This multifaceted development
makes Computer Science a rich field for TOK debates, highlighting the complexity and depth of how
knowledge grows and transforms within it.
Is Computer Science knowledge primarily objective, grounded in mathematical truths and
empirical data, or does it also encompass subjective elements, such as user experience and ethical
considerations? How significant is intuition in developing new algorithms or systems? Can purely

logical and empirical approaches lead to all breakthroughs, or is there a place for creative intuition?

1

Construct code that asks the user to provide their name, house / flat number and their street

number or name.. Concatenate this information to display a message such as the following.
(Attempt to write the message by using one single line of code, and ensure it is displayed on
two separate lines, as shown.)

From: Name
Address: Full Address
Message:
Why was there a bug in the computer?
Because it was looking for a "byte” to eat!
2

Construct code that allows the user to enter their first and last names. Concatenate the two
values, add a space in between and display the full name together with its length without

the space.
3

Construct code that allows the user to enter a noun and a letter. Replace all occurrences of
that letter with the @ symbol.

B2 Programming

Programming constructs

SYLLABUS CONTENT
By the end of this chapter, you should be able to:
» B2.3.1 Construct programs that implement the correct sequence of code instructions to
meet program objectives
P B2.3.2 Construct programs utilizing appropriate selection structures
» B2.3.3 Construct programs that utilize looping structures to perform repeated actions
» B2.3.4 Construct functions and modularization

B2.3.1 Sequencing
When solving problems, the order in which the statements are executed matters. Taking the
swapping example in section B2.1, if you were to change the order of the instructions it would

produce an incorrect output:
a

=>=5

b =7
a=>b

// 7 is stored into a

temp = a

// 7 is saved into the temporary variable temp

b = temp

// 7

(from temporary variable)

is stored into b

Here, even if they are the same statements, the result will be incorrect just because they are not
in the right order. In this example, in the end both variables, a and b, will store the value 7. As
such, no swapping occurred, even if a temporary variable was introduced exactly as was done
in the correct algorithm.
# Sequence: to

Sequence refers to the instructions being executed once and in the exact order they are written.

execute instructions
one after another in the

outcome, which could lead to incorrect functionality (as demonstrated above), logic errors or

given order.

Tollowing the right order of the instructions is important in programming, as this impacts the
infinite loops.

B2.3.2 Selection structures
B Selection or branching structures
Selection is a programming construct used to decide what statement(s), if any, are to be
executed based on one or more given conditions.
Conditions are usually built using logic operators. IF statements are an example of selection
or branching structures. The condition in the IF statement is evaluated: if it evaluates to
true, specific statements are executed; otherwise, nothing happens, or other statements

are executed.

B2.3 Programming constructs

condition
False

True

statement 1
statement 2

)

statement 3
statement 4

M IF statements flowchart

In this flowchart, if the condition is met, statements 1 and 2 will be executed; otherwise,
statermnents 3 and 4.
IF condition THEN
END IF
B General structure

condition

Yes

statement

M Selection statement flowchart

In this case, nothing happens if the condition is not met. As an example, this structure could

be used in a situation where a buyer receives a discount of 20 per cent if their purchase value is
100 or more. As such, if their purchase value is below 100, nothing happens.

B2 Programming

Java
private static Scanner read;
public static void main(String[] args)
read = new Scanner (System.in) ;
double purchaseValue,

{

discount;

discount=0;

System.out .println("enter value of goods purchased:
H

");
:

purchaseValue = read.nextDouble
() ;
if

(purchaseValue>=100)

discount = purchaseValue * 0.2;
System.out.println("Your discount is:

"

+ discount);

In this example, the purchaseValue and discount variables have been declared as
double because they are meant to store an amount of money, which could be a decimal value.

As the discount is only calculated if the condition is met, we had to initialize it to 0 in the
beginning, so there is a value to display if no calculation occurs. The indentation inside the
IF statement in the Python below shows what instruction is going to be executed when the

condition is met. In Java, the indentation is replaced by curly brackets and, if those are missing,

e e e e ee e e e e R e e R e R R R e e e e e R e e e e e e
r e

:
]
1
]
]
I
]

Python
discount = 0
purchaseValue= float (input ("Enter the value of your goods:"))

if purchasevValue>=100:
discount = purchaseValue * 0.2
print ("Your discount is

",

discount)

o

]
]
1
]

o

then the next line will be interpreted as belonging to the selection statement. Therefore, the output
statement will be run independently of the given condition, as it is not included in the IF statement.

o

[

In Python, there is no need to declare the variables, so only the discount variable is
initialized to 0. However, the input value is converted to £loat, to ensure the user will enter a
decimal number (integers are included into the range of decimal values). If the float conversion

did not happen, the user’s input value would be a text, and this would throw an error when
attempting to use it in calculations.

You can further expand this code and include a variable to store and display the due amount:

: Java
E

:

double purchaseValue,toPay,

discount;

E

i toPay=0;

|

i System.out.println("enter the wvalue of your goods:
E

purchaseValue = read.nextDouble
() ;

");

i
E

i if

(purchasevalue>=100)

E

discount = purchaseValue * 0.2;

E

i

toPay = purchaseValue - discount;

]

{

! System.out.println("You need to pay:

B2.3 Programming constructs

:

" + toPay);

i

In the example above, you need the brackets to indicate that both calculations will happen
only if the condition is met.

toPay = 0

purchaseValue= float (input ("Enter the walue of your goods:"))
if purchaseValue>=100:
discount = purchaseValue * 0.2
toPay = purchaseValue - discount
print ("You need to pay: ", toPay)

In Python, the indentarion replaces the brackets, so they are not included.
The IF statement can be further expanded to include an ELSE. The statements corresponding
to the ELSE are the statements that will be executed if the condition evaluates to false instead.
IF condition THEN
ELSE

END IF
M General structure

No

Yes

statement 2

statement 1

N

M Selection statement flowchart

Java
if

(purchasevValue>=100) {
toPay= purchaseValue * 0.8;

} else {
toPay = purchaseValue;

}
System.out.println("You need to pay:

" + toPay);

B2 Programming

Note that the brackets can still be used even if only a single instruction is included in the IF or
ELSE part.

'

' Python
:

toPay = 0

1 purchaseValue= float (input ("Enter the value of your goods:"))
:

if purchaseValue>=100:

:

discount = purchaseValue * 0.2

:

toPay = purchaseValue - discount

| else:
:

toPay = purchasevValue

: print ("You need to pay:

",

toPay)

As you may have realized, the block of code can even be further expanded to include another
I statement inside the current one. (One IF statement inside another is called a “nested IF".)
IF condition THEN
IF condition 2 THEN

ELSE
ENDIF
ELSE

END IF
M General structure

condition 1

statement 3

o

Yes

7
M Nested IF flowchart

B2.3 Programming constructs

statement 1

—L

statement 2

Java
boolean member = false;
toPay=0;

System.out.println("do you have a membership card(true/
false):

");

member = read.nextBoolean();

if

:

(purchaseValue>=100)

if (member == true)

{

:

{

i

discount = purchaseValue * 0.2;
toPay = purchaseValue-discount;

} else {
toPay = purchaseValue*0.9;

}
} else {
toPay = purchaseValue;
¢

System.out.println("You should pay:

" + toPay);

In this case, a new variable was included that will decide whether the discount is 20 per cent
or 10 per cent, depending on whether or not the buyer is a member. Also, observe that, as there
is no requirement to display the discount value, you could have calculated the due amount by

simply multiplying the purchase price by 0.9, thus applying the discount of 10 per cent.
i
1

g

gy iy Sy

S
1

i1 Python

i

1

:

1

toPay = 0

:

I purchaseValue= flcat (input ("Enter the value of ycur goeds:"))

1

:

:

member = input("Do you have a membership card

(true/false)?")

: member = eval (member)

:

: if purchaseValue>=100:

:

:

:

if member == True:

1
1
1
:

discount = purchaseValue * 0.2
toPay = purchaseValue - discount
else:

:
1i

1
1
1
:

toPay = purchaseValue * 0.9

:

else:.

1
toPay = purchaseValue
1
1 print ("You need to pay: ",
1

1i

1
1
1
1

toPay)

L

4

The value input and stored into the member variable should be a Boolean value. However, if
there is an attempt to check whether the value entered is True or False by using the bool
keyword instead of eval, it will not return the right answer: bool checks whether or not
the string entered is empty and, as the user will write True or False, the value of the variable
member will always be True as the string is not empty. Therefore, the eval function is used
in this situation, to ensure the value entered is evaluated to True or False and then stored

into the member variable.

B2 Programming

However, there is another way of solving this problem, by using the and logic operator in
the condition.

if

(purchaseValue>=100 && member==true)

{

discount = purchaseValue * 0.2;
toPay = purchaseValue-discount;
} else if

(purchasevValue>=100 && member==false)

{

;

toPay = purchaseValue*0.9;

} else {
toPay = purchaseValue;

!
System.out .println("You should pay:

" + toPay);

........................................................................................................ Baessssasasssitstisisntattn

In the example above, both conditions should be met (to be a member and purchase value to be

100 or above) for the discount of 20 per cent to be applied. The second condition is checking
whether both conditions are met again, but this time they should have a purchase value of 100
or above, but not be a member. The statement executed on the else branch is the statement
happening if the purchase is not 100 or above.
I,

o,

i

i

s

s

S

1 L]

E Python

i

: toPay = 0

:

:

purchaseValue= float (input ("Enter the value of your goods:"))

:

I

member = input ("Do you have a membership card

1

:

member = eval (member)

:

:

if purchaseValue>=100 and member==True:

:

(True/False)?")

:

discount = purchaseValue * 0.2

:

:

toPay = purchaseValue - discount

:

| elif purchaseValue>=100 and member == False:

!

:

:

:

toPay = purchaseValue * 0.9
else:

:

:

toPay = purchaseValue

: print ("You need to pay:
o

R

:

",

R

toPay)
R

R

R

:
R

R

e e R

R

e e e e e e e

e e e me em ee ee o

In Python, else if isreplaced by the keyword elif.
Conditions can use other logic operators, such as OR and NOT.
In case you wanted the discount to be applied if the purchase value was 100 or above or the

buyer owned a membership card, the OR operator would replace the AND operator in the
condition above, for example:
[

: Java

i Python

H

if

(purchaseValue>=100

B2.3 Programming constructs

||

member)

(I
:
1
g

if purchasevValue>=100 or member:

1

1
1
1
1

As in the example above, a comparison with a true value can be written by using the
conditional statement if, followed by the variable that needs to be evaluated to true:
if (member)

This will evaluate to TRUE if the member stores the value true, and to FALSE otherwise.
Therefore, the expression if

(!

member) inJavaor if not member: in Python would

return TRUE if the member variable stores a value of false, and it would return FALSE if the

variable stores true; this expression being read as if not member.
Other relational operators can be part of the comparison, such as: ==, 1=, <, >, <=
Because = is used in assignments, == is used in comparisons to check for equality.

1

Construct code to let the user input their favourite food. If the user enters pasta, PASTA or

Pasta, output the message “Go to Italy”. Otherwise, output the message "[favouriteFood]
will never replace pasta!”
2
3

Construct code that requires the user to input a number and a Boolean variable £1ag. If the
flagis true, output double the number. Otherwise, output the squared number.
Retirement ages differ for men and women. In some countries, women can retire at the age

of 62 and men at 65. Construct a program that asks the user to enter their name, gender and
age. Calculate and output whether the user is eligible for retirement, or how many years they
need to wait to get their pension.
4

Construct a program that requires the user to enter the measurements of the sides of a right-

angled triangle. Calculate and display its area.
5
6

Construct code to create a calculator that converts temperatures between Celsius
and Fahrenheit.
(Construct code to create a quiz that asks the user to guess the capital city of five different
countries of your choice. Add a score to your quiz. At the end, display the right answers for

the missed questions and the score.
7

Construct a program that asks the user to enter their favourite colour and their lucky number.
If their favourite colour is green and their lucky number is between 4 and 7, output the
message “In [LuckyNumber] years, you'll buy a [colour] bicycle”. Otherwise, if the lucky
number is below 4 and above 1, output the message "I suppose you wanted a [colour]
ball [LuckyNumbex] years ago”. Otherwise, display the message *[LuckyNumber] is not
50 lucky!”

8

Construct code that requires the user to input two numbers. Compare the two numbers
and output the larger one. If the two numbers are the same, output an appropriate

message instead.

B2 Programming

(®Tok
How does reasoning affect decision-making?
Reasoning involves analyzing, evaluating and drawing conclusions from given facts, data and
processes between them. Those are important skills in making effective decisions, as they allow you
to clearly define problems and goals, by selecting the relevant details and ignoring the unnecessary
ones, analysing possible solutions, generating ideas and proposing efficient solutions.
The word “decision” cames from the Latin decidere, meaning "to cut off”. In order to make a
decision you need to consider and cut off alternative solutions. Reasoning plays a critical role in first
identifying available options and then evaluating their consequences. However, decision-making
often involves a blend of reasoning and other factors that may constrain rationality, such as biases
and emotions.
In exploring the role of reasoning in dedision-making, discuss the importance of logic, analysis,
critical thinking, problem-solving techniques, acquired skills and purpose in reaching well-informed
and effective conclusions.

Thinkers: Use critical and creative thinking skills to analyse and take responsible action
on complex problems. Exercise initiative in making reasoned decisions.

B2.3.3 Loops and iteration
Consider a scenario where you need to display your name multiple times. Initially, you might
achieve this by writing individual print statements for each repetition. However, this approach

quickly becomes cumbersome when dealing with a larger number of repetitions, such as
100 times. Moreover, if you want to repeat the actions based on user input or until a certain

condition is met, manually writing each repetition becomes impractical. To handle such
situations efficiently, loops come into play.
Loops provide a way to execute a block of cade repeatedly, either for a predetermined number
of iterations or until a specific condition is satisfied. Whether you know the exact number of

repetitions in advance, or need to iterate dynamically based on runtime conditions, loops offer
a flexible and concise solution.
Loops are used to repeat different instructions or blocks of code. One loop refers to one
repetition. There are several types of loops, such as count-controlled loops (FOR loops) and
conditional loops. Conditional loops can be pre-condition loops (WHILE loops) or postcondition loops (REPEAT-UNTIL loops).

B Count-controlled loop
A count-controlled loop (FOR loop) is used when the number of repetitions is known in advance,
prior to the execution of the code. For example, if you need to write all the numbers between

1 and 100, before writing any code it can be said that the program will repeat 100 times.
loopifrom0Oton
end loop

M General structure

B2.3 Programming constructs

True

statement

False

i=i+1

B Count-controlled loop flowchart

If n is the number of repetitions required, a FOR loop would look like this:

Python
for(int i = 0; i<n; i++)

{

for i in range

//code to be repeated

(0,n):

#code to be repeated

}
In Java, i = 0 is the starting point of the repetition, so 1 is initialized to 0.

1<n is the

condition to be met so, when 1 is no longer smaller than n, the repetition will stop. As the
variable 1 was initially 0 to avoid running the code to infinite, the value of i needs to be
changed with every reperition. In this case, i is incremented (i++).
In Python, the range indicates the initial value of i (in this case, 0) and the ending value of i
(in this case, n). Note here that the code will stop when i becomes n-1. For example, ifn =
5, 1 will take the values of 0, 1, 2, 3, 4. There are five repetitions in total; when i reaches the

value of 5, the repetition will stop and so the value won't be displayed.
In the example above, because the starting point is 0, which is the default value, the statement
could have been written as for i in range (n) : and it would have had the same effect.
In both Java and Python, the starting point can be changed. Consider that you must display all
the numbers between 1 and 100. To solve this problem, you can set the starting point to 1 and
the ending point to 101, ensuring 100 is also included.

.
:
8
:

for(int i = 1;

i<101;

i++)

)
System.out.println(i);

{

1

1 Python
:

i
1
-

for i in range

print (i)

(1,101):

1
1
1
1
1
1
1

e
e
Ll

Fesssssnsssssassssasnnnes rerransanas sessssssssssasanarsrnnnrans

B2 Programming

The Java example could have used the less-than-or-equal-to sign in the condition to ensure the
upper bound of 100 is included. Alternatively, the loop could have been maintained to iterate
from 0 to 100, with the printing statement adjusted to display the value of 1+1
vem te

T

M

A

R

: Java

A

TP

I

R

instead.
U

PN v

' Python

for(int 1 = 1;

i<=100;

i++)

{

System.out.println(i);
}

:

:

for i in range

1
1

print (i+1)

o

(100):

:

1
1

e e

e

e

e

e e

-

Imagine wanting to display all the odd numbers between 1 and 100. A solution would be to
keep the same structure as before, but to check whether or not the number is odd.

T
e———

¢ Java

g

'

T

3 e

E Python

for(int 1 = 1;

i<=100;

if (i%2 == 1)

}

i

i++)

{

i

:

-

i

for i in range

(1,100):

:

{

:

if (1%2 == 1):

L

System.out.println(i);

1

print (i)

1

o

i A S SR
T ST H

}
i%2==1 checks whether the remainder of division by 2 of the variable i is 1. In other words,
if there is a remainder, the number is odd; if there is no remainder, the number is even.
The same problem can be solved without the need to use an IT statement. A step can be
included to change the incrementation so, instead of incrementing the value of i by 1, which is
the default value, it increments it by a ditferent value.

R
Y PP e

Java
for(int i = 1;

}

.
i<=100;

i=i+2)

{

System.out.println(i);

eT

1 Python
:

|

for i in range

i
(1,100,2):

print (i)

:

1

A ———— :

In this situation, in Java, the increment was changed, so the value of i is increased by 2, and in

Python a step was included: 2, to specify the same thing. So, the variable i will take the values:
1,3,5,...99

But what if you are requested to display the numbers from 100 to 1 instead?

[

e N RGeS v

: Java

' Python

i for(int i = 100; i»0;
H

System.out.println(i);

H

E

i=i-1)

{

:

: for i in range
1
|

}

B2.3 Programming constructs

print (i)

:
(100,0,-1):

:
1
1

T
—— a

In Java, the starting point is set to 100, so that value is displayed first. The condition is
changed, as you want to repeat as long as the value is greater than 0, and also the step is
changed to decrement the value instead of incrementing it. i=1-1 could be written as i--.

In Python, the range is changed to start at 100. It should stop when it reaches 1 (0 is not
touched) and the step is set to —1, so the number is decremented by 1.

B Pre-condition loop
-0
loop while

i=1+1

end loop

M General structure

l
initialization

True

EFalse

'

# Termination
condition: a condition
in a loop that interrupts
or stops the repetition.
# Validation: a process
to ensure input data is

statements

M Pre-condition loop flowchart

A pre-condition (WHILE) loop is used when the number of repetitions is not known prior to
the execution of the code. The code is expected to be repeated as long as a condition is met, or

it evaluates to true.
When the condition is no longer met, called termination condition, the loop execution will

sensible or reasonable.

stop. In a WHILE loop, the repetition might not run at all; this happens when the condition is

# Verification: a

never met. WHILE loops are loops that are often used for validation or verification purposes.

process to ensure input

For example, when the user is asked to enter a password twice, the computer will compare

data is accurately copied
from one source to
another.

the two entries to check if they match (double entry verification). In this case, a loop would be

used to repeat entering the password until the two inputs match.

B2 Programming

Java
String password, pass;
password = "apple";
System.out.println("Re-enter the password:");

$

pass = read.nextLine();

while

(! password.equals(pass))

{

System.out .println("Re-enter the password:");
pass = read.nextLine();

}
System.out.println("The two passwords matched");
........... T T

L

I

T

ey

In this case, .equals is used to compare the value stored in password with the one stored
in pass, as those two values are of type string. If the two values were numbers, then ==
would be used for comparison. The ! is a negation, therefore, in this case, it is checking if the

two values are not the same, and the user is asked to re-enter the password until the two values
match. The outpur at the end will be displayed only after the loop is exited. If the second

password never matches the first, the code inside the loop will continuously repeat.
Any FOR loop can be rewritten as a WHILE loop. Considering our example that displays all
the numbers between 1 and 100, using a WHILE loop the code would look like this:

Java
int i = 1;
while (i<101)
:

{

E Python

i

:

:

i=1

: while(i<101):

System.out .println(i);

:

print (i)

:

i = i+1;

:

i=i+1

:

In the example above, the loop will repeat as long as i is smaller than 101. The termination
condition will be that 1 >=101. The role of the incrementation is to change the value ot i, so
the loop will stop at one moment. Otherwise, without that statement, the loop would run
to infinite.

B Post-condition loop
i=0
repeat

i=i+1

until i >=n

M General structure

B2.3 Programming constructs

:

statements

i=i+1

Yes

l

M Post-condition loop flowchart

In the post-condition (REPEAT-UNTIL) loop, the condition is checked at the end. In this case,

the code inside the loop will execute at least once.
Both in Java and Python, post-condition loop structures are written using WHILE loops.

Java

i Python

i

int 1 = 1;

:

:

do {

: while (True) :
System.cut.println(i);

:

} while(i<=100);

B

R

e

e e

:

print (i)

:

-

i=isl

:

i

:

if i-100:

:

ee

1

break

1

i= di+1;
:

i=1

R|

In the example above, the variable 1 is initially set to 1. This value is displayed and then
incremented. This happens no matter what the condirion evaluates to. If the condition
evaluates to true, the loop is repeated; if the condition evaluates to false, the repetition stops.

B2 Programming

Non
AR W N =

Define the term “loop”.
Explain why it is useful to use loops in coding.
Explain the difference between a pre-condition and a post-condition loop.

Identify a situation when you would use a count-controlled loop.
Define the term “termination condition”.
Explain why it is important to avoid infinite loops.
Identify a situation where an infinite loop could occur.

1

Construct a program that allows the user to entera number. Output all numbers between 1
and that number.

2

Construct code that requires the user to enter a number and a word. Display each letter in
the word on a separate line. Repeat the process the user's number of times.

3

Construct code that asks the user to input ten numbers. Calculate and display the sum of all
even numbers entered.

4

Construct a program that creates a variable and initializes it to the value 7. Ask the user to
guess a number between 1 and 20. If the user guesses the value 7, output the number of
attempts. Do not allow the user to try to guess the number more than three times. If the user
doesn’t guess the number after three attempts, output the message: "The game is locked.

Try again later!”
5

Construct a program that asks the user whether they want an apple. Repeat the question
until their answer is yes. At the end, output the message: “Apples are delicious, aren't they?
Let's have one!”

Use your answers to the programming exercises above to answer the following questions.

( .TDP tlp'

When you are asked

1

2

to identify the type
of loop exemplified

What loop did you use to solve question 1? Could you replace that loop with another
one? How would you do that?

Did the program you constructed to solve question 2 handle user input correctly? Can
you think of an easier way to extract each letter from a given word?

3

in a piece of code,

Did your program for question 3 extract the even numbers correctly? What change

would calculate the sum of all the odd numbers instead?

refer to them as

4

count-controlled,

5 What termination condition did you use for question 57

Why do you think a FOR loop is not appropriate for solving question 4?

pre-condition or postcondition loops. For

eS

a FOR loop instead of

( ® Key information

a "count-controlled”

FOR loops are called "count-controlled” loops, WHILE loops are called “pre-condition” loops and

loop is not enough, as

REPEAT-UNTIL loops are called “post-condition” loops.

it is not clear that you
know what type of
loop a FOR loop is.

Count-controlled loops are used when the number of repetitions is known prior to the execution
of the code. Pre-condition loops might not be executed at all (if the condition is not met). Postcondition loops will execute at least once, even if the condition is never met.

B2.3 Programming constructs

B2.3.4 Functions and modularization
TFunctions represent blocks of code that can be reused in various parts of the program and
# Maintainable code:
clear, easy-to-read and

modify code that can be
reused within the same
program or in other
programs, by the same
or other programmers.
@ Procedure: a set of

statements that can be
grouped together and
called in a program

include a return value. Using functions makes the code look neater, and it saves development
time as they can be reused as needed. At the same time, they allow for modularity, meaning
multiple programmers can work together, each developing a function and then those functions
can be put together to build up a more complex program. Once a function has been written
and tested, the programmer can reuse it without worrying about its functionality.
Writing maintainable code is an important skill for any programmer. Maintainable code refers
to code that is clear; easy to read and modify; and can be reused by the programmer themself
or by other programmers. Using functions aids in the creation of maintainable code.
Such a reusable block of code is called a procedure or a function; the difference between the
two being the returned value(s). A procedure can take several parameters or none and it has no

as needed; they don't

return value, so it could update a variable or output a message or a value. However, a function

return a value.

will return a value. This returned value can further be used in a mathematical expression, or it

# Function: a set of
statements that can be
grouped together and
called in a program as
needed, they always
return at least one value.

can simply be displayed.
Consider the following problem: A user is required to provide two whole numbers. Construct a
program that calculates the sum of the two numbers and displays it.
A simple solution would be to ask the user to enter the two numbers, add them together and
display the result, such as:

Java
read = new Scanner (System.in) ;
:

int nol,

!

System.out.println("enter
nol:");
(

no2,

sum;

i:

nol = read.nextInt();
(

ii

System.out.println("enter no2:");

i

(

no2 = read.nextInt ()
sum = nol+noz;
System.out.println("The result is

"+ sum);

e
T

E Python

i

:

nol = int(input ("enter nol:"))

:

: no2 = int(input ("enter no2:"))

:

:

:

sum = nol + no2

: print ("The result is ", sum)
:
e
———————
M Solution 1

But if you needed to perform the same operation again, with different values, you would have
to rewrite the code, which is not very time or memory efficient. Therefore, to complete such

tasks, a procedure is required.

B2 Programming

private static Scanner read;
public static void add()
int nol,

no2,

({

sum;

System.out.println("enter
the first number:");
(
nol = read.nextInt ( )i

sasasssssssrsnnnrerenrrrnnnay

Java

sum = nol+no2;

System.out.println("The result is "+ sum);
public static void main(String[]

args)

{

read = new Scanner (System.in);

H
H

H

H
HH
HH
H

H
HH
:H
H

HH
HH

add
() ;

HH

T T TR TR T T P TP TPP TP R T TT TP

Y

System.out .println ( "enter the second number:");
no2 = read.nextInt/();
(

Python
def add():
nol = int (input("enter nol:"))
no2 = int(input("enter noZ2:"))
sum = nol + no2
print ("The result is

",

sum)

add ()

M Solution 2

Because this does not return the sum, but only prints it, it is a procedure.
Java
HH
H
HH
HH

private static Scanner read;
public static void add(int nol,

H

int no2)

int sum;

HH

sum = nol+no2;

H

System.out.println("The result is "+ sum);
H

}
public static void main(Stringl[]

args)

{

read = new Scanner (System.in);
int valuel,

value2;

System.out.println("enter the first number:");
valuel = read.nextInt();
System.out.println("enter the second number:");
value2 = read.nextInt
()
add (valuel,

B2.3 Programming constructs

wvalue2);

Python
def add(nol,no2):
sum = nol

+ no2

print ("The result is ",

sum)

valuel = int (input ("enter nol:"))

value2 = int(input ("enter no2:"))
add (valuel,

value2)

M Solution 3

In the code above, the same procedure is created, but two parameters are passed to it {(nol
and no2). When the procedure is called in the main program, the values being passed to it are
called “arguments” (valuel and value2).

When a return is added to the block of code, the procedure becomes a function. The returned
value can be displayed on the screen or used in other mathematical expressions. The number
of parameters also differs when it comes to functions: one, none or more parameters can be
passed to a function.

When implementing functions in Java, the void keyword from the method signature is
replaced by the data type of the value being returned.

. Java

:

: private static Scanner read;
public static int add(int nol,

i
int no2)

{

int sum;
g

sum = nol+no2;

E

return sum;
public static void main(Stringl[]

;
args)

{

read = new Scanner (System.in);
int valuel, value2;
System.out.println("enter the first number:");
valuel = read.nextInt();
System.out.println("enter the second number:");
value2 = read.nextInt();
System.out.println("The result is "+ add(valuel,

value2));

int newVal = 3;
newvVal = newVal + add();

System.ocut.println("The new value is "+newVal);

B2 Programming

Python
def add(nol,no2):
sum = nol + no2
return

sum

valuel = int (input("enter nol:"))

value2 = int (input("enter no2:"))
print ("The result is

",

add(valuel,

wvalue2))

newVal = 3
newVal = newVal + add(valuel,

print ("The new value is ",

wvalue2)

newVal)

In the example above, the function add will return a value of data type integer.
The function is called once to be displayed and the other time to increase the value of the

variable newval.

Compare functions and procedures.
Identify three things you can do to keep a maintainable code.
3

Qutline the difference between validation and verification. Provide an example where a
selection can be used for validation checks.

4

Differentiate between pre- and post-condition loops.

1

Construct code to let the user create a function called factorial that takes a natural
number (n) as a parameter. The function should return the factorial value of that number (n!).

2

Construct a program that consists of a procedure called odds that takes a natural number (n)
as a parameter. The procedure should display all the odd numbers from 1 to that number (n).

3

Construct code that creates a function called perfect that takes n (a natural number) as a

parameter. The function should return true/false if n is a perfect number.
A perfect number is a positive integer that is equal to the sum of its positive proper divisors,

excluding the number itself. For example, 28 is a perfect number as its proper divisors
are: 1, 2,4, 7, 14. Adding those values together we get 28, and this result is equal to the
initial number.
4

Construct a function called palindrome that takes a word as a parameter. The function

should return true/false if the given word is a palindrome.
A palindrome is a word that reads the same forwards or backwards. For example, kayak,
racecar, level and civic are all palindromes.
Reflect on the errors you encountered when constructing your code, and how you resolved them.
B

How did you go about debugging the issues?

B Did you notice any patterns in the errors you encountered?
B What can you do to avoid such errors in the future?

B2.3 Programming constructs

B Scope of variables
# Local variable: a
variable that exists only
within the block of code
where it is defined.
# Global variable:
a variable that exists

Based on their scope, variables can be classified into various categories, such as local or
global variables.
The scope of the variable defines its lifetime in the program, meaning the block of code where
it has been declared, where it can be used and modified. How and where the variables are
declared detines the scope.

throughout a program.

Local variables

4 Variable scope: the
lifetime of a variable

Local variables are variables that have their scope limited to the block of code within which

within a program; it

determines whether you
can access and maodify
the variable within a
specific block of code.

they are declared and used.
Once that block of code is executed, the variable is automarically removed from the memory.

It is recommended to use local variables as often as possible. An example of a local variable
is when using a counter in a FOR loop. That counter is required only within the body of the

loop for storing temporary data but, once the loop is finished, you do not need that counter
any longer.

¢ Java: i is a local variable

for(int i=0; i<3;i++) {
System.out.println("helloc world");
T
P T PP srrrrrsnrens srrrrssnrane B
L R TP PR TP PPCETTRYS sarasrsanans s

As i is a local variable, it exists within the loop, and it will take values trom 0 to 3. When it

reaches 3, the variable is no longer smaller than 3 and the repetition will stop. After this loop,
the variable i does not exist any longer.

Python: text is a local variable
def hello():
# text is the local wvariable
text =

"hello world"

print (text)
# code to text
hello()
# the print below will throw an error as text does not exist
# outside the procedure
print (text)

In this example, text is the local variable. When printing the variable text inside the
subprocedure, the message “hello world” will be displayed. However, when attempting to print
the text again, after the call of the method, an error will be thrown as text is used without

having an initial value.

Global variables
Global variables are variables that are visible and accessible throughout the program.
In Python, the global variables are initialized at the top of the code or module and, whenever

they are used within a function or procedure, they are declared as global. As Java is an

B2 Programming

object-oriented programming language, it does not use the concept of global variables.
However, by using the static or static final keywords, the variables can have all the
properties of global variables.

Python
text =

"hello

"

def hello():
# text is a global wvariable

global text
# text is concatenated with a new text wvalue
text = text +

"world"

# Driver code
hello()
print (text)

B

e

L

T

L L

e

In this example, the text is a global variable, which means that, by calling the hello

procedure, the content of the variable text is changed and, once it is printed, even if it is
printed outside the procedure, it will display the updated content: hello world.

(.-Top tip!
When writing code, aim to preponderantly use local variables rather than global variables. Local
variables are confined to the function or block in which they are dedared, promoting encapsulation
and modularity. This makes functions self-contained and easier to understand, test and debug.
Global variables can be madified by any part of the code, leading to unintended side effects that
can make the program behaviour difficult to predict and debug. Local variables prevent such side
effects by limiting the scope of variable modifications.

1

Trace the following program to determine its output.

. Java
static String student = "Bob";
public static void changeOfName (String st)

{

System.out.println("Student inside the method:

"+st);

}
public static void main(String[]

args)

{

changeOfName (student) ;

System.out.println("Student outside the method:
student) ; }

B2.3 Programming constructs

" +

student =

"Bob"

def changeOfName
(st) :

st = "Bobby"
print ("Student inside the method:

",

st)

changeOfName (student)
print ("Student outside the method:

",

student)

Identify a local variable in the code above. Explain why the chosen variable is not a
global variable.
Construct a program that changes the code above so that, after the method is executed,
both outputs display the name lim, without changing the first line of code.
Construct code to update the method above to include a validation check: the new name

should be input from the keyboard and the change should occur only if the new name is
different from the previous name. Display a message if the new name is not different and
display the current name.

Identify the scope and data type of the variable you have created to validate the
name change.

B2 Programming

Programming fundamentals
(part 2)
How can we apply programming to solve problems?

SYLLABUS CONTENT
By the end of this chapter, you should be able to:
P B2.1.3 Describe how programs use common exception handling techniques
» B2.1.4 Construct and use common debugging techniques

B2.1.3 Exception handling
‘When a computer program is run, different reasons or events might cause the program to halt
or produce an unexpected outcome. These reasons could include logical errors in the code,
unexpected user inputs or resource unavailability.
# Logic error: an error

in a program that makes
it operate incorrectly;
it will not crash the
program.
# Runtime error: an

error that occurs when
executing a program,
the program might stop
unexpectedly.
# Exception handling:
a process of responding
to an exception, so the

Logic errors refer to incorrect sequences in the logic of the program, incorrect choices of
condition or incorrect calculations. For example, when attempting to calculate the average of
three numbers, dividing the sum of the three numbers by 2 instead of dividing it by 3 would

produce an incorrect outcome.
Such errors can only be detected through testing, as they would pass the compilation stage.
Runtime errors could cause the program to crash. These errors refer to problems occurring
as the program runs, such as division by 0; a file not being found; truncation; overflow or
underflow errors; a hardware device not being available, such as a printer not being ready; or a
class tile not being found.

Also, a user can enter unexpected inputs, such as entering text instead of a number or entering
values that would lead to an attempt to divide by 0, or entering the wrong file location to read

system does not halt
unexpectedly.

data from or write data to.

# Exception: an

operation, such as a file not being found or a printer not being ready for the operation.

unexpected event that
stops the execution of

All those events can be dealt with, so the program does not crash, using exception handling.

Resource unavailability refers to hardware and software equipment not being available for the

a program, e.g. division

Even if the desired operation would not be achieved, the user can get an idea of what went

by 0.

wrong, and they can continue attempting other features of the program.
The role of exception handling techniques is to maintain the normal flow of the program, by

catching and throwing exceptions that cannot be handled locally. In Java, this takes the form
of try/catch blocks, while in Python they are found as try/except blocks. The code

that might throw an error is written within the try block and the exception is caught and
displayed, if needed, in the catch/except block. Both languages allow for a finally block
that is found at the end of the try/catch or try/except block and this includes code
that will always execute after leaving the try statement, regardless of the try block outcome:

whether or not it raises an error.

B2.1 Programming fundamentals (part 2)

Java
read = new Scanner (System.in) ;
System.out.println("Enter a number:
int number = read.nextInt();
int result;

try{
result

10/number;

System.out.println(result);

}
E catch(Exception e){
E

System.out.println(e.toString());

! finally {
System.out.println("This would be printed anyway");

}
P

; Python
i

number = int (input ("Enter a number:

I

try:

:

result = 10/number

:

print (result)

:

except ZeroDivisionError:

:
:

print ("You can't divide by zero")
finally:

:
b

print ("This would be printed anyway")
o o o o o

e e e e e e e e e e e e e R R e e e e e R e e R R e e R e e e R e e e e e e R e e e

In the example above, the user is requested to enter a number. If the number entered is 0, then
this would be caught in the exception; otherwise, the calculation will be performed and the
result displayed. Independent of the action completed, the message included in the finally
block will be displayed.

read = new Scanner (System.in) ;
System.out.println("Enter a number:
int number = read.nextInt
() ;
int result;

try{
result = 10/number;
System.out.println(result);

}
catch(Exception e) {
System.out.println(e.toString());

B2 Programming

r

1
1 Python
1
)
_
_
I number = int (input ("Enter a number:
1
1

bl

1
1
1
1
1

"))

try:

1

:

result = 10/number

:

:

print (result)

:

: except:
]

:

print ("There was a problem!")

1

15

1

1
4

The exception handling construct can include only a try/catch block in Java, or justa
try/except block in Python. There is no need to specifically indicate the type of error that
might have caused the program to crash, but this is useful to help the programmer debug the
code and fix issues that might be solved or to let the user understand the problem if the wrong
input is provided.

(;Key information
"Exception” refers to the event that interrupts the execution of a program, while “exception

handling” refers to the actions taken to deal with an exception or how the system is prevented
from halting unexpectedly. For example, a division by 0 is an exception; using a try/catch or try/

=

Explain how exceptions differ from errors.

N

Explain why it is important to handle exceptions in your code.

W

Identify some common types of exceptions.

A

Explain a scenario when a runtime error could occur.

v

except block is the exception handling technique.

Explain the risks of showing detailed exception messages to end users.

B2.1.4 Debugging techniques
# Debugging: finding
and fixing errors in
a program.
# Trace table: a
technigue used to test
an algorithm, and to
predict how it will be
run and how values of
variables will change.
# Breakpoint: a
marker to interrupt the
execution of code for
debugging purposes.

Debugging refers to finding and fixing errors in code. Common debugging techniques include
trace tables, breakpoint debugging, print statements and step-by-step code execution.

B Trace tables
Trace tables represent a technique usually used at design stage to test an algorithm and predict
step by step how it will run. They can be used to demonstrate the outcome of an algorithm or
to identity logic errors.
A trace table is a table in which the columns represent variables, conditions or an output in the
algorithm. However, not all variables, conditions or outputs are always needed; this depends
on the purpose of the trace table.
Its role is to identify how variables change, what conditions evaluate to and what are
the produced outcomes. By producing a trace table, the purpose of the algorithm can be
determined or any flaws in the algorithm can be detected.

B2.1 Programming fundamentals (part 2)

For example, consider the following problem: Students taking a language course will pass
their final examination if their score is 80 or above. As the students register for the course
every term, the number of students is unknown. Therefore, the teacher will enter 999 to

terminate the program. The teacher is required to identify the number of students passing
the assessment.

The following flowchart has been designed to suggest a possible solution to the problem:

count <- 0

i

INPUT score

;

w Yes —l

No

score >= 80

Yesj

OUTPUT count, " students have
passed the exam”

count <- count + 1

No

|

The trace table for the input data would look like this:
23,08, 33, 45, 78, 80, 81, 84, 34,999
count

score

0

23

output

98
1

33
45
78
80

2

81

3

84

4

34
999

4 students have passed the exam

B2 Programming

When the value 98 is entered, the count is incremented. 33, 43, 78 will not affect the count,

so its value stays the same. You might choose to repeat the previous value for the count
variable, or just leave it blank as there is no change. Be aware if there is a statement reassigning
the value of the variable to something, then even if the value is the same as the previous one,

it should appear within the count column, as that is a change to the variable. When value 80
is entered, the count is incremented again, and the procedure repeats for the values 81 and

84, but nothing happens to the count when 34 is entered. 999 is the value that will terminate
the program, and so the output will be displayed, as the output is displayed only after 999 is

entered, in this example.

il

The following flowchart represents an algorithm.

temp <-0

value <- num

Y

reminder <- value MOD 10
value <- value DIV 10
temp <- temp*10 + reminder

.

A

DJ

temp = num

QUTPUT false

B2.1 Programming fundamentals (part 2)

No

T

value > 0

Yes

l

(Y
e

STOP

1

Copy and complete the trace table below for the value: 1221.
num

2

temp

value

reminder

value >0

temp = num

output

temp = num

output

Copy and complete the trace table below for the value: 1231.
num

3

temp

value

reminder

value > 0

Identify the purpose of the algorithm represented by the flowchart above.

B Breakpoint debugging
Breakpoints are special markers that interrupt the execution of the code for debugging

purposes. To set a breakpoint in Eclipse IDE, it is sufficient to right-click on the blue section
beside the line number and toggle a breakpoint as shown in the screenshot below (this differs
from IDE to IDE).

5

Prmsmse

78
8
«: 9
e

= susms SemEiEs

|S

public static void main(String(] args) {
read = new Scanner(System.in);
____System.out.printin("Entera number: ");

Disable Breakpoint

©Double Click

@ Toggle Lambda Entry Breakpoint
&< Toggle Tracepoint

=] Run to Line

X Click

Go to Annotation

fways™);

+ Show Quick Diff
+ Show Line Numbers

Folding

>

Preferences...
Breakpoint Properties...

3 Double Click

3F

36

M Breakpoint debugging in Eclipse

B2 Programming

After setting up the breakpoints, the next step is to run the program in debugging mode. This
is done by clicking on the Debug button (the one next to the Run button), which looks like a
little bug, as shown in the image below.

ene

eclipse-workspace - sum/src/

r3-m-

Qinir

B

22

15 Debug X () Project Explorer

|-

|

L -|

0-Q-Q- & 4-

e
:’m

1 addition

« [T} addition [Java Application]
wi [Usersfioansganesl.p2jpociipluginsiorg.eciipsejust

1o 71 2 Competitions
2 11 [T] 3 Swimmer

v [T addition [Java Application]
v sum.addition at localhost:57950

:
[T 4 mainTester
; :

v of® Thread [main] (Suspended)

6

= addition.main(String[]) line: 10

[3) mainTe

Debug As

>

76

:ringl] arg

4! [Users/icanaganeal.p2/poolpluginsforg
eclipse just; &
[T addition (Java Application]
29

Debug Conflgurations...
Organize Favorites...

v {J sum.addition at localhost:57974
v @ Thread [main] (Suspended (breakpoint atline 13

T TR
tew {
’

}?
5

item.in);
iter a nuab

smmmemedINt )

M Running the program in debugging mode in Eclipse

Next, you can see the Breakpoint window that shows the variables, breakpoints and

expressions, as here:

Q
B

s &%

) variables X ®g Breakpoints &5 Expressions

= Ep

& B §
Name

Value

= no method
return value

& args

String[0] (id=19)

@ number

3

O result

3

[~}

=

M Breakpoint window in Eclipse

The code will execute as normal, but it will interrupt its execution the moment it reaches the
set breakpoint.

B2.1 Programming fundamentals (part 2)

In IDLE (Python), there is only a need to right-click on the line where you want the breakpoint
to be set and choose the option Set Breakpoint.
number = int(input(“Enter a number: "})

| trys

result 5|
print{res

CuUI

| except:

print("Th

Copy

)

Paste

Set Breakpoint

Clear Breakpoint
M Breakpoint debugging in IDLE

After that, you can simply run the script (F5). Once this has happened, you can press Debug
on the menu and the debugger window will appear.
—

=
mesber= sntlineuti*Esiee & susters 1)
rerelt = 10/ngmser
srintiresult

SriE"There wet & peablent®)
uni), e 600 sxec|omd, giotals, locals|
e e
), e 2 rurmitae = int{input]*Enter & ramber: “})
ran’ writal], bea 467 5 = s3 encodeds, sell encodng weif.

ane

*IDLE
Shell 3.12.3%

Pythen 3.10.3 (v 12.3:TOASBT00ET, Aor § D024, BR:IB:AT) (Clang 13.0.8 (clang-1

30,0,
9. M1 88 Sarvis
Type “halp™, “copyright™, “credits” or *Licenss(]* for sere informstios,
[ maggmoeames WESTART: fUsaras|
ta/teat. py
Inter & sumberi

3. 3133333333300033%

Lacais
run. 1 Be1085af 280>
Ll <idbellt

wee IDESNG oM

M Debugger window in IDLE

B Step-by-step code execution
To monitor and see what happens with the variables, you have to press Step into / Step over
or use Step filters buttons. If you want to check what happens at the breakpoint line then you
would choose the Step into button, but if you want to skip that line and execute the following

one you would choose the Step over button. In Eclipse, those buttons are the arrows shown in
the following screenshot:

5D
I ™ 0

S

B L O

of aavirwnstion

o sososticions

Qe
[ mentovimiens

] sttioninaX

O

X % Besskpons S Daeessons
e vaesies

I package wum;
1 eioe At

;

Ampert java.util.e]

4

{
public class sddition

pecipresmy

7

|
-

1

[ 7o math o et ewlae

1
2

o -

peblic static weid main(String(] srge) (

& At

o revat

read = svw Scaswer|Systes.{s);

“tater & sumber: =)
Systen.awt.printin

st musher = read.nextintily

st cesalt;
ey{

resalt o U mmber)

Voo

oo

) privete static Scenner resd;

Saringlt] (=19

:

3

-

-

Systes.out.printialresuit);

17
]
e

1
T

catohl Laception oM
Systes.out.printiale. vaString());

]
Fisally {

Systen.aet.prlatIn{"This would be printed anmays”);

W Step-by-step execution in Eclipse

B2 Programming

H Print statements
‘When testing your code, you might ask yourselt whether the execution of the program has
reached a specific line of code, whether a variable changed its value as expected or whether a

decision statement has been evaluated to true or false. Including print statements into your
code to trace such changes is a useful method that would help you identify when exactly your

code stopped running as expected and give you an idea of what went wrong. The only
impediment might be that, once the debugging has occurred and the errors are fixed, you will

have to delete those print statements.

(; Key
information
You need to be able
to construct and use

common debugging

1

Define the terms “exception” and “exception handling”.

2

Identify three possible causes of an exception.

3

Outline three features that support the debugging of the code in an IDE.

technigues. Being

able to complete trace
tables is an important
technique that can be
used to test the logic
and functionality of an
algorithm, to identify
how the variables
change throughout
the running of
the program and

to identify the
expected output of
an algorithm.

Affective skills: Demonstrate persistence and perseverance. Don't give up when you
realize that coding becomes challenging - use debugging techniques to identify the

errors, focus on understanding the errors report and try different approaches to
solving problems.

(;TOK
Language and meaning
We use different programming languages to code, each with its own syntax and grammar rules.
English is not suitable to be used as a programming language because it is ambiguous and many
expressions can be interpreted differently based on the context in which they are used.
Analyse the following statements and identify the possible meanings of each of them:
B Peter and Anna are married.
B A salesman visited every house in the area.
B Look at that dog with one eye.
What are the essential features of a computer language? Why is there a need for a fixed vocabulary,
unambiguous meaning and consistent grammar and syntax?

B2.1 Programming fundamentals (part 2)

Data structures

SYLLABUS CONTENT
By the end of this chapter, you should be able to:
» B2.2.1 Compare static and dynamic data structures
P> B2.2.2 Construct programs that apply arrays and lists
» B2.2.3 Explain the concept of a stack as a Last In First Out (LIFO) data structure
» B2.2.4 Explain the concept of a queue as a First In First Qut (FIFO) data structure

B2.2.1 Static vs dynamic data structures
A data structure is a way of storing and organizing data, so it allows for its manipulation in
an efficient way and attempts to reduce the time and space complexity. Arrays, lists, stacks,

queues, binary trees and hash tables are all examples of data structures. Data structures can be
# Static data
structure: a data
structure with
predefined fixed size
and elements stored
in contiguous memory

static or dynamic, the two differing in terms of storage and access to their elements.
A static data structure has a predefined fixed size, a specific memory space being allocated to
it, that will not change when running the program, and elements that are stored in contiguous

memory locations. Elements in a static data structure can be either directly accessed or
sequentially accessed.

locations.

A dynamic data structure has no predefined fixed size, it can grow or decrease at runtime and

4 Dynamic data
structure: a data

its elements are stored in memory locations that are chained together but are not necessarily

structure that can grow
or decrease at runtime,

with elements stored in
memory locations that

contiguous. Elements in a dynamic data structure cannot be directly accessed.
Static data structure

Advantages

Disadvantages

®

Fast access time, as elements can be directly
accessed via the index (position of the element in
the data structure)

.

Inefficient use of memory, as there is a need to
know in advance the likely size of the structure to
allocate sufficient memory

*

No need to deal with possible overflow or
underflow errors when adding or deleting

*

Memory is allocated, regardless or whether or
not it is needed

are chained together,

but not necessarily
contiguous.
# Direct access: a
method of access where

elements are directly
retrieved by using their

®

elements as the size is fixed

®

Does not allow for flexibility, as its size is fixed

Easier to program; there is no need to check on

®

Deletion of an element might create a vacant slot

its size at any time

code to reuse this space might take time

index (position).

4 Sequential access: a
method of access where
elements are checked
one after another,
from the beginning to
the end of the data

between two other elements, and changing the
*

|nsertion of elements between two other elements
if there isn't a vacant space is time-consuming

Dynamic data structure
Advantages

Disadvantages

*

Allows for flexibility — it can shrink or grow as
needed at runtime (suitable when the size of data
is not known in advance or may change in time)

.

*

Efficient use of memory; as it can resize itself,
there is no memory waste

structure.

*

Insertion and deletion operations are optimal
concerning time and space complexity

The programmer needs to deal with overflow
(the structure might exceed the memory limit)
and underflow (it might attempt to delete an
item from an already empty structure) situations
when inserting or deleting elements

®

Harder to program, as the
nepprogrammer is required
!
always to keep track of its size and data allocations

B2 Programming

B2.2.2 Arrays and lists
Hl One-dimensional arrays (Java) and one-dimensional lists
(Python)
Suppose your teacher wants to store the grades of 100 students. One way to complete this task
is to use 100 variables, but this means lots of memory waste, many lines of code and a lot of
effort. And what if this teacher needs to store 1000 grades?
A better solution is to store all those 100 or 1000 elements under a single name or a single
identifier. The array data structure allows you to do this.
A 1D array (Java) or a 1D list (Python) is a data structure that stores elements of the same data
type, under one single identifier (name). Those elements can be directly accessed by using
an index (plural indices), where the index indicates the position in the array. Some languages
indicate the first index as being the 0 element, and others allow the programmer to indicate

how the items will be addressed.
Tor example, an array of five integers storing students’ grades out of 100 is called grades.
Graphically, arrays can be represented horizontally or vertically.
index (position in array): lower limit: 0, upper limit: 4

ol (1] [21 3] [4)

grades |75|64|95|50|34

array size: 5

64|[1]

grades |95 |[2]
50|[3]
grades[2] = 95

34|[4]

W 1D array (list)

The array element at index 2 (the 3rd element, when counting from 0) can be directly accessed

by using the name of the array followed by the index: grades [2] . Keep in mind that, if the
first element has index 0, the last element is at index 4 (in this case, the grades array has only
five items).

To process arrays, loops are used. Loops can be used to traverse the array; therefore, any time
you perform calculations on all elements of an array, find an element, sort them, and so on,
you will use loops.

One-dimensional arrays (Java)
Array declaration and initialization:
To use arrays in Java, they must be declared, and the language allows for different ways to do
this. First, square brackets [] are used to differentiate between a variable and an array. They

B2.2 Data structures

can appear before or after the array name:
int grades
int

[]; //an array called grades of integers

[] grades; //grades array of integers

i

After deciding where you want to place the square brackets (most often, the first example is
used), you need to specify the size of the array, as it is a static data structure.

Declaration:
int grades([]l=new int[5];

i

//grades array can store maximum 5

//elements

:

If the array is of integer or double or float type, and there is no further initialization of the
array elements, Java automatically initializes all its elements to 0.
Initialization:

{ grades[0]=75;
grades[1]=64;
i

grades[2]=95;

! grades[3]1=50;
¢ grades[4]=34;

At this point, the elements of the array are given specific values, the value 0 being overwritten.
Another way to declare and initialize the array is like this:
int grades[]= new int[]{75,64,95,50,34};

But this can also be rewritten in a simpler way, like this:
Ye
T
TPP

T prr. wes

int grades[]={75,64,95,50,34};

Sometimes, the developer will have to allow the user to initialize the array. In such cases, you
can simply declare the array and use a loop to allow the user to populate the array.
read = new Scanner (System.in) ;
int grades[]=new int[5];

for(int i=0;i<5;i++)
:

!

{

System.out.println("Enter a number:

");

:

int value = read.nextInt();
grades [i] =value;

The loop repeats five times, and it requires the user to enter an integer value that will be stored
into the array indicated by index i (from 0 to 4).

B2 Programming

1f the array is of type string, it would look like this:
String pilots[]=

{"Bob",

Boolean passedExam[ ]

"John",

= {true,

T T T Ty B

"Elvis"};

false,

true};

T T

T

T T LT TT T T PP T

One-dimensional lists (Python)
Python replaces arrays with lists, but you can manipulate those lists to behave like arrays.
In Python, data structures don't need to be declared. Square brackets are still used to specify
that the data structure used is a 1D list.
For example, the grades array will look like this:
:

grades =

FPm

[75,64,95,50,34]

e eeee

: grades =

ee e e

1

e e e e e e

ee

mmm e

:

for i in range(5):

:

#stores value entered at given index

:

grades[i]

o

mm s

————— == 1

[0]*5 #creates an array of 5 zeros
#repeats 5 times

= int(input ("enter a value:

e

:

e e e e

e e M e e e R M R e

:

:
"))

:

R M M M e e e e e e

o

e ww ww owm owwoww o

The first line in the code above specifies the initial value each element in the list will take (in this

case, 0). After the *, it is the size of the list (meaning there are five Os in this list at first).
1f you were to write this line of code as grades =

[ ], when trying the FOR loop an

error would be thrown (index out of range), as the size of the list would be none or zero, so

there would not be a way to add any new elements to it. However, the following statement is
completely valid:

T1 grades =

[]

: grades =

[0 for i in range(5)]

1

TTTTTTTT T i1
:

1

And this is possible because the grades list is overwritten. But this could have been just
like this:

1
1
1

grades =

[0 for i in range(5)]

B

o o

e

o

o o

e e e e

e e

e e e e e e e e

:

1
e e e e

e e e e e

e e

- - -

The purpose of the line above is to initialize the grades list to 0 for all its five elements.
The following two lists are examples of a 1D list of type string and a 1D list of type Boolean:
|5

T

pilots =

i

T

e

["Bob",

"John",

passedExam =

B2.2 Data structures

[True,

e
"Elvis"]

False,

True]

e

e

e s i e Al

i

Parallel arrays: a

T or more arrays
7 of the same size,
i
Parallel arrays represent two
such that
the n™ th element of the

group of arrays of the

first array is related to the n™ element of the second array, and so on. The values stored on

same size, where the

those arrays at a given index will be related in some form, for example defining a record data

element at a given index
in one of the arrays
corresponds to another
element at the same
index in another array,
like descriptions of a

structure to store details about students. So, the first array will store the students’ names,

the second array their ages, the third array their addresses. When retrieving the element of
position 3 from each of those arrays, you'll be able to identify the name, age and address of the

third student.

1

Construct a program that creates a 1D array or list that stores six integer values. Output true
if the first element in the array is the same as the last element in the array.

2

Construct code that requires the user to enter a number. Use that number as the size of
an array or list of integers to be inputted from the keyboard. Calculate the sum of all even
numbers in the array or list; calculate the average of all its elements; and count how many of
those elements are odd numbers. Display those values.

3

Construct a program that creates an array or list that stores five names. Copy those elements
in a second array or list in reverse order. Display the second array or list.

Use your answers to the programming exercises above to answer the following questions.
1 What data type was your output for question 1? Was it a Boolean or a string variable?
Which one do you think is more appropriate?
2 What was the initial value of the count variable you used for question 2 to count
how many array elements were odd? Why was it important to set an initial value for
this variable?
3 Did the results for question 3 display accurately? What loops did you use to traverse
the arrays? Could those loops have been replaced by other types of loops? Which
are those?

GCommon mistake
Algorithms written to solve a problem should function correctly. When asked to construct an
algorithm that finds the smallest value in a 1D array or 1D list, many candidates initialize a variable
called min to 0 and then compare each element in the array with that one to find a smaller value.
The data structure could store only pasitive numbers; therefore, you will not find a value smaller
than 0.
Remember to initialize that variable to the first element in the array. In this case, if no other
element is smaller, you have already stored the smallest one.

B2 Programming

Bl Two-dimensional arrays / lists

column

[6]

[1 ]

[ 2]

A two-dimensional array can be seen as a table, with rows

and columns. To manipulate and traverse a 2D array,

[0]] 1

e—11]] 4
[2]| 7

2

3

two indices are used: one for the rows and one for the
columns. When writing code, rows are always first and

5

columns second.

6 ————————— numbers

Look at the figure for storing numbers from 1 to 9 in a table
with three rows and three columns. You will create a 2D

8

9

array or a 2D list for this purpose.
Each element in a 2D array (Java) or 2D list (Python) can

n uy] be rS[/] [1]\: 8 ——value

pe directly accessed by specifying its indices (row index
and column index).

identifier

row index

column index

M 2D array (list)

Declaration

int numbers[

]

[ ]

= new int

[3]

[3];

iy
S S S
S
—
1
1

1 Python

1
I numbers =
[

I

[[0 for i1 in range(3)]

for j

in range(3)]

1
1
1

The first value of 3 indicates the number of rows, and the second one the number of columns.
The value of 0 in the Python example refers to the initial value this list will be set to.
In Python, the 2D list will appear as a table

In Java, the 2D array will only include the

with three rows and three columns, all filled

structure of the table, as there are no initial

with zeros, as shown in the diagram below:

values provided:

[0] [1] [2]

[0] [1] [2]

0lfojo

|0

[0]

[1ljo|0

|0

[1]

[2llo|o0|o0

[2]

M 2D array (list) filled with zeros

M Empty 2D array

Manipulating 2D arrays or lists requires the use of two loops: the first one for the rows and the
second one for the columns. When addressing one specific item in the array or list, this is done
by using the name of the array or list followed by square brackets that include the row and
column indices.
numbers [0] [2] refers to the element in the array numbers, located at the intersecrion of

the first row with the third column.

B2.2 Data structures

Java
Scanner reader = new Scanner (System.in);
int numbers[] []= new int[3] [3];

for(int i = 0; i<3;i++)

{

for(int j=0; j<3;j++)

|

System.out.println("enter a number:

");

int value = reader.nextInt
() ;
numbers[i] [j]=value;

}
for(int i = 0; i<3;i++)

{

for(int j=0; j<3;j++)

{

System.out.print (numbers[i] [j]1+ "

");

}
System.out .print ("\n") ;

1
1
numbers =

[[0 for i in range(3)]for j

for i in range
for j

in range(3)]

i

(0,3):

1

in range(3):

:

value = int (input ("enter a number:

"))

:

numbers [i] [j]=value

:

for i in range(3):
for j

H

in range (3):

print (numbers([i] [§],

:
"

",

end ="")

:

print {("\n")

:
a

The first two count-controlled loops are used to traverse the array (i for the rows and j for the
columns). Then the user is asked to enter a number that is stored in the variable value, which

is then assigned to the array or list numbers.
The last two loops are used to traverse the array or list, so the values stored in the array are
displayed on the screen.
A 2D array can also have a different number of rows and columns.

In the example above, the array numbers will be constructed with two rows and three columns.

B2 Programming

1

™

[ ]

I
5
0
=
o
5
3]

int numbers[ ]

IS

To fill the array with values, the following code can be used:

Construct code that creates a two-dimensional array or list with three rows and three
columns. Fill it with values read from the keyboard. Calculate the sum of all values and their
average, and display the results.

2

Construct a program that creates a two-dimensional array or list with three rows and three

columns. Display the sum of all elements per column. Display the average of all elements
per row.
3

Construct code that creates a two-dimensional array or list with three rows and three

columns that stores random numbers. Display the array and output the sum of all the
elements on the principal diagonal. Calculate the sum of the elements on the secondary
diagonal and display this value as well.

4

Matrix calculations are used extensively in machine learning within Computer Science. The
following constraints exist to calculate a dot product: width of matrix A must match height of
matrix B. Given two 2D arrays (lists) of integers that represent matrices, construct a program
to calculate and solve the dot product of those two matrices.

TR
"Dot product”

(;Common
mistake

1

2

3

Algorithms written

4

5

6

to solve a problem

should function
correctly. Many
students lose marks
for incorrect use of
indices in 2D arrays
or incorrectly looping
through 2D arrays,
such as overlooking
boundaries or not
using two indices to
traverse the array.
Remember that you
always use rows first
and columns second.

B2.2 Data structures

X

7

8

9

10

L1112

7

8

9

10

11

12

Reflect on the most challenging parts of the programming exercises. How did you approach
them? Did you seek support, did you research or did you apply any other strategies? What did

you learn from this experience that you can apply to solve future problems?

B ArraylLists in Java
An ArrayList in Java is a class that allows the use of a dynamic array to store elements, this
time without a pre-defined size. ArrayLists can hold duplicate elements, they allow for random

access and they maintain the insertion order.
To be able to use an ArrayList, you need to import the java.util package:

This will import the entire package, or you can specifically choose to import just the required class:
import java.util.ArrayList;

Keep in mind that, when working with ArrayLists, the data type integer appears as Integer
instead of int.
If the ArrayList will store text, then it would look like this:

To be able to manipulate elements in an ArrayList, there are specific methods that can be used:
Method

Explanation

Code example

add()

Add a new element passed as an argument

grades.add(75);

get()

Access an element at a given position (specified in the brackets)

grades.get(2);

set()

Update an element at a given index (first argument is the index; the | grades.set(2, 64);
second one is the value)

remove()

Delete an item at a specific index

grades.remove(2);

size()

Returns the number of elements in the ArrayList

grades.sizel();

clear()

Delete all elements in the ArrayList

grades.clear();

Arraylist<Integers> grades = new ArraylList<Integers>();
grades.add(75);
! grades.add(64);

LT T T T TP

To traverse an ArrayList, you can use a FOR loop:

grades.add(50);

: grades.add(34);
§

for(int i=0;i<grades.size()
;i++)

{

System.out.println(grades.get(i));

sessnnsnies B

: grades.add (95) ;

B2 Programming

In the code above, the grades ArrayList of type integer is declared. Five elements are added

to the ArrayList. A loop is used to traverse it (the size () method will return the number
of items in the ArrayList to specify how many repetitions will occur), and each element is
retrieved using the get () function and passing the corresponding index of the element that is

then displayed on the screen.
Another example of traversing the ArrayList is by using a FOR-EACH loop instead:
ArrayList<Integers> grades = new ArrayList<Integers();
grades.add(75);
grades.add(64);

grades.add(95);
grades.add(50);
grades.add(34)
;

for

(int i: grades)

{

System.out.println (i) ;

In this example, the variable 1 is not an index, but it is an element in the grades
ArrayList instead.

B Dynamic lists in Python
A dynamic list in Python is a dynamic data structure, meaning it does not have a fixed size.
Dynamic lists can store duplicate values. When creating a dynamic list, you can simply declare
it as an empty list: grades =

[]

However, when wanting to insert a new element, attempting to write something like this:
grades [0]

= 75 will throw an error.

To manipulate dynamic lists, specific methods can be used:
Method

Explanation

Code example

append() | Add a new element passed as an argument at the end of the list

grades.append(75)

insert()

grades.insert(0,64)

Insert a new element at a given index (first argument is the index,
the second is the value to be inserted)

remove() | Delete the first occurrence of a given item passed as an argument

grades.remove(75)

popl()

Delete the element at the specified index

grades.pop|(0)

popl)

Delete the last element if no index is given

grades.popl)

clear()

Empty the entire list

grades.clear()

len()

Return the size of the list

len(grades)

To loop through a dynamic list, a FOR loop can be used:
grades=[]
grades.append (75)
grades.append (64)
grades.append (95)

grades.append (50)
grades.append (34)
for i in range

(len(grades)):

print (grades[i])

B2.2 Data structures

Another way to achieve the same is:
grades=1[]

grades.append
(75)
grades.append
(64)
grades.append
(95)
grades.append
(50)
grades.append
(34)
for i in grades:
print (i)

In this case, i is not the index, but an element in the dynamic list.

1

2

Construct programming code to create an ArrayList in Java or a dynamic list in Python that
stores five colours.
a

Construct code to insert a sixth colour after the third.

b

Change the element at the second position to a different colour.

¢

Delete the last element.

d

Display the new data structure.

Construct a program that creates an ArrayList in Java or a dynamic list in Python that stores

3

4

Append three more values to the end of the data structure.

N
Qo

Store the first element into a variable.

o

Display the size of the data structure.
Display the first element.

Replace all the other elements with this value.

-

oW

three numbers.

Display the new values.

Construct a program that creates an ArrayList in Java or a dynamic list in Python that stores
three different numbers.
a

Store the second value into a variable and insert it into the data structure at the end.

b

Display the index of the first occurrence of that value.

Construct programming code that creates an ArraylList in Java or a dynamic list in Python that
stores four different values.
a

Display all the elements.

b

Swap the values of the second and third elements.

¢

Display the new data structure.

B2.2.3 Stacks
If you were a bank cashier, you would deal with lots of coins. To easily manipulate those, the
coins are categorized based on their values and stored in piles, for example a pile of 10p coins,
a stack of 20p coins, another stack of 50p coins, and so on. When the cashier needs one of

these coins, they would get it from the top of the pile containing the required coin value, so the
stack remains intact. When the cashier needs to add a new coin to one of the piles, they would
add the new coin to the pile; again, on top of it.
B2 Programming

Another example would be a stack of plates: a new plate is
added to the top of the stack and a plate is removed from
the top of the stack, otherwise plates can break.

In Computer Science, when performing actions that work
on the same principle, a specific abstract data structure
called stack can be used. The stack works on the principle
of Last In First Out (LIFO) or First In Last Out (FILO),

meaning that only the top element is accessed. The
operation of removing an item from the stack is called
pop, which means taking off the top element, while the
operation of adding an item to the stack is called push,
meaning adding an item to the top of the stack.

B Stacks of coins

# Stack: an abstract

push (value)

data structure that
works on the LIFO
principle.

pop ()

# Last In First Out
or First In Last Out

principle: the last

8

toplndex =1

element inserted is the
first element removed.

5

# Pop: a method for
deleting the element
from the top of a stack.
Push: 2 method for

M Stack

inserting an element at

A stack can be implemented as a static data structure using arrays (it would have a fixed size)

the top of a stack.

or as a dynamic data structure using a linked list (which would not have a fixed size).

A stack could use a stack pointer variable to indicate the next free available slot in the stack.

# Stack pointer: a

register used to store

B Stack operations

the memory address of
the last added data in a
stack, or sometimes the
first available address in
a stack.

Operations performed on a stack are:
B

isEmpty: to check whether the stack is empty; attempting to pop an item from an empty
stack would throw an undertlow error

public static boolean isEmpty() {
if(topindex ==-1)
return true;
else
return false;

}
topindex = -1
def IsEmpty():
if toplndex == -1:
return True

else
return False
M Stack operation: isEmpty

B2.2 Data structures

__
t0p|ndex =-1
stack is empty

B

isFull:to check whether the stack is full; attempting to push an item into a full stack
would throw an overflow error

public static boolean isFull() {
if(topindex == StackSize -1)

topindex =3

return true;

else

return false;

12

}
def IsFull():
if topIndex == StackSize -1:
return True
else:

5

StackSize = 4

M Stack operation: isFull

B push: to add an item to the top of the stack
public static void push(int value) {

push(9)

if(isFull())
System.out.println("Stack
overflow!");

else {
topindex++;

stack[topIndex]=value;

12

topIndex = 2

}
def push(value):

global topindex

5

if IsFull():
print("Stack overflow")

else:
toplndex += 1
Stack[topindex] = value
M Stack operation: push

® pop: to delete an item from the top ofthe stack
public static void pop() {

if(isEmpty()
System.out.println("Stack underflow");
else
toplndex—;
}

/) pop()

12|

toplndex =2

def pop():

global topindex
if isEmpty():
print("Stack underflow")
else:
toplndex = 1
M Stack operation: pop

B peek: to return the top element

public static int peek() {
return stack[topindex];

12) toplindex =2

}
def peek():

return Stack[topindex]
M Stack operation: peek

B2 Programming

B Uses of stacks
Stacks are used when storing data in the order they occurred and when it might be necessary to
track back to a certain point or action in the past, as they respect the LIFO principle of operation.
Stacks can be used:

B
4 Interrupt handling:
handling interrupt
reguests.

# Interrupt: a signal
sent from a device or
software to request the
processor’s attention;

the processor will stop
its current activity
until the interrupt has
been serviced.
# Recursion: a process
that uses a function
or procedure that is
defined in terms of itself

to create an UNDO feature in games: actions are pushed into the stack; when undoing,

actions are popped
m

to allow backwards navigation on a web browser: pressing the back button performs a pop
operation; opening a new website performs a push operation

m for interrupt handling: when the current activity of the CPU is interrupted, the content of
variables and return addresses are stored in a stack; after the interrupt is dealt with, those
are popped from the stack to restore its activiry

B to evaluate arithmetic expressions: when evaluating RPN (reverse polish notation)
expressions, the operands are pushed on to the stack; when an operator is met, if it

is a binary operator (requires two operands) two more pop operations will occur, the
calculation is performed and the result is pushed back into the stack — the process will

continue until the result is reached
B for recursion: return addresses and values of parameters are stored into a stack to help with
the unwinding process.

and calls itself.
4 Queue: an abstract

B2.2.4 Queues

data structure that
works on the FIFO
principle.

A queue is a data structure that functions on the FIFO (First In First Out) principle. An example

# First In First Out

of a queue is a line of people waiting to check out at a grocery store. The first to join the queue is

principle: when the first
element inserted is the
first element removed.

the first to leave. A new person who joins the line will enter at the end of the queue.
A queue uses a front pointer to show where elements will be removed from and a rear pointer
to show where elements will be added to.

LLim
B Queue

B2.2 Data structures

A queue can be implemented as a static data structure
using arrays (it will have a fixed size, and it is possible to
become full as this fixed size cannot be exceeded). Or, a
queue can be implemented as a dynamic data structure,
using a linked list (which would not have a fixed size).
When a queue is implemented as an array, it can often be

seen and managed as a circular queue. This is in case there
are elements removed from the queue, so that there is still

a way to add new elements, even if the last index has been
reached, as the queue will not actually be full. In a circular

queue, if the rear pointer becomes equal to the front
pointer after an item is added, the queue becomes full; it
they become equal after an item is removed, the queue
becomes empty.

B Queue operations
5

Operations performed on a queue are:
B isFull: checking whether the queue is full; trying to

ENQUEUE

front / head

enqueue an item into a full queue would throw an

overflow error
=

DEQUEUE

® isEmpry: checking whether the queue is empty; trying

3

9

2

4

to dequeue an item from an empty queue would throw

3

an underflow error

/
rear / tail / back

B enqueue: adding an item to the rear of the queue
.

.

B dequeue: removing an item from the front of the queue
B front displaying the element stored at the front of

the queue.

3
W Queue pointers

# Enqueue: a method
of inserting an element
at the rear of a queue.

Bl Uses of queues
Queues are used when dealing with simulations or situations that require the first item entered
to be the first item dealt with. Applications of queues include:

4 Dequeue: a method
of deleting an element
from the front of

Printer queues: Printing jobs are stored in a queue. The first printing job sent is the first
to be dealt with. New printing jobs join the queue at the rear of the queue. As such, all

a queue.

printing jobs are dealt with on a first come first served basis.
Keyboard queues: The keyboard buffer (which stores characters as they are typed) operates
as a queue. As such, the first letter to be shown on the screen is the first letter typed. New
characters are added to the end of the queue.
Simulations of real-life situations: Checkout queues, car-washing queues, carpark-exiting
queues, and so on, are all situations that require a queue. People or cars enter the queue on
one side and exit it on the other side.

1

Define the term “stack”.

2

Define the term “queue”.

3

Identify the main operations of a stack.

4

ldentify the main operations of a queue.

5

Explain the FIFO and the LIFO principles and how they apply to stacks and queues.

6

Identify a real-life scenario where you could use a stack.

7

Identify a real-life scenario where you could use a queue.

8

Outline a situation where the use of a stack might be more efficient than the use of a queue.

9

Qutline a situation where the use of a queue might be more efficient than the use of a stack.

10 Identify a scenario where you might combine a stack and a queue within the same program.
11 You must store a list of numbers in a particular sequence and then retrieve them in reverse
order. Identify the data structure that is most suitable for this task and explain your reasoning.
12 Outline three uses of a stack.
13 Outline three uses of a queue.
14 Describe two characteristics of a stack.

B2 Programming

15 Describe two characteristics of a queue.
16 Compare the use of a stack with arrays or lists.
17 Compare static and dynamic data structures in terms of data storage and data access.
18 Explain the meaning of stack overflow and stack underflow and describe when they occur.

19 Use a stack to evaluate the following arithmetic expression: 52 * 3 2+ -

1

Construct a program that creates a stack that has a maximum size of seven elements. Push

five words into the stack. Display the top element. Pop two words from the stack and display
the top element.
2

Construct a program to reverse the elements from a given queue using a stack.

(;Common
mistake
Students often lose
marks by not giving
responses appropriate

Use your solutions to the programming exercises above to answer the following questions.
1

Why is the maximum size of the stack important? What happens if this maximum size

to the keywords used

2

is exceeded?
How would you change the solution to Exercise 2 if you were asked to reverse the
elements of a stack using a queue structure instead?

in the question. For
example, “compare
static and dynamic

data structures”
is expecting you
to provide both
similarities and

differences between
the two types of data
structures, rather than
just differences.

B2.2 Data structures

(;Common mistake
When required to state applications of a data structure, such as a queue or stack, students often

lose marks for not being clear enough to gain the marks. For example, saying that stacks are used
to undo would not be enough to gain any marks.
Be specific and explain a clear situation where an undo feature is needed, such as implementing
an undo feature in games: actions are pushed on to the stack and, when the previous action is
needed, the undo feature is used to pop the top action from the stack.

Programming algorithms
SYLLABUS CONTENT
By the end of this chapter, you should be able to:
» B2.4.1 Describe the efficiency of specific algorithms by calculating their Big O notation to
analyse their scalability
» B2.4.2 Construct and trace algorithms to implement a linear search and a binary search
for data retrieval
P> B2.4.3 Construct and trace algorithms to implement bubble sort and selection sort,
evaluating their time and space complexities

P> B2.4.4 Explain the fundamental concept of recursion and its applications in
programming (HL)
» B2.4.5 Construct and trace recursive algorithms in a programming language (HL)

B2.4.1 Big O notation
Complexity analysis of algorithms includes time and space analysis. Time complexity analysis
refers to how long an algorithm will take to run or how many steps an algorithm will take to
run, while space analysis refers to how much memory space it takes to run the algorithm.

Bl Time complexity
Consider the following algorithm:

......................................................................

e

'

]

! for(int i = 0; i<5;i++) {

! for i in range (0,5):

: Java

————————

e

' Python

System.cut.println("hellc");

:

}

print ("hello")

B

-

How many times will this loop repeat? The variable i will take values from 0 to 4 included;

therefore, it is simple to say that the algorithm will repeat five times. If we are to replace
the 5 with n, the algorithm will repeat nn times and the time complexity will be of the order
4 Big O notation: used
to find the upper bound
(worst-case scenario
or the highest possible
amount) of the growth
of a function; the
longest time or space

required to turn the
input into output.

of
n. This is written as O(n), which is known as Big O notation. The time it takes to run
the algorithm is approximately proportional to n. The larger the n, the more accurate the

approximation; therefore, when calculating the Big O notation, the worst-case analysis is
considered (the larger the n, the better).

.......................................................................
:

i Java

for(int i = 0; i<n; i++)

{

System.out.println("hello");
}

:

T e
1

e

e T

' Python
A for i in range (0,n):
1

print ("hello")

1
o

oo

o

o

o

e

e

B2 Programming

Consider the following example:

i Java

E Python

for(int i = 0; i<n; i++) {
for(int j = 0; j<n; j++)

F)

i

: for i in range
{

:

System.out.println("hello");

:

|

:

for j

R

:

(0,n):

in range

(0,n):

print ("hello")

e

:
:

i B LR

In the example above, the algorithm will repeat n times for the outer loop and n times for the
inner loop, so a total of n*n times, which means time complexity becomes O(n?).
Let's look at another example:

i Java

E Python

for(int 1 = 0;

i<n;

for(int j = 0;

i++)

{

j<n+3; j++)

{

System.out.println("hello");

}

for i in range

:

for j

:

H

i

:

R

(0,n):

in range

:

(0,n+3):

:

print ("hello")

e T

i i o e i

it i

:

s

bbb vl

In the example above, the number of repetitions isn* + 3n. As time complexity becomes
more accurate for larger numbers, when n rakes a very high value, the addition of 3n is not
even taken into consideration. As such, constants are ignored (the rate of growth is what
matters) and the lower-order terms are ignored (as n grows larger, the larger term dominates
all other terms). Therefore, the Big O notation is still O(n?). In the same way, il the number of
repetitions is 25n°, n* + 25n® + ¥n, the coefficients will be ignored and only the term with
the highest exponent will be used, and so the Big O notation will be O(n?).
The final example is a simple statement, without any loops:
..................................................................................

Java

Py

i Python

System.out.println("enter a number:

");

: value = int (input ("enter a number:

int value = reader.nextInt();

1

sum = 50 + value;

:

i
"))

:

sum = 50 + value

&

1

A

In this case, Big O notation is constant; no matter how large the input value, the algorithm will
take the exact same time to run, so we can say the time complexity is O(1).
The common time complexities expressed using Big O notation are:
B O(1) - constant time: The algorithm performs a fixed number of operations; the time taken
to run the algorithm does not depend on the size of the input. Such algorithms are ideal for
operations where you need consistent performance regardless of input size, such as basic
operations in data structures like hash tables.
B O(n) — linear time: The algorithm scales linearly with the size of the input. Such algorithms
are appropriate for simple searches where each element must be considered.

B2.4 Programming algorithms

B O(n?) — quadratic time: The time taken to run the algorithm is directly proportional to the
square of the input size. Such algorithms are often used when dealing with small data sets;
they are inefficient for large data sets.

m O(2") — exponential time: The algorithm’s running time doubles with every increase in the
input size. Such algorithms are generally impractical for large inputs due to rapid growth in
execution time.
B O(log n) — logarithmic time: The algorithm’s running time scales logarithmically with
the increase in the input size. Such algorithms are suitable for searching and some divideand-conquer algorithms. They are ideal for cases where you can efficiently reduce the

problem size.

B Space complexity
Space complexity analyses the amount of memory used by an algorithm with respect to its
input size.
Common space complexities expressed using Big O notation are:
B O(1) - constant space: The space used by the algorithm is not dependent on the size of the
input. The algorithm uses a fixed amount of memory, no matter the input size.
B O(n) — linear space: The memory usage scales linearly with the input size.
B O(n? - quadratic space: The space taken to run the algorithm is directly proportional 1o
the square of the input size.
Consider the following example:

int sum = 0;
for(int i = 0;

r

.

1 Python

P

: Java
!

B

i<n;

i++)

sum
= sum
+ i;

}
System.out.println(sum) ;

{

:

sum = 0

:

for i in range

:

1

!
:
(0,n):

sum
= sum
+ i

:
:

1 print (sum)
1

1
1

=

o

In the example above, no matter how many repetitions there are, the space taken to store the
sumand i variables in memory is always the same. The sum and i will be overwritten with
every repetition, so the space complexity stays constant: O(1).
As memory is not a real issue these days, it is often the case when writing an algorithm to aim
for reducing the time complexity, even if that means trading off more space.
To calculate the space complexity of an algorithm, you need to look at:

B Variables and constants: As variables are overwritten and constants don't change their
value during the execution of the program, they will always take up the same amount of

space, so they don't need to be recalculated after the execution of the program.
B Inputs: Inputs are important for space complexity. If the inputs are variables, arrays or
other data structures, their space complexity differs.

B Execution: Based on how the algorithm is written, the space complexity can be constant
(when a fixed number of simple operations are performed) or differ (when, for example, a

function calls itself several times, and so extra space is needed to store the return values
and values of the parameters that will be used in unwinding to provide a solution).

B2 Programming

Il

int sum

[as]

"

for(int 1 = 0;
sum

i<n;

i++)

{

:

sum + numbers[i];

}
System.out.println(sum) ;
HT

1
1
1
1
1
:
1
1
1
1

-

for i in range

(0,n):

sum = sum + numbers[i]

.
print (sum)

L

1
1
1
1
1
:
1
1
1
1

o

T T T LT LT r T T Ty v ARH

In the example above, the sum will include each value stored in the array, so the space

required to run the algorithm is linear to the number of elements in the array: O(n).

B Choosing algorithms based on scalability and efficiency
B Small data sets: Simpler algorithms with higher time complexity (for example O(n? or
O(n*) can be acceptable.

m Large data sets: Algorithms with lower time complexity (for example O(n log n) or O(log
n)) are preferred, for better scalability.
B Real-time requirements: Algorithms with constant time complexity (O(1)) or logarithmic
complexity (O(log n)) are considered, where possible.
®

Complex problems: Dynamic programming or divide-and-conquer approaches with
manageable time complexity are used.

Selecting the right algorithm depends on the problem constraints, input size and performance
requirements. Analysing time complexity helps ensure that the chosen algorithm will perform
efficiently as the input size grows.

1

Explain what Big O notation is and why it is used in Computer Science.

Define the terms “time complexity” and “space complexity”.
3

OQutline the difference between O(n) and O(n?). Identify two algorithms that present

these complexities.
4
5

Explain why you think it is important to consider the worst-case space complexity of
an algorithm.
Sketch a graph to compare the time complexity of O(n) and O(log n). What differences do
you notice?

6

Consider the following statement: “An algorithm with a Big O value of O(n) will always
be slower than one with a value of O(log n)”. Evaluate this statement to true or false and

explain your reasons.
7

Outline the two types of complexity analysis.
Identify which is generally faster for a very large n: O(log n) or O(2").

B2.4.2 Linear search and binary search
Search algorithms are used to find a specific item in a data structure. Such algorithms can
be used to find an item in a list or in a database; to search for an item (word or phrase) in a

document; to find a relevant webpage based on a keyword typed in a search engine; or to find a

location on a map.
B2.4 Programming algorithms

B Linear search
A linear search is also called a “sequential search” as it

Step 1

3

9

?

4

traverses a data structure from the beginning to the end

I

when looking for a specific item. In the best-case scenario,

‘ not equals

the item is found in the first position, but in the worst-

key =7

case scenario the item is the last item in the list and so the
entire list is traversed.
Consider an array (list) of integers with ten elements and a

3

Step 2

9

?

4

key, being the element you are searching for.

/

To find the key, you will use a loop to traverse the

‘ not equals

array (list).

key =7

Starting at the first index, the element stored at position
0 will be compared with the key. If they are the same,
the element is found; otherwise, the process repeats until

3

Step 3

9

?

4

the element is found or until the end of the array (list)

is reached.
|

If a conditional loop is used, the algorithm can be stopped

‘ equals

key =7

if the searched element has been found.

W 1D array (list) - linear search

4 Linear search: a
method of searching,
in which each

Java

element is checked in

int key = 7;

sequential order.

once the element is found. But if a count-controlled loop is
used, the algorithm will traverse the entire list (array), even

H

int numbers= {3,9,7,4};
int position =

-1;

for(int i = 0;

i<numbers.length;

i++)

{

if (key==numbers[i]) {
position = i;¥

}
if (position != -1){
System.out.println("element found on position "+
position);

}
else{
System.out.println("element was not found!");

B2 Programming

Python
numbers =

[3,9,7,4]

key = 7
position = -1
for i in range

(0, len(numbers)):

if key == numbers|[i]:
position = i
if position != -1:
print ("element found on position ", position)
else:
print ("element was not found")

This algorithm can be improved, so it stops when the element is found by using a
conditional loop.
‘When you think of Big O notation, linear search has a time complexity of O(n), as in the worstcase scenario every single element in the array (list) will be traversed in the attempt to find the
searched key. At the same time, the space complexity is O(1), as the space required to run the
algorithm is constant.

M Binary search
Linear search is not a very efficient algorithm, especially when the size of the array (list) is

considerably high.
Binary search is a more efficient searching algorithm as it reduces the number of searches

# Binary search: a
method of searching

to half with every comparison performed, so the time complexity is logarithmic O(log n).

an ordered array (list)

However, to be able to perform a binary search on an array (list), the data structure must be

by repeatedly checking
the value of the

sorted (it must be in order). This is because the algorithm works as follows:
Set a variable (Lower) to store the lower bound index.

middle element and

disregarding the half of
the data structure that
does not contain the

Set a variable (upper) to store the upper bound index.

searched element.

Compare the value in the middle index with the search key (if numbers [mid] ==key).

Calculate the middle index (mid) by using the formulamid = (lower+upper) /2
1f they are the same, the value is found and the algorithm can stop.

key =7

new lower

»

mi

[0] @

/

m If the value in the middle position is smaller than the
key, you can disregard the left side of the array (if the

.

)

‘

)

array is sorted in ascending order) by setting the lower
[2]

[3]

variable to the middle index
+ 1: lower = mid + 1
m If the value in the middle position is greater than the

Z
=)

.{',

?

9

key, you can disregard the right side of the array (if the
array is sorted in ascending order) by setting the upper

lower =0
upper = 3
mid = (lower + upper)/2 = 1
7>4,s0

lower=mid +1=2
mid = (lower + upper)/2 = 2
7 =17, 5o the element is found
M 1D array (list) — binary search

B2.4 Programming algorithms

variable to the middle index — 1: upper = mid - 1
B Repeat the entire process, starting from the third point
until the value is found or the end of the array (list)

is reached.

Java
int numbers([]

= {3,4,5,7,9,11,13};

int key = 11;
beolean found = false;

5

int

i

lower = 0;

int mid = 0;

int upper = numbers.length;
while ((lower<=upper)
mid =

&&

!found )

{

:

(lower+upper)/2;

if (numbers[mid]=zkey)

{

found = true;

} else if (numbers[mid]<key)

{

lower = mid+1;

} else {
upper = mid-1;

}
if (found)

{

System.out.println("the value was found on position

" + mid);

} else {
System.out.println("the value was not found" );

}
ea e

R e

Re

numbers=

e R SR E R R

RA

R A R R AR R R

A

e e A A

AR AR

e RN ee R R e AR ta

sy

[3,4,5,7,9,11,13]

found = False
lower = 0
upper = len(numbers)

while lower<=upper and not found:

mid = int((lower + upper)/2)
if numbers
[mid] ==key:
found = True

elif numbers [mid] <key:
lower = mid + 1
else:

upper = mid - 1
if found:
print ("the value was found on position ",

mid)

else:
print ("the value was not found")

B2 Programming

Each algorithm is more appropriate in different scenarios. For example, if the list (array) needs
to be searched once for a given element, such as the ID of a worker, and the organization has
fewer than 50 employees, it would be faster to simply use a linear search, rather than having
to sort the data structure and then apply a binary search on it. However, if there is a need to

search for the home address of a student based on their school 1D, in a data structure already
ordered based on the students’ IDs, and the school has 1500 students, it would be much more

appropriate to use a binary search to retrieve the student’s details.

B2.4.3 Bubble sort and selection sort
Sorting refers to arranging the elements in an array (list) into ascending or descending order.
You already practised a swapping technique at the beginning of the unit. This technique is
4 Bubble sort: a
sorting algorithm that

used in sorting routines.

compares adjacent

H Bubble sort

values and swaps

Bubble sort is a sorting algorithm that uses an incremental approach, and it works by

Fhem if they are in an

repeatedly swapping the adjacent elements if they are not in the right order. If the array (list)

hissluagri
28

was traversed only once, there might still be elements in the array (list) that are not yet sorted.
Bubble sort algorithms work as follows:

Unsorted array (list)

B Start at the beginning of the array (list).

1

2|9

Compare the current element with the next one.
It the two values are not in order, swap their contents.

swap

Move to the next element in the array (list).

2|

3

9

Repeat the process until all the elements have
been sorted.

swap

As shown in the diagram, once the array (list) has been

3

3

2

traversed once, the last element is surely in the right

position. Therefore, to optimize the algorithm, the number

- Mg

no swap

of repetitions can be reduced by 1.

7

9

7

9

0 swap

Sorted array (list)
M Bubble sort

B2.4 Programming algorithms

79

¢ Java
int numbers[]
for

= {7,3,2,9};

(int i = 0;

i

<numbers.length;

i++)

{

for (int j = 0; j<numbers.length-1-i;
if (numbers [j] >numbers [j+1])

j++)

{

{

int temp = numbers([j];
numbers [j]

= numbers[j+1];

numbers [j+1] =temp;

for

(int i=0;i<numbers.length;

i++)

System.out .print (numbers [i]l+"

numbers =

{

");

[7,3,2,9]

for i in range (len(numbers)):
for j

in range (0,

len(numbers)-1-i):

if numbers|[j]>numbers[j+1]:
temp = numbers[j]

numbers
[j] =numbers [j+1]
numbers [j+1] =temp

for i in range (len(numbers)):
print (numbers[i],

"

",

end="")

The inner loop repeats from 0 to the size of the array (list) -1, because you compare one
element with an adjacent one and, when the current element is the second last to be compared
with the last element, that should be the last comparison that takes place.
The same repetition is reduced by i every time. This ensures that, when the array (list) is
traversed the first time, it will repeat to its size -1, as i isinitially 0, but with the next

traversal it will repeat to size -2, and the next passitwill be size -3, and so on. Thisis
happens because, with the first pass of the array (list), the last element moves to the correct
position; with the second pass, the last and the second last are in the correct position, and
S0 on.

B2 Programming

Another way to implement a bubble sort is by using a conditional loop:

‘ Python
int numbers[]

= {7,3,2,9};

:

numbers =

[7,3,2,9]

boolean swapped = true;

: swapped = True

int n = numbers.length;

:

while (n>0 && swapped)

{

: while (n>0 and swapped):

swapped = false;
n

=

n-1;

for

(int i = 0; i<n-1;

i++)

{

if (numbers [i] >numbers [i+1])

{

:

swapped = False

:

n=n-1

:

for i in range(0,

1
:

int temp = numbers[i];
numbers[i]

n = len(numbers)

= numbers[i+1];

numbers [i+1]=temp;

swapped = true;

n-1):

if numbers[i] snumbers[i+1]:
temp = numbers[i]

:

numbers [i] =numbers [i+1]

:

numbers [i+1] =temp

:
:

swapped = True
for i in range (len(numbers))
:
print (numbers([i],

"

",

end="")

}
for

(int i=0;i<numbers.length;

i++)

System.out.print (numbers[i]+"

{

");

Although it is quite simple to understand the algorithm and to implement it, the bubble sort
has a time complexity of O(n?), which means it is a very inefficient algorithm, especially when
it comes to large sets of data. In terms of space complexity, the bubble sort algorithm is very

efficient O(1), requiring a constant memory space to store the variables read from the array, the
indices and the temporary variable. This required space would not depend on the size of the

input; it would not require additional space proportional to the size of the input array.

Unsorted array (list)

M Selection sort
To easily understand the algorithm, imagine you split the

1

original array (list) into two parts. The first part is the
sorted part, which is initially empty, and the second part

is the unsorted part, which initially contains the entire
array (list). With the first part, the smallest element in

the unsorted part is selected and swapped with the first
element in the array. This smallest element now becomes
the sorted part of the array. In the second pass, you now
search for the smallest element in the unsorted part and
swap it with the second element. The sorted part now
includes the first and second element. The process repeats
until all the elements are sorted, the sorted part includes
the entire array and the unsorted part is empty.

Sorted array (list)
M Selection sort

B2.4 Programming algorithms

Java
int numbers[]
int min,

= {9,7,2,3};

minIndex;

for(int i = 0;

i<numbers.length;

i++)

{

min = numbers[i];
minIndex = i;

for(int j = i+1;

j<numbers.length;

if (numbers[j]<min)

j++)

{

{

min = numbers[j];

minIndex=7j;

}
numbers [minIndex]

= numbers[i];

numbers
[i] = min;

}
for(int i = 0;

i<numbers.length;

System.out.print (numbers[i]

i++)

+ "

{

");

}

Python
numbers = [9,7,2,3]
for i in range (len (numbers)):
min = numbers[i]
minIndex = 1
for j

in range(i+1,

if numbers[j]

len(numbers)):

< min:

min = numbers[j]
minIndex = j
numbers [minIndex]
numbers[i]

= numbers[i]

= min

for i in range(len(numbers)):
print (numbers[i],

"

",

end="")

B2 Programming

The same algorithm can be implemented by using just the index of the smallest element,
instead of retrieving the smallest element and its index to swap:

Java
int numbers[]

= {9,7,2,3};

int min;
for(int i = 0;

i<numbers.length-1;

i++)

{

min =i;

for(int j = i+l; j<numbers.length;
if (numbers [§] <numbers [min] ) {

j++)

{

min=j;

}
int temp = numbers[i];
numbers [i] =numbers [min] ;
numbers [min] =temp;
for({int i = 0;

i<numbers.length;

System.out.print (numbers[i]

numbers =

i++)
+

"

{

"};

[9,7,2,3]

for i in range(len (numbers)-1):
min = i

for j

in range(i+l,

if numbers[j]

len(numbers)):

< numbers[min]:

min = j
temp = numbers[i]
numbers
[i] = numbers[min]
numbers [min]

= temp

for i in range
(len (numbers)) :
print (numbers[i],

# Selection sort: a
sorting algorithm that
repeatedly selects the
smallest or largest
element (ascending
or descending order)
from the unsorted part
of the data structure
and moves it to the
sorted part.

"

",

end="")

The limitation of the selection sort is that it doesn’t allow for an early exir it the array (list)
is ordered at an earlier point. The time complexity of the selection sort is O(n?) and the space
complexity is O(1). Selection sort performs a smaller number of swaps; therefore, it is said to
be a more efficient algorithmm than the bubble sort algorithm. However, it is possible to stop the
algorithm if all elements are sorted during an early pass in a bubble sort by using the flagin a
conditional statement, which is not possible in a selection sort.

Research skills: Present information in a variety of formats and platforms - find an
ingenious way to explain one of the programming algorithms you have studied. For
example, use labelled cups to explain a sorting algorithm, create an animation, a video,
and so on.

B2.4 Programming algorithms

ATNO TH

B2.4.4 Recursion (HL)
Recursion represents a technique that involves the use of functions, procedures or algorithms
calling themselves one or more times until one or more specific conditions are met, at which
point the process unwinds itself to produce a solution, by processing the last call to the first.

Characteristics of a recursive algorithm include:
B amethod or function that calls itself
4 Base case: a

terminating solution
(that is not recursive) to
a process.
# General case: a
process where the
recursive call takes
place.
4 Winding: a process
occurring when
recursive calls are made
until the base case is

reached.

B atermination condition or a base case — a termination solution that is not recursive;

without a base case, the algorithm will run to infinite
B ageneral case that calls itself recursively or is defined in terms of itself, and moves towards

the base case by changing its state (winding)
m unwinding, which occurs when the algorithm reaches the base case (cascades up until the
original problem is solved or, in other words, is processing the results, starting at the last

call and building up towards the base case).
Recursive algorithms provide elegant solutions to complex problems, by often using less code

and fewer variables than iterative approaches. They allow the programmer to divide complex
problems into smaller sub-problems that are more readable and easier to solve. However, if

many recursive calls are made, there is a heavy use of the stack, a process that is memory
intensive and could potentially lead to stack overflow, and the computer running out of

¢ Unwinding: a
process occurring

memory. If the termination condition is not set correctly, the algorithm might run to infinite,

when the base case is

or the system might crash or freeze due to the high number of recursive calls.

reached, and the values
are returned to build a

Recursion might take longer to execute than other techniques or iterative approaches, as

solution.

each call takes a specific amount of time, in addition to the time required to build up the

final solution.
Recursion can also be challenging to follow sometimes, which can make it difficult for other
programmers to maintain, document or modify it.

Recursion can be used:
B to implement sorting algorithms, such as quick sort
B for fractal image creation
m for traversing binary trees or graphs

m for solving mathematical problems, such as factorial functions and towers of Hanoi.
When choosing whether to solve a problem by using a recursive algorithm, ask yourself the
following questions:

m Is it possible to identify a base case?
B Isit possible to solve the problem by calling itself or splitting it into smaller instances of the
same problem?

m Does it require data structures like graphs, trees or linked lists — data structures that can be
seen as repetitive instances of itself?
Does it require backtracking?
Is there a mathematical expression that can be translated into a recursive algorithm?
B Are you solving the problem in a more elegant, simpler and logical way by using recursion,
without sacrificing too much memory or performance?

B2 Programming

=

Define the term “recursion”.

N

Compare recursive and iterative algorithms.

W

Explain the need for a base case in a recursive program.

R

Identify one consequence of not using a base case in a recursive function.

D

Identify some advantages and disadvantages of using recursion.

Explain what steps you would take to debug a recursive function that does not work
as expected.

B2.4.5 Recursive algorithms (HL)

==
T
o
=
=<

B Factorial of a number
One of the exercises in Section B2.3.4 required you to find the factorial of a number. You
were able to solve this problem by using a loop. However, now you understand the concept

of recursion, you can easily establish that this problem can be solved by using a recursive
algorithm. Starting from the mathematical formula that defines the factorial of n: nl =n *
(n-1)!, you can identify that 5! can be defined as 5 *4! and 4! can be defined as 4*3!, and so

on, until n = 1, which will return 1. The base case is whenn = 1, as 1 will be returned, and

the recursive call is when the method calls itself with n - 1 as a parameter. Therefore, the
solution to this problem is:
R0

¢ Java
i public static int factorial(int n)

if (n==1)

i

{

return 1;

g

}

i}

g5

: def factorial(n):

:

1

1

:

return n * factorial (n-1);

S

E

:

else {

g

E Python

:

}

g

if (n==1):
return 1

else:
return n * factorial(n-1)

:

fact = factorial
(5)

:

print (fact)

:

!
:
:
:

| temeeesscscessssees
s ss s a

public static void main(Stringl[]

args)

{

int fact = factorial(s);
System.out.println(fact);

M Fibonacci sequence
Another application of a recursive method is in solving the Fibonacci sequence.
The Fibonacci sequence looks like this:
0,1,1,2,3,5,8,13, 21, 34...

B2.4 Programming algorithms

@

AINO TH

THE FIBONACCI SEQUENCE
Each number is the sum of the two that precede it.

011235818
21
0+1=1

1+1=2
1+
2

M Fibonacci sequence

m F=0
m F=1
m F,=F +F
u

m F=[F

+F,

To find the sequence for the first n terms, the base cases are identified as being ¥ and T,

e e e e e ey

where the returned values would be 0 and 1 and the recursive call: F_ +F_,

Java
public static int fib(int n)
return

0;

} else if (n==1)
return

{

{

{

if n==0:
elif

1;

} else {
return fib(n-1)

+ fib(n-2);

:

}
public static void main(Stringl[]

args)

else:
return fib(n-1)

+

n = int (input ("enter a number: "))
for i in range(n):

{

Scanner read = new Scanner (System.in) ;

System.out.println("Enter a number:

e e e e

(n==0)

");

o e e

if

Python
def fib(n):

print (£ib

(i),

end="")

1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
4

int n = read.nextInt();

for(int 1 = 0;

i<n;

i++)

{

System.out .print (fib(i)

+ "

");

}
e s e asas et a st s e r et E s ta e Eaae e e

e NN a S Ea s

SR

RN

RRAe s aa s Rsa s aana

B2 Programming

B Quicksort
# Quicksort: a

1f the bubble sort and selection sort discussed earlier use an incremental approach, the

I:E

sorting algorithm that

quicksort is an efficient sorting routine that uses the divide-and-conquer algorithm. The

2
=

repeatedly selects an

divide-and-conquer principle refers to dividing the problem into two or more identical, smaller

element as a pivot and

sub-problems that can be solved individually, and their solutions combined to produce the

.
elements into two sub-

solution to the larger problem.

arrays (lists): one that

The quicksort algorithm makes use of a pivot element from the data set, against which the

includes elements that

other elements are compared, to identify their correct position. The pivot element can be

are smaller than the
pivot and the other one
that includes elements
that are larger than

Imagine that the data structure is broken into two partitions (sections): one that contains

partitions the other

the pivot.

the first element, the last element, a random element or the middle element in the darta set.
elements smaller than the pivot and one that contains elements larger than the pivor.
A way to construct the quicksort algorithm is by implementing the following logie:

m

Set the pivot as the middle element.
Start at each end of the list by using a left pointer and a right pointer.
Move the values smaller than the pivot to the left partition.
Move the values larger than the pivot to the right parrition.

Recursively apply the same principle for the left partition until all elements are sorted.
B Recursively apply the same principle for the right partition until all elements are sorted.

Java
public static void gquickSort (int start,

int finish,

int[Jnumbers)

{

if (start>=finish) {
return;

H

}
int left = start;

int right = finish;
int pivot = numbers[(start+finish)/2];

System.out.print ("start:" + start + " finish:
+ " right: " + right + " pivot: " + pivot );
while (left<right)

" + finish + " left:

" + left

{

while (numbers
[left] <pivot)

{

left = left+1;

System.out.println("left:

" + left);

}
while (numbers [right] >pivot)

{

right = right-1;
:

System.out.println("right:

" + right);

}
if (lefte=right)

{

int temp = numbers|[left];

numbers [left]

= numbers[right];

numbers [right]

= temp;

left = left+1;

HH
H

right = right-1;
System.out.println() ;
B

T TT T

B2.4 Programming algorithms

T T T T T T

T

LT T

HH
HH
HH
T T T T T TN HH

@

AINO TH

for({int i = 0;

i<numbers.length;

System.out.print (numbers[i]

i++)
+ "

{

");

}
System.out.println();
System.out.println("left:

"

System.out.println("right:

+ left);

" + right);

}
System.out.println("quickSort from start:
quickSort (start,

right,

System.cut.println("quickSort from left:
quicksSort (left,

finish,

" + start + " right:

" + right);

" + left + " finish:

" + finish);

numbers);

numbers);

}
§

public static void main(Stringl[]

{

:

int numbers[] = {16,13,4,6,22,1,9,5};

|HH

quickSort
(0, numbers.length-1,

H
HH

for(int i = 0;

args)

numbers);

i<numbers.length;

i++)

System.out.print (numbers[i]l+ "

{

HH
HH
HH
HH
H

");

HH
HH
H

)
BT

T LT LT T T T

T

T

LT T

L T T

T LTI T TR TTT T H

T

'
1
1
1
1
1
1
1
1
1
1
1

i
def quickSort (start,

finish,

1
1
1
1
1
1
1
1
1
1
1

numbers):

if (start==finish)
:
return
left = start

right

finish

:

pivot = numbers[int ((start+finish)/2)]

:
1
1
1

print ("start: ", start, "finish:
right, "pivot: ", pivot)

:

.
:

while left<right:
while numbers[left]<pivot:

"left:

",

left,

"right:

",

:
1
1
1
:

:

print ("left: ", left)

]

while numbers [right] >pivot:

:

right = right -

print ("right:

:

finish,

left = left + 1

1
1

1

",

:

1

", right)

if left<=right:

:
:

1
1

1

temp = numbers[left]

:

numbers [left]

:

numbers [right] = temp

:

:

left = left + 1

:

:

right = right - 1
print ()

:

:
L]

= numbers[right]

:
:

:
Ll

B2 Programming

1
for i in range (len(numbers)):
1
1
print (numbers([i], " ", end="")
1
I
print
()
1
1
print("left: ", left)
1
1
print("right: ", right)
I
1
print ("quickSort from start: ", start, " to right: ", right)
1
1
quickSort (start, right, numbers)
1
print ("quickSort from left: ", left, " to finish: ", finish)
1
1
quickSort (left, finish, numbers)
1
1 numbers = [16,13,4,6,22,1,9,5]
1
1 quickSort
(0, len(numbers)-1, numbers)
1
1 for i in range(len(numbers)):
1

1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1

1

1

print (numbers[i],

1

"

",

end="")

1

[0] [1] [2] (3] [4] [5] [6] (7]

116)13[4[6]22[ 1] 95 |smeptsanas

eft: D right:
7 phvot &
left: 1 right: 6

[0] [1] [2] [3] [4)([5])[6] (7]

G

right.5

2[5]13[ 4 [6[22[1 ]9 [16]swep13ana

et 2o

@®Common
.

left: 4 right:
[0] [1] [2]

mistake

3[511(4

Always pay attention

toN
the logic
benind
——
9

[4] [5] [6] [7]

i

write. Many students

implement sorting

algorithms incorrectly

22[13[ 9 [16|swap6ands

[0] [1] [2] (3] [4] [5] [6] [7]
45/1|4|6|22(13[9 |16|swap5and1

[0] [1] [2] [3] [4] [5] [6] [7]

5 . 54161221139 [16|swapsanda

or they cqnfuse
?hebalgcnthrzs
in

[0] [1] [2] [3] [4] [5] [6] (7]

between. For
Lé . Gl

cliD) 9

J0) e 22 ena®

the sorting of an

1741569 .22 16| swap 22.and 16

[0] [1] [2] [3] [4] [5] [6] [7]

array in ascending

order by using the

selection sort,a

common mistake
is to implement an
incorrect bubble sort,
or an algorithm that

left: 0 rl_gm: % pivot 1

.

.

.

L

right:

eft
1rishtt
0

auicksortstar:
0 ight:
0. S35 ey5
quickSort left:
1finish: 2 jeft: 1 right: 2 pivot5
——
ri o
e -

heor
b o Tefca right:
7 pivot 13
r_|ght:6

auicksort left: 4 finish: 7

quickSort start: 4 right: 3 l;gtftsfin '2it5:h317_
quickSort left:
5 finish: 5 ::Efg"ght:?p“‘m 22
quickSort left:
5 finish: 7 ———vou-—

exampie, when the

question is requiring

quickSort start: 0 right: 2 s(:art4f;lfg|nltsh22

i

uickSort start: 5

right: 6 ls(:?rt?;:‘gllrltshﬁs

e

W
quickSort start: 5 right: 4

[0] 1] 121 [3] [4] [5] 16] [7]
8111415

|eﬂ:'5r§gmfg'pivm13

ickSort

left: 6

$onant

finish: 6

quickSort lft: 7 fiish:7

|6|9(13[16(22

M Quicksort

in descending order
instead of ascending,

1

Complete a trace table for a bubble sort algorithm to sort the numbers: 16, 13, 4, 6, 22, 1,9, 5.

as required.

2

Complete a trace table for a selection sort algorithm to sort the numbers: 16, 13,4, 6,22, 1,9, 5.

Pay attention to the

3

Complete a trace table for a quicksort algorithm to sort the numbers: 16, 13, 4, 6, 22, 1, 9, 5.

features of each of
the sorting algorithms

4

Create a table outlining the Big O value for both time and space complexities for all the
searching and sorting algorithms you have studied.

5

Outline the principles of working of a selection sort and a quicksort algorithm.

and understand the

logic behind them.

B2.4 Programming algorithms

@

=
o
Z

=

=<

ATNO TH

B Traversal of binary trees
At this point, you will need to review the binary trees concepts in Section B4.1.4. If you have

not covered this topic yet, take the time to do it now.
Binary trees can be traversed by using a recursive algorithm as well. The logic behind this is
the following:
B Visit a node or display its content.
B Traverse the left subtree.

m

Traverse the right subtree.

The order of those three operations depends on the type of traversal used. For example, in an
in-order traversal you need to follow the left, root, right pattern, as shown in the algorithm
below; as such you will go to the leftmost node and visit it, then the data in the node above,

and then the right node. Once this is done, you move one level up and repeat the process, so
the left subtree will be first traversed, then the root and then the right subtree. In a post-order
traversal you need to follow the left, right, root pattern, and in a pre-order traversal you need
to follow the root, left, right traversal.

Java

1 Python

|

class Node

:

:

class Node:

]

{

def _ init_ (self, value):

1

int data;

:

self.data = value

Node left;

:

self.left = None

:

Node right;

:

self.right = None

!

Node (int value){

: def inorder (root) :

:

1

if root is None:

1

return

:

data = value;
left= right=null;

:

)
class testTraversal |
void inorder (Node root)

{
if

(root == null)

{

:

inorder (root.left)

:

print (root.data,

:

inorder (root.right)

:

:

"

",

end="")

:

:

:

root = Node(5)

:

I

root.left = Node(3)

1

:

root.right = Node (8)

:

:

root.left.left = Node(2)

:

inorder (root.left) ;

:

root.left.right = Node (4)

:

System.out.println({rcot.data);
inorder (root.right) ;

:

root.right.left = Node(5)

:

:

root.right.right = Node (9)

:

}

:

inorder (root)

:

public static void main(Stringl[] args)

e o

o
e
o

return;

)

Node root = new Node(5);
root .left = new Node(3);
root .right = new Node(8);
root .left.left = new Node(2);
root .left.right = new Node(4);
root .right.left = new Node(§);
root .right .right = new Node (9) ;

inorder (root) ;

}

Implement the post-order and pre-order traversals
of a binary tree using recursion.

B
LT P
PP
T T

B2 Programming

=
Thinking skills:
Create novel
solutions to
problems — choose
an iterative
program you have
created before, and

attempttorewrite.
it using a recursive
approach

Use your answer to the programming exercise above to answer the following questions.
1 Did you use two different functions to solve the exercise? Did the functions work
as expected?
2 Did you use any local or global variables? Why did you need any local variables, if
you used any?

(@ Common mistake
B
.
i
Practical questions requiring algorithms to be described often lack clarity. Ensure steps are clearly
outlined. You can support explanations by adding code or pseudocode statements, but those
should be clearly explained to gain marks.

B2.4 Programming algorithms

[}
"‘4_:
=

File processing
SYLLABUS CONTENT
By the end of this chapter, you should be able to:
» B2.5.1 Construct code to perform file-processing operations

When creating a program, you might want to store data permanently so that, once you

close your program or switch off the computer and you turn it on again, the data can still be
retrieved and manipulated. One way to achieve this is to store the data in a file. The program

will be able to manipulate the data stored in several types of files, such as text files (txt),
comma-separated value files (.csv), binary files (.dat), and so on.
4 Absolute path:
the location of a file
specified from the root
directory (the full path).
# Relative path: the
location of a file relative

to the current folder.

To avoid having to use the absolute path of your file (to specify the entire location), save the
file within the same folder as your program. This will allow you to access the file by simply

using its file name, also called the relative path of the file.
A text file is a sequential file, meaning that data in the file can be accessed sequentially (line
by line) and new records will be added to the end of the file.

A file can be opened in several modes: write, read and append. When opening a file in write
mode, new data inserted into the file will overwrite the existing content in the file. Read mode

is used to allow you to access the data from the file to read it, and append mode allows you to
insert new records at the end of the file without erasing previous content.
The process to write text to a text file is as follows:
B Open the file for write or append, as needed.
B Prepare the line of text to be written.

B Write the line to the file.
m Close the file.
The process to read text from a text file is as follows:
B Open the file for read.
B Read the content from the file:
[0 Read a single line from the file.
[0 Use a loop to repeat for all the lines in the file and read them line by line.
[0 Read the entire file into a data structure.
m

Close the file.

File processing in Java
To process files in Java, you can use:

® the Scanner class
m the FileWriter class
m

the BufferedReader class.

B2 Programming

B Scanner class
The Java package java. io includes the Files class that allows you to manipulate files, so
this package needs to be imported first.
To create a file, follow the procedure of creating an object of type File and pass the file name

as a parameter to the constructor.
File f = new File

("fileName.txt");

There are specific methods that can be used on the newly created file:
Method

Explanation

exists( )

Returns true if the file exists on the disk

delete( )

Deletes the file

getName(
length(

)
)

Returns the name of the file
Returns the number of characters in the file

renameTo( ) | Receives a parameter to specify the new name of the file
canRead( )

Returns true if the file can be read

You have already used the Scanner class several times by now to read input from the
keyboard. You can use the same class to read a file, by passing a file object as a parameter.
Scanner nameOfScanner = new Scanner

(f);

In the line of code above, the nameOfScannexr variable is an identifier, chosen to label the
scanner for furure use, and the f variable passed to the Scanner constructor is the file object
created above.
The same purpose can be achieved by using:
Scanner nameQfScanner = new Scanner

(new File

("fileName.txt"));

The Scanner uses tokens. When you use a function like nextLine (), the Scanner will
split the input into tokens (units of user input, separated by whitespaces).
Tor example, if the text file conrains the following rwo lines of text:
"Bobby Bob"
3 75.5

the Scanner will split this into tokens, as follows:
Token

Possible data types

"Bobby

string

Bob"

string

3

int, double, string

75.5

double, string

Each call to the functions next ( ), nextInt( ),nextDouble( ),and so on, will

consume a token, meaning it will read the token and advance the cursor to the next one.
Consider the following exercise: Construct a program that will read five numbers from the text

file called “numbers” and will output their average.

B2.5

File processing

-

Consider that the text file includes the following numbers on five different lines:

Java
i

import java.util.*;

§

import java.io.=*;
public static void main(String[]

3
§
args)

{

i

try {
Scanner read = new Scanner (new File ("numbers.txt"));
double sum = 0.0;

:

double average = 0.0;
for (int i = 0; i<5; i++)

i
{

double value = read.nextDouble();
sum = sum + value;

}
average = sum/5;
System.out.println("average is:

" + average);

} catch (FileNotFoundException e)

{

i

i

e.printStackTrace
() ;

In the code above, the function nextDouble ( ) is used to read the next token in the file,

as the problem already described the data type of the values stored in the file. But in case
you don't know what type of data is stored, the scanner has functions that will return true or

false when checking whether the next token is of a specific data type. As such, the function
hasNextInt( ) will return true if there is a next token in the file of darta type integer.
Similarly, you can use hasNextDouble ( ) or hasNextLine ( ).
Another structure used above is a FOR loop that repeats five times. This is possible as the
number of lines in the text file is known. In case that is unknown information, a conditional
loop can be used to repeat, as long as there is a next token in the file. The condition would
include the function hasNext ( ).
To read a file line by line, the function nextLine ( )

can be used.

B2 Programming

import java.io.*;
public static void main(String[]

args)

{

try{
Scanner read = new Scanner (new File("numbers.txt"));

{
R

while (read.hasNext
())

PR T P PP T TP P TP T TP TP PP TP TP

import java.util.*;

TP

Java

String line = read.nextLine();
);

T

System.out .println{line

}
{

T

} catch (FileNotFoundException e)

B

L R

e.printStackTrace () ;

Even if the values stored in the file are of decimal numbers, they can be read with
nextLine ( ), which interprets them as being of string data type. This is because, as
described above, the values stored in a file can have more possible data types. If a conversion is
possible to one of the required data types, there will be no error thrown.
In both examples, a try/catch block is used for exception handling. This is because the text
file might not exist, or any other error might occur when reading the data and performing the
required operations. By using exception handling techniques, the code will not crash.
The java. io package is used for both input and output. Therefore, it also includes the
PrintStream, which allows you to write output to the text file.

Java
H
HH

import java.uktil.*;
import java.io.*;
public static void main(String[]

args)

{

try{
PrintStream out = new PrintStream(new File
("numbers.txt")) ;
out.println("Hello world!");
out.println("I added content to the text

} catch (FileNotFoundException e)

filel");

({

——

e.printStackTrace
() ;

When creating the PrintStream, the out variable has been used as an identifier. The file
passed as a parameter is generated by calling the constructor called File. In case this file
already exists, it will be overwritten. Otherwise, a new file called numbers . txt will be created.

It is important to keep in mind that you should not opena file for both reading and writing at
the same time (Scanner and PrintStream).
B2.5

File processing

If you want to append data to the file so the new text will be added at the end of the
file, rather than overwriting its contents, you can replace the File constructor with
FileOutputStream and pass the parameter true together with the file name to it. By
setting the second parameter to true, it sets the file to append mode.

Java
import java.util.*;
import java.io.*;
public static void main(String[]

args)

{

try {
PrintStream out = new PrintStream(new
FileOutputStream("numbers.txt",

true));

out.println("A new line appended!");
H

out.close
() ;

}
-

catch

(FileNotFoundException e)

{

e.printStackTrace() ;

The PrintStream can be closed at the end, by simply using the close (

) function:

out.close ().

B FileWriter class
The FileWriter classisalso partof the java. io package, and it is used to write data in
character form to the file (streams of characters). To create a FileWriter, simply create a

FileWriter object that will pass the file name as a parameter to the constructor.
FileWriter out = new FileWriter ("numbers.txt");

Again, it the file does not exist, a new one will be created, bur if it exists it will be overwritten.
To write data to the file, the write ( ) function is used and the writer can be closed by using
the close( ) function.

import java.util.*;

import java.io.*;
public static void main(String[]

args)

{

try {
FileWriter out = new FileWriter ("numbers.txt");
out.write("This is the first

line!");

out.close();

} catch (IOException e)

{

e.printStackTrace() ;

HT T

T TT

B2 Programming

The code above will overwrite the existing text in the file. To open the file in append mode, just
set the append mode to true, by adding a second parameter to the FileWriter constructor.

H
H
H

Java

H
H

import java.ukbtil.*;

H

import java.io.*;
public static void main(String[]

args)

{

try {
FileWriter out = new FileWriter("numbers.txt",

true);

out .write("This is the second line!");
out.close();

} catch (IOException e)

{

e._printStackTrace () ;

H

H

H
HH

H
HH

H

H

To read data from a file in character format, FileReader can be used.
FileReader read = new FileReader ("numbers.txt");

This allows you to read a single character from the file with the read ( ) method, to read
the characters from the file and store them into a named array with the read (char [ 1]
arrayName), or to read a given number of characters from the file starting at a specific index
and store them into a named array with read (char[ ]

arrayName, int startIndex,

Java
import java.util.*;
import java.io.*;
public static void main(String[]
char[]

args)

{

text = new char[100];

try
FileReader reader = new FileReader ("numbers.txt");
reader.read (text) ;
System.out .println(text);
reader.close
() ;

} catch (IOException e)

{

e.printStackTrace();

l BufferedReader class
BufferedReader classisused to read data from a character-based file. It can read a

single character by using the read ( ) function or read an entire line of text by using the
readLine ( ) function. To use the Buf feredReader, there is a need to instantiate a

FileReader objectas well.
B2.5

File processing

P
T PP TP P T PP PP PP PP

H

H

int length).

Java
import java.util.*;
import java.io.*;
public static void main(String[]
char[]

args)

{

text = new char[100];

try {
FileReader reader = new FileReader ("numbers.txt");
BufferedReader br = new BufferedReader (reader) ;
int singleChar = br.read();

while (singleChar!=-1)

{

System.out.print
( (char)singleChar +

"

");

singleChar = br.read();

}
br.close();
reader.close()
;

} catch (IOException e)
e.printStackTrace();

:

Before printing the character, it is converted to a char, as the values read from the

Buf feredReader are integer values representing the given character. If the method returns
—1, it means there are no more characters in the file; therefore, this condition is included in the
conditional loop.
BT

L LT T

T

T LT T T T PT PP PP

PP tassnneas tasesssasessansaisasesaannes

Java
import java.util.*;
import java.io.*;

public static void main(String[]
char[]

args)

{

]

text = new char[100];

i

try {
FileReader reader = new FileReader("numbers.txt");
BufferedReader br = new BufferedReader (reader) ;
String line = br.readLine();

while (line!=null)

{

System.out.println(line)
;
line = br.readLine();

}
br.close();

reader.close() ;
} catch (IOException e)

;

e.printStackTrace () ;

:
;
E

pu—

E

{

B2 Programming

File processing in Python
To process files in Python, use the following functions:
open(

)

|

read(

)

B

readline( )

B

write(

)

u

close(

)

The open () function takes two parameters: the name of the file and the mode the file should
open in. There are several modes available in Python:

B

"w" —write mode: The file is opened for writing text to it:
0O 1If the file does not exist, it creates a new file with the given name.
[0 When adding text in write mode, the new text added will overwrite the previous text.

B

"a" —append mode: The file is opened for adding text at the end of the file:
[0 1If the file does not exist, it creates a new file with the given name.
0 When adding text in append mode, the new text is added at the end of the file, so the
previous text is not overwritten.

B

"r" —read mode: The file is opened for reading data from it:
0 1f the file does not exist, it will throw an error.

The default mode is the read mode. Therefore, writing £ = open ("numbers.txt") is the
same as writing £ = open("numbers.txt",

"r").

Python
f = open("numbers.txt",

"w")

f. write("First line")
f.close()

The code above will create a file called numbers . txt in case it does not exist on the disk,
and it will write the given text to it. Once this is done, the file is closed. If the program is run
again with a different line of text, the existing text in the file will be overwritten.

Python
f = open("numbers.txt",

"w")

f.write("First line")
f.close()

£ = open("numbers.txt",

"r")

print (f.read())
f.closel)
-

e

e e e e e e R e e e e e e R e e R e e e R e e e e e e e e e e e e e e e e o

o

e

The code above opens the file, writes the given text to the file and closes it. Afterwards, the file

is open in read mode, the line is read and displayed, and then the file is closed.
read ( ) will read the entire content of the file so, if the file contains several lines, as shown

below, they will all be displayed. Although this might seem an inefficient method, it can be

B2.5

File processing

used to read the entire content of the file into a data structure, such as a list, and then to

manipulate the data stored in the respective data structure.

Python
f = open('"numbers.txt",

"w")

f.write("First line‘\n")

f.write("Second line\n")
f.closel()

f = open('"numbers.txt",

"r")

print (f.read())
f.closel()

The \n will move the cursor on to the next line after a line of text has been written. To read a
single line of text, the readLine (

) function can be used.

1

1

i1 Python

]

1
:

f = open("numbers.txt",

1

f.write("First line\n")

1

:

f.write("Second line\n")

:

:

f.closel()

:

: f = open("numbers.txt",
1 print (f.readline())
1
1 f.closel()
1

1
:

"w")

"r")

:
1
1
1
1

[

a

In the code above, although the file contains two lines of text, only the first one will be displayed.
To display every line of text in the file, a conditional loop can be used.

Python
try:

f = open ("numbers.txt",

"w")

f .write("First line‘\n")
f.write("Second line\n")
f.close()
f = open("numbers.txt",

"r")

text = f.readline()
while textl!="":

print (text)
text = f.readline()
except:

print ("There was a problem")

In the code above, a new line of text is read until the retrieved line is blank. As manipulating
files might produce several errors, such as the file not being found on the disk, or an operation
on the file being impossible to be completed, it is always a good idea to use exception handling
via try/except blocks.

B2 Programming

f = open ("numbers.txt",

"w")

f.write("First line\n")
f.write("Second line‘\n")
f.close()
f = open("numbers.txt",

Ilrll)

text = f.readline()
while len(text) !=0:

print (text)
text = f.readline()
except:
print ("There was a problem")

The same result can be achieved by changing the condition of the loop to check whether the
retrieved line of text has a length different from 0.
Another way to do this is to use the following loop:

Python
try:

f = open("numbers.txt",

"w")

f.write("First line\n")

f.write("Second line\n")
f.close()
f = open("numbers.txt",

"r")

for line in f:

print (line)
except:
print ("There was a problem")

When creating
programs that
manipulate files, if you
are using a relative
path in your program,
ensure that both the
text file (txt) and the

coding file (.py or .exe)
are within the same
folder. If they are not
within the same folder,
the program won't be
able to access that file
unless the absolute
path is provided.

B2.5

File processing

This would repeat for each line in the file and display it accordingly.
Sometimes, you might want to check whether the file exists before attempting to perform

an operation on it. This can be done by importing the os library and using the os.path.
exists command:
el|

(;Top tip!

1
1
1
1
import os
1
1
if os.path.exists("numbers.txt"):
1
1
print('the file exists")
1
1
else:
1
1
print ("the file does not exist")
1
Fl
e
e e R R R R R e R R R R R R R R R R R R R R R R R R R
e R e e

Python

It is very important to close the file once it has been manipulated for a given mode.

1

Construct a program that checks whether a given file exists (called name .txt). If the file
does not exist, the program asks the user what their name is, prints a personalized greeting

message to them and saves the person’s name into name.txt. If the file does exist, instead
of prompting for their name, it loads the name from the file and prints the personalized
greeting immediately.

2

Construct a program that uses a file to store a number to represent the number of times the
program has run. Every time the program runs, it should increase the number by one and
save the new value.

3
4

Construct programming code that generates 100 random numbers with values between 1
and 70. Store those numbers into a text file, one number per line. Call the file numb. txt.
Construct code that uses the numb.txt file to read the numbers, identify the number of

duplicate values and delete those duplicate values from the file. Output how many numbers
were deleted.

5

Construct code to append to the same file the exact number of elements that were deleted
in guestion 4, including values from 71 to 150.

6

Construct programming code to read the text file and sort the values in ascending order

using an efficient bubble sort algorithm.
7

Construct a program to read the values from the text file and identify the odd numbers. Store
those numbers into a new text file.

R
T
P T

@ Linking questions
1
2

Does database programming in SQL require computational thinking? (A3)
Why is an understanding of variables and their scope important for effective memory
management in computer systems? (Al)

3

Is algorithmic efficiency relevant to machine learning, where large data sets are processed,
and computational cost can be significant? (A4)

4

Are data structures, such as stacks and queues, applicable in networking algorithms for

5

packet routing and load balancing? (A2)
How can graph theory be applied to packet distribution in networks? (Mathematics A&l HL)

6

How do graph algorithms and terminologies, such as vertices and edges, impact machine
learning algorithms like network analysis? (A4, Mathematics A&I HL)

7

How can network traffic be used as an example or connection to programming
algorithms? (A2)
How can programming algorithms be used to develop machine learning methods? (A4)

8

B EssssasssEssssssssERssRaERERERE
R s Rs R s s

SssssEsssEsEssEssssssssEARNEEEANEsEIEEERSERRRERRERSE msssssssssssssssEssEsssEREEREsERERREEES s

IR

B2 Programming

1

Consider the following code that processes an input string:

Java
! public static void content (String text)
§

String value =

{

:

"";

int pos = 0;
while

(pos < text.length())

{

String letter = text.substring(pos,

if

(letter.equals(","))

pos + 1);

{

System.out.println(value) ;

:

value = "";

i

:

} else {

:

i

value += letter;

i

pOsS++;

}
if

(tvalue.isEmpty())

{

——

System.out.println(wvalue) ;

Python
def content (text):
value =

""

pos = 0
while pos<len(text):

letter = text[pos:pos+1]
if letter==",":
print (value)
value=""
else:
value = value + letter
pos = pos + 1
if wvalue:
print (value)

a

Trace the algorithm for the input value of: “car,boat,ball” by copying and completing the following table, up to the
variable pos becoming 7.
VALUE

b
¢

POS

LETTER

LETTER = *,"

[4]

QUTPUT

Deduce the purpose of the algorithm.
The output is dependent on the exact format of the input. Identify two strings that would not generate the

[3]

desired output.

2]

B2.5 File processing

2

A group of friends play a round-robin tournament game of table tennis, where each person plays against each other player
for 5 minutes at a time. The information from the tournament is recorded in parallel arrays (lists), NAMES and SCORES,

examples of which are shown below.
When two people have their round against each other, each player records the points they win in their assigned row, in the
column for the person they are playing against. For example, in the data set below, when Annabelle played against Jack,
SCORES[0] [3] shows that Annabelle scored 4 points, and scorgs [3] [0] shows that Jack scored 8 points.
SCORES
NAMES

0

1

2

3

4

5

0

Annabelle

0

0

3

4

4

3

5

1

Benjamin

1

5

0

3

5

3

3

2

Claire

2

7

5

0

4

3

5

3

Jack

3

8

6

4

0

5

4

4

Fran

4

2

1

4

5

0

2

5

Mark

5

2

3

2

5

4

0

a
b
¢
d

Construct an algorithm that will declare and populate the NnaMES array (list), based on the example data above.
Identify the data type of the elements in the SCORES array (list).
Identify the winning player in the game between Claire and Benjamin.

2]
[1]
[1]

Construct an algorithm that will print the names of players for every round, each player's respective scores and

who the winner was. If the game was a tie, output an appropriate message. For example:
Annabelle scored 3 vs Benjamin scored 5: Benjamin won
Annabelle scored 4 vs Claire scored 7. Claire won
[6]
e

Construct an algorithm that will declare two new parallel arrays (lists) to keep track of a leaderboard based on net

f

should be LeaderName and LeaderPoints. Each player’'s element in the LeaderPoints array should be the
total of points they won minus the total of points they conceded.
For example, the first two rows using the data above would be:
LeaderName
LeaderPoints
Annabelle
-5
(Annabelle won 19 points but conceded 24)
Benjamin
1
(Benjamin won 19 points and conceded 18)
Construct an algorithm that will sort the parallel arrays (lists) of LeaderName and LeaderPoints in descending

points each player has won. Perform the calculations necessary to populate these arrays. The two parallel arrays

order of LeaderPoints.

[8]
[6]

g

3

Construct an algorithm that will save the parallel arrays (lists) of NAMES and SCORES to names.txt and
scores.txt text files.
A company has exported its sales data from a spreadsheet to a couple of text files. NAMES.txt contains a list of the
names of its salespeople and SALES.txt contains a list of the total sales made by each person in the last month.
For example, the first few lines of each file may resemble the following:
NAMES txt
SALES.txt
Amina
23424
Carlos
42549
Emily
52488
Hao
37562
Isabella
44770
a Construct an algorithm that will declare two parallel arrays or lists, NAMES and SALES, open the files and load
their content into the respective array or list. You may assume there is a maximum of 1000 entries in the file.
b Construct an algorithm that will use a recursive quicksort to sort the two parallel arrays or lists by SALES in
descending order.
¢ The content of the NAMES array (list) was iterated over with a loop, and its elements added into an empty stack
(element 0 was the first to be added to the stack). What can be said about the order of the NAMES that will be
popped off the stack in respect to their sales?

(4]

[4]
[8]

[3]

B2 Programming

4

a Define the term "queue”.
b Describe an application that uses a queue in a computer system.
5 State the efficiency of the quicksort algorithm in Big O notation.
6 Outline two uses of a stack in a computer system.
7 Outline the differences between storing a queue in a linear form as opposed to a circular form.
8 State which data type is best for storing a telephone number (e.g. 00352 661 008 990) and give two reasons.
9 Arrays or linked lists can be used to implement stacks and queues.
a Describe the advantage of using an array to implement a stack ora queue.
b Describe the advantage of using a linked list to implement a stack or a queue.
10 The following list of numbers needs to be put into ascending order:
3,1,7,2,4,1,6
State the list that would be obtained after two iterations of a selection sort.

2]
2]
[1]
[4]
[4]
3]
[1]
[1]

[1]

11 Define the term “recursion”.

[1]

12 Construct a program to calculate the sum of numbers from 1 to n using recursion.
13 State one advantage and one disadvantage of recursion vs iteration.

[4]
2]

14 Consider the code shown below.

Java
public static void manipulate(int n,
al0o]

=

int[]

a)

{

15;

}
public static void main(String[]
int[]

a

=

{O,

1};

manipulate(3,

a);

for(int i = 0;

args)

i<a.length; i++)

{

{

System.out.println(alil) ;

'
1
1
1
1
1
1

Python
def manipulate(n,

a):

alol= 15

a=

[0,1]

I
1
1
1
1
1

manipulate (3,a)
print (a)

a
b

State the scope of the variable n.
Aninteger array (list) called b is initialized with the values {11,12,13,14}. The procedure manipulate is called
again with the parameters 14 and b. Explain why the assignment a[0]=15 in the body of the procedure changes
the values stored in the array (list) b.
15 Consider the following data structure:

Java

:

1 Python

1
1 a =
0

-4

[

a
b

State the name of the data structure.
Outline how the data value 3 can be directly accessed.

B2.5 File processing

3]

Pog oo TTTTTTTTmmmm
e me i
:
i
5

int a = {1,2,3,4,5};

[1]

1

1
1
1

[1,2,3,4,5]
e

e

L L L

L L

T

|

[1]
[1]

B3 Object-oriented
programming (OOP)

Fundamentals of OOP
for a single class
Is OOP an appropriate paradigm for solving complex problems?

SYLLABUS CONTENT
yvYyvvywyy

By the end of this chapter, you should be able to:
B3.1.1 Evaluate the fundamentals of OOP
B3.1.2 Construct a design of classes, their methods and behaviour

B3.1.4 Construct code to define classes and instantiate objects
B3.1.5 Explain and apply the concepts of encapsulation and information hiding in OOP

B3.1.3 Distinguish between static and non-static variables and methods

B3.1.1 Fundamentals of OOP
# Object-oriented

Object-oriented programming (OOP) is a paradigm in Computer Science that increases

programming: a

modularity by providing a new type of abstraction.

form of programming
that involves creating
code for classes of
objects, allowing many
such objects to be
created from a single
code base, achieving
a more modular and
extensible software
development process.
It is like the idea of
producing architectural
blueprints, from which
many similar houses can
be constructed.

Just as you have experienced the benefits of modularity through writing functions that allow

you to standardize behaviour for a given combination of input parameters, OOP lets you take
this even further. It allows you not only to standardize behaviour, but also to standardize the
structure of the data within your code.
OOP achieves this level of modularity by empowering you to define custom data types,
known as “classes”. You are no longer constrained to basic data types like integers, floats and
strings; you can now craft custom variables of types such as Person, Book, BankAccount
or ShoppingBasket. Similar to creating various instances of integers or strings, you can
instantiate numerous instances of your classes.
When you manage existing dara types like strings and integers, they come with standardized
methods for setting their values and for manipulation. For example, with strings, you don't
need to program custom functions to extract substrings, locate the first occurrence of a
character or convert to uppercase or lowercase. These capabilities are inherent to the data
type. With OOP, you tailor functionality specitically for your class, creating methods that
align with the nature of the data it represents. Furthermore, similarly to using strings and
integers without knowledge of their internal storage mechanisms, the internal data structure
of your classes remains encapsulated, hidden behind the interface you provide as the creator of

the class.

B2 End-of-topic QUeSHIONS. ... e 413

B2 N BIWOTKS . ...
et
e ettt et et e an e
e 100
A2
Network funNdameEntals. ... ...
e
e et ee et e e e e e eae e se e esnesaennesnesnaenennensennsanennes 1O
A2.2
NEIWOTK ArChItECIUNE .. ...
e et
e e et et e e eaeenesananeenesneensnnsneennennennen| 24
A2.3
(D = (14T 4 T (o] o U
RURURPRRRR 47
A2.4
NEWOTK SEOUNLY . ..ottt
e e e e e e e eeeaa s e ansaaaannaaannnaasnnaasnnnaennnaeennnne |O4
B2 Programming

*

B2 PrOogramiming .. ...ttt
e e e e e e e e e et et eteaaesnnesnanatenaenanneananaaennn 336
B2.1
Programming fundamentals..... ...
e
arn e e e e e eeennes 33T
B2.2
Data SIUCTUIES ...ttt
e e et e et e e s et s ee e snaeaneeans e eeerannaaesnnnneeensennees SO0
B2.3
Programming CONSIIUCES ... ..
ettt et e e e e e e e e e esnneee e aesnaaennnnaas 302
B2.4
Programming algorithms . ...
et
e e e e e eee e aaa i aaannnaas 3/ O
B2.5
Flle PrOCESSING ...ttt
et
e e e e e e e eee e e e e ennaaannaannnaaannaannnnennnnaeennanennnens D07
